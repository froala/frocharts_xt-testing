
/**!
 * @license FusionCharts JavaScript Library
 * Copyright FusionCharts Technologies LLP
 * License Information at <http://www.fusioncharts.com/license>
 *
 * @version 3.13.0-alpha.2
 *
 * @attributions (infers respective third-party copyrights)
 * Raphael 2.1.0 (modified as 'Red Raphael') <http://raphaeljs.com/license.html>
 * JSON v2 <http://www.JSON.org/js.html>
 * Firebug Lite 1.3.0 <http://getfirebug.com/firebuglite>
 */


(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("FusionCharts", [], factory);
	else if(typeof exports === 'object')
		exports["FusionCharts"] = factory();
	else
		root["FusionCharts"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return webpackJsonpFusionCharts([0],{

/***/ 112:
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ 144:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._checkPointerOverPlot = exports._checkPointerOverErrorBar = exports._firePlotEvent = exports._rolloutResponseSetter = exports._rolloverResponseSetter = exports.removeElements = exports._getHoveredPlot = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _dependencyManager = __webpack_require__(6);

var _errorBar2DAnimation = __webpack_require__(804);

var _errorBar2DAnimation2 = _interopRequireDefault(_errorBar2DAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var colorStrings = _lib.preDefStr.colors,
    COLOR_AAAAAA = colorStrings.AAAAAA,
    ROUND = _lib.preDefStr.ROUND,
    MOUSEOVER = 'mouseOver',
    MOUSEOUT = 'mouseOut',
    PERCENTAGESTRING = _lib.preDefStr.PERCENTAGESTRING,
    pStr = _lib.preDefStr.pStr,
    sStr = _lib.preDefStr.sStr,
    BLANKSTRING = '',
    UNDEF = void 0,
    removeElements = void 0,
    ROLLOVER = 'DataPlotRollOver',
    ROLLOUT = 'DataPlotRollOut',
    COMMASPACE = ', ',

// showHoverEffectStr = preDefStr.showHoverEffectStr,
// SETROLLOVERATTR = preDefStr.setRolloverAttrStr,
// SETROLLOUTATTR = preDefStr.setRolloutAttrStr,
DEFAULT_CURSOR = 'default',
    POINTER = 'pointer',
    EVENTARGS = 'eventArgs',
    GROUPID = 'groupId',
    M = 'M',
    H = 'H',
    V = 'V',
    _getHoveredPlot = void 0,
    _firePlotEvent = void 0,
    _checkPointerOverPlot = void 0,
    _checkPointerOverErrorBar = void 0,
    _rolloverResponseSetter = function _rolloverResponseSetter(chart, data, event, dataset) {
  var dataGraphics = data.graphics,
      errorBarHovered = data.errorBarHovered,
      elem = dataGraphics && dataGraphics.element,
      animationManager = chart.getFromEnv('animationManager'),
      elData = elem && elem.getData();

  if (!errorBarHovered && elem && elData.showHoverEffect !== 0) {
    animationManager.setAnimationState(MOUSEOVER);
    animationManager.setAnimation({
      el: elem,
      label: 'rect',
      component: dataset,
      attr: elem.getData().setRolloverAttr
    });
  }
  elem && _lib.plotEventHandler.call(elem, chart, event, ROLLOVER);
},
    _rolloutResponseSetter = function _rolloutResponseSetter(chart, data, event, dataset) {
  var dataGraphics = data.graphics,
      errorBarHovered = data.errorBarHovered,
      elem = dataGraphics && dataGraphics.element,
      animationManager = chart.getFromEnv('animationManager'),
      elData = elem && elem.getData();

  if (!errorBarHovered && elem && elData.showHoverEffect !== 0) {
    animationManager.setAnimationState(MOUSEOUT);
    animationManager.setAnimation({
      el: elem,
      label: 'rect',
      component: dataset,
      attr: elem.getData().setRolloutAttr
    });
  }
  elem && _lib.plotEventHandler.call(elem, chart, event, ROLLOUT);
},
    convertColor = _lib.graphics.convertColor;
(0, _dependencyManager.addDep)({
  name: 'errorbar2DColumnAnimation',
  type: 'animationRule',
  extension: _errorBar2DAnimation2['default'].column
});
(0, _dependencyManager.addDep)({
  name: 'errorbar2DErrorAnimation',
  type: 'animationRule',
  extension: _errorBar2DAnimation2['default'].error
});

var ErrorBar2DDataset = function (_ColumnDataset) {
  _inherits(ErrorBar2DDataset, _ColumnDataset);

  function ErrorBar2DDataset() {
    _classCallCheck(this, ErrorBar2DDataset);

    return _possibleConstructorReturn(this, _ColumnDataset.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  ErrorBar2DDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  ErrorBar2DDataset.prototype.getName = function getName() {
    return 'errorBar2D';
  };
  /*
   * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
   * This function is called once from the init() function of the Column class.
   */


  ErrorBar2DDataset.prototype.ErrorValueConfigure = function ErrorValueConfigure() {
    var dataSet = this,
        conf = dataSet.config,

    // fcJSON = dataSet.fcJSON,
    JSONData = conf.JSONData,
        setDataArr = JSONData.data,
        setDataLen = setDataArr && setDataArr.length,
        chartAttr = dataSet.getFromEnv('chart-attrib'),
        setData,
        dataObj,
        config,
        dataStore = dataSet.components.data,
        yAxisName = (0, _lib.parseUnsafeString)(chartAttr.yaxisname),
        xAxisName = (0, _lib.parseUnsafeString)(chartAttr.xaxisname),
        toolText,
        seriesNameInTooltip = (0, _lib.pluckNumber)(chartAttr.seriesnameintooltip, 1),
        seriesname,
        tooltipSepChar = (0, _lib.parseUnsafeString)((0, _lib.pluck)(chartAttr.tooltipsepchar, COMMASPACE)),
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        errorInPercent,
        macroIndices,
        parserConfig,
        toolTipValue,
        errorBarAlpha,
        setErrorValue,
        formatedVal,
        setTooltext,
        errorBarShadow,
        maxValue = -Infinity,
        minValue = Infinity,
        parentYAxis,
        setValue,
        errorValue,
        maxErrorValue,
        xAxis = dataSet.getFromEnv('xAxis'),
        catLen = xAxis.getTicksLen(),
        len = Math.min(catLen, setDataLen),
        minErrorValue,
        halfErrorBar,
        positiveErrorValue,
        negativeErrorValue,
        cumulativeValueOnErrorBar,
        positiveCumulativeErrorTooltext,
        negativeCumulativeErrorTooltext,
        getTooltext = function getTooltext(setTooltext) {
      var toolText;

      if (!conf.showTooltip) {
        toolText = false;
      } else {
        if (formatedVal === null) {
          toolText = false;
        } else if (setTooltext !== UNDEF) {
          macroIndices = [1, 2, 3, 4, 5, 6, 7, 99, 100, 101, 102, 120, 121];
          parserConfig = {
            yaxisName: yAxisName,
            xaxisName: xAxisName,
            formattedValue: config.toolTipValue,
            errorValue: setErrorValue,
            errorDataValue: config.errorToolTipValue,
            errorPercentValue: config.errorPercentValue,
            errorPercentDataValue: config.errorPercentValue,
            positiveErrorValue: config.positiveErrorToolTipValue,
            negativeErrorValue: config.negativeErrorToolTipValue,
            label: config.label
          };
          toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, setData, chartAttr, JSONData);
        } else {
          if (seriesNameInTooltip) {
            seriesname = (0, _lib.getFirstValue)(JSONData && JSONData.seriesname);
          }
          toolText = seriesname ? seriesname + tooltipSepChar : BLANKSTRING;
          toolText += config.label ? config.label + tooltipSepChar : BLANKSTRING;
        }
      }
      return toolText;
    },
        positiveErrorToolText,
        negativeErrorToolText,
        i;
    conf.showTooltip = (0, _lib.pluckNumber)(chartAttr.showtooltip, 1);
    conf.errorInPercent = errorInPercent = (0, _lib.pluckNumber)(JSONData.errorinpercent, chartAttr.errorinpercent);
    conf.showValues = (0, _lib.pluckNumber)(JSONData.showvalues, chartAttr.showvalues, 0);
    conf.errorBarShadow = errorBarShadow = (0, _lib.pluckNumber)(chartAttr.errorbarshadow, chartAttr.showshadow, 1);
    conf.ignoreEmptyDatasets = (0, _lib.pluckNumber)(JSONData.ignoreemptydatasets, 0);
    halfErrorBar = (0, _lib.pluckNumber)(chartAttr.halferrorbar, 1);
    conf.notHalfErrorBar = !(0, _lib.pluckNumber)(chartAttr.halferrorbar, 1);

    errorBarAlpha = (0, _lib.getFirstAlpha)((0, _lib.pluck)(JSONData.errorbaralpha, chartAttr.errorbaralpha, conf.plotFillAlpha));
    conf.errorBarWidthPercent = (0, _lib.pluckNumber)(JSONData.errorbarwidthpercent, chartAttr.errorbarwidthpercent, 70);
    conf.errorBarColor = convertColor((0, _lib.getFirstColor)((0, _lib.pluck)(JSONData.errorbarcolor, chartAttr.errorbarcolor, COLOR_AAAAAA)), errorBarAlpha);
    conf.errorBarThickness = (0, _lib.pluckNumber)(JSONData.errorbarthickness, chartAttr.errorbarthickness, 1);
    conf.shadowOpacity = errorBarShadow ? errorBarAlpha / 250 : 0;
    conf.parentYAxis = parentYAxis = (0, _lib.pluck)(JSONData.parentyaxis && JSONData.parentyaxis.toLowerCase(), pStr) === sStr ? 1 : 0;

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      if (!dataObj) {
        continue;
      }
      setData = setDataArr && setDataArr[i];
      config = dataObj && dataObj.config;
      positiveErrorToolText = UNDEF;
      negativeErrorToolText = UNDEF;

      if ((0, _lib.pluckNumber)(setData.value) === UNDEF) {
        continue;
      }

      if (!dataObj) {
        dataObj = dataStore[i] = {
          graphics: {}
        };
      }

      if (!dataObj.config) {
        config = dataStore[i].config = {};
      }
      setValue = config.setValue;
      config.setErrorValue = setErrorValue = numberFormatter.getCleanValue(setData.errorvalue);
      config.errorInPercent = (0, _lib.pluckNumber)(setData.errorinpercent, errorInPercent, 0);

      config.errorInPercent && (config.setErrorValue = setErrorValue = (0, _lib.pluckNumber)((setErrorValue / 100 * setValue).toFixed(2)));

      config.cumulativeValueOnErrorBar = (0, _lib.pluckNumber)(setData.cumulativevalueonerrorbar, conf.cumulativeValueOnErrorBar, 1);

      config.positiveErrorValue = numberFormatter.getCleanValue((0, _lib.pluckNumber)(setData.positiveerrorvalue, setData.errorvalue));

      config.errorInPercent && config.positiveErrorValue && (config.positiveErrorValue = (0, _lib.pluckNumber)((config.positiveErrorValue / 100 * setValue).toFixed(2)));
      config.positiveCumulativeErrorValue = setValue + (0, _lib.pluckNumber)(config.positiveErrorValue, config.setErrorValue);

      config.negativeErrorValue = numberFormatter.getCleanValue((0, _lib.pluckNumber)(setData.negativeerrorvalue, setData.errorvalue));

      config.errorInPercent && config.negativeErrorValue && (config.negativeErrorValue = (0, _lib.pluckNumber)((config.negativeErrorValue / 100 * setValue).toFixed(2)));

      config.negativeCumulativeErrorValue = setValue - (0, _lib.pluckNumber)(config.negativeErrorValue, config.setErrorValue);

      config.errorToolTipValue = numberFormatter.dataLabels(setErrorValue, parentYAxis);

      config.negativeErrorToolTipValue = numberFormatter.dataLabels(config.negativeErrorValue, parentYAxis);

      config.negativeCumulativeErrorTooltipValue = numberFormatter.dataLabels(config.negativeCumulativeErrorValue, parentYAxis);

      config.positiveErrorToolTipValue = numberFormatter.dataLabels(config.positiveErrorValue, parentYAxis);

      config.positiveCumulativeErrorTooltipValue = numberFormatter.dataLabels(config.positiveCumulativeErrorValue, parentYAxis);

      config.errorPercentValue = Math.round(setErrorValue / setValue * _lib.HUNDREDSTRING * _lib.HUNDREDSTRING) / _lib.HUNDREDSTRING + PERCENTAGESTRING;

      cumulativeValueOnErrorBar = config.cumulativeValueOnErrorBar;

      config.notHalfErrorBar = conf.notHalfErrorBar;
      config.halfErrorBar = halfErrorBar;

      config.showValue = (0, _lib.pluckNumber)(setData.showvalue, conf.showValues);
      config.hasErrorValue = (0, _lib.pluckNumber)(setData.errorvalue) !== UNDEF ? 1 : 0;

      errorValue = config.errorValue = setErrorValue;

      toolTipValue = config.errorToolTipValue;

      formatedVal = toolTipValue;

      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, formatedVal)));

      toolText = getTooltext(setTooltext);

      positiveErrorToolText = negativeErrorToolText = UNDEF;

      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, config.positiveErrorToolTipValue)));

      setTooltext && config.positiveErrorToolTipValue && (positiveErrorToolText = getTooltext(setTooltext));

      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, config.negativeErrorToolTipValue)));

      setTooltext && config.negativeErrorToolTipValue && (negativeErrorToolText = getTooltext(setTooltext));

      if (cumulativeValueOnErrorBar) {
        setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, config.positiveCumulativeErrorTooltipValue)));

        setTooltext && config.positiveCumulativeErrorTooltipValue && (positiveCumulativeErrorTooltext = getTooltext(setTooltext));

        setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, config.negativeCumulativeErrorTooltipValue)));

        setTooltext && config.negativeCumulativeErrorTooltipValue && (negativeCumulativeErrorTooltext = getTooltext(setTooltext));
      }

      positiveErrorValue = config.positiveErrorValue;

      negativeErrorValue = config.negativeErrorValue;

      if (setData.positiveerrorvalue || setData.negativeerrorvalue) {
        config.halfErrorBar = 0;
        config.notHalfErrorBar = true;
      }

      maxErrorValue = setValue + (positiveErrorValue !== null ? positiveErrorValue : setErrorValue);
      minErrorValue = setValue - (config.halfErrorBar ? 0 : negativeErrorValue < 0 && setValue < 0 ? 0 : negativeErrorValue !== null ? negativeErrorValue : setErrorValue);

      maxValue = Math.max(maxValue, maxErrorValue, minErrorValue);
      minValue = Math.min(minValue, maxErrorValue, minErrorValue);

      config.errorValueArr = [];
      config.positiveErrorValue === null && (config.positiveErrorValue = UNDEF);
      errorValue = -config.positiveErrorValue;
      config.errorValueArr.push({
        errorValue: errorValue,
        tooltext: cumulativeValueOnErrorBar ? positiveCumulativeErrorTooltext : positiveErrorToolText || toolText,
        errorEdgeBar: true
      });

      config.errorValueArr.push({
        errorValue: errorValue,
        tooltext: positiveErrorToolText || toolText
      });

      if (config.notHalfErrorBar) {
        errorValue = config.negativeErrorValue;
        config.errorValueArr.push({
          errorValue: errorValue,
          tooltext: cumulativeValueOnErrorBar ? negativeCumulativeErrorTooltext : negativeErrorToolText || toolText,
          errorEdgeBar: true
        });
        config.errorValueArr.push({
          errorValue: errorValue,
          tooltext: negativeErrorToolText || toolText
        });
      }
    }
    conf.maxValue = maxValue;
    conf.minValue = minValue;
  };

  ErrorBar2DDataset.prototype.drawErrorValue = function drawErrorValue() {
    var dataSet = this,
        datasetIndex = dataSet.getJSONIndex(),
        conf = dataSet.config,
        attr,
        i,
        k,
        visible = dataSet.getState('visible'),
        chart = dataSet.getFromEnv('chart'),
        yAxis = dataSet.getFromEnv('yAxis'),
        dataStore = dataSet.components.data,
        errorBarThickness = conf.errorBarThickness,
        errorBarWidthPercent = conf.errorBarWidthPercent,
        errorBarColor = conf.errorBarColor,
        showTooltip = conf.showTooltip,
        shadowOpacity = conf.shadowOpacity,
        errorGroupContainer = dataSet.getContainer('errorPlotGroup'),
        errorShadowContainer = dataSet.getContainer('errorShadowGroup'),
        setLink,
        xPos,
        yPos,
        useCrispErrorPath = 1,
        dataObj,
        setValue,
        config,
        animState,
        scrollMinVal = conf.scrollMinVal,
        scrollMaxVal = conf.scrollMaxVal,
        crispY,
        crispX,
        errorPath,
        errorValPos,
        errorValuePosFactor,
        errorValueArr,
        errorValueObj,
        errorValue,
        errorStartPos,
        errorLen,
        errorBarWidth,
        halfErrorBarW,
        groupId,
        errorLineElem,
        isNegative,
        barXpos,
        barYpos,
        barWidth,
        barHeight,
        errorStartValue,
        trackerConfig,
        trackerTolerance,
        errorTrackerConfig,
        callbackFn = function callbackFn(state) {
      return function () {
        if (state === 'disappearing') {
          this.hide();
        }
      };
    },
        animationManager = dataSet.getFromEnv('animationManager');

    // Loop through each data points
    for (i = scrollMinVal; i < scrollMaxVal; i++) {
      dataObj = dataStore[i];
      if (!dataObj) {
        continue;
      }
      trackerConfig = dataObj.trackerConfig;
      errorTrackerConfig = dataObj.errorTrackerConfig = {};
      errorTrackerConfig.errorTrackerArr = [];
      config = dataObj && dataObj.config;
      setValue = config && config.setValue;
      // If plot value is found "null", continue the loop to next iteration.
      if (dataObj === UNDEF) {
        continue;
      } else if (dataObj && (setValue === UNDEF || setValue === null || config.errorValue === BLANKSTRING || config.errorValue === UNDEF || config.errorValue === null && config.positiveErrorValue === null && config.negativeErrorValue === null)) {
        // hide error bars
        errorLen = dataObj.graphics.error && dataObj.graphics.error.length;
        for (k = 0; k < errorLen; k++) {
          if (dataObj.graphics.error && dataObj.graphics.error[k]) {
            animationManager.setAnimation({
              el: dataObj.graphics.error[k],
              label: 'path',
              callback: callbackFn('disappearing')
            });
            dataObj.graphics.error[k].shadow({ opacity: 0 });
          }
        }
        continue;
      }

      dataObj.errorBar && delete dataObj.errorBar;

      errorValueArr = config.errorValueArr;
      errorTrackerConfig.errorLen = errorLen = errorValueArr.length;

      !dataObj.graphics.error && (dataObj.graphics.error = []);

      groupId = datasetIndex + '_' + i;

      setLink = config.setLink;

      isNegative = setValue < 0;

      barXpos = dataObj._xPos;
      barYpos = dataObj._yPos;
      barWidth = dataObj._width;
      barHeight = dataObj._height;

      yPos = isNegative ? barYpos + barHeight : barYpos;
      xPos = barXpos + barWidth / 2;

      dataObj.errorBar || (dataObj.errorBar = []);

      // Loop through errorValue array
      while (errorLen--) {
        errorLineElem = null;

        errorTrackerConfig.errorTrackerArr[errorLen] = {};

        errorValueObj = errorValueArr[errorLen];
        errorTrackerConfig.errorTrackerArr[errorLen].tooltext = errorValueObj.tooltext;
        errorStartValue = errorValueObj.errorStartValue;
        errorStartPos = !isNaN(errorStartValue) ? yAxis.getPixel(errorStartValue) : yPos;
        errorValue = errorValueObj.errorValue;
        if (errorValue === null || isNaN(errorValue)) {
          if (dataObj.graphics.error && dataObj.graphics.error[errorLen]) {
            animationManager.setAnimation({
              el: dataObj.graphics.error[errorLen],
              dom: 'path',
              callback: callbackFn('disappearing')
            }).shadow({ opacity: 0 });
          }

          continue;
        }
        errorBarWidth = barWidth * (errorBarWidthPercent / 100);
        halfErrorBarW = errorBarWidth / 2;

        errorValuePosFactor = visible ? -1 : 0;
        // Vertical Error drawing
        errorValPos = yAxis.getPixel(yAxis.getValue(!isNaN(errorStartValue) ? errorStartPos : barYpos) + errorValue * errorValuePosFactor, { wrtVisible: true });
        isNegative && (errorValPos = errorValPos + barHeight);
        crispY = errorValPos;
        crispX = xPos;
        errorBarThickness = (0, _lib.pluckNumber)(errorValueObj.errorBarThickness, errorBarThickness);
        trackerTolerance = errorBarThickness > 5 ? errorBarThickness / 2 : 2.5;
        if (useCrispErrorPath) {
          crispY = Math.round(errorValPos) + errorBarThickness % 2 / 2;
          crispX = Math.round(xPos) + errorBarThickness % 2 / 2;
        }
        dataObj.errorBar[errorLen] || (dataObj.errorBar[errorLen] = []);
        if (errorValueObj.errorEdgeBar) {
          errorPath = [M, crispX - halfErrorBarW, crispY, H, crispX + halfErrorBarW];
          dataObj.errorBar[errorLen][1] = {
            _xPos: crispX - halfErrorBarW - trackerTolerance,
            _yPos: crispY - trackerTolerance,
            _height: 2 * trackerTolerance,
            _width: 2 * (halfErrorBarW + trackerTolerance),
            _toolText: errorValueObj.tooltext
          };
        } else {
          errorPath = [M, crispX, errorStartPos, V, crispY];
          dataObj.errorBar[errorLen][0] = {
            _xPos: crispX - trackerTolerance,
            _yPos: crispY < errorStartPos ? crispY : errorStartPos,
            _height: Math.abs(errorStartPos - crispY),
            _width: 2 * trackerTolerance,
            _toolText: errorValueObj.tooltext
          };
        }
        errorBarColor = (0, _lib.pluck)(errorValueObj.errorBarColor, errorBarColor);
        attr = {
          path: errorPath,
          stroke: errorBarColor,
          // In case of tooltip disabled this element should act as the hot element.
          ishot: !showTooltip,
          'stroke-width': errorBarThickness,
          'cursor': setLink ? POINTER : BLANKSTRING,
          'stroke-linecap': ROUND
        };
        if (dataObj.graphics.error[errorLen]) {
          if (dataSet.getState('visible')) {
            animState = 'updating';
          } else {
            animState = 'disappearing';
          }
        } else {
          animState = 'appearing';
        }
        errorLineElem = dataObj.graphics.error[errorLen] = animationManager.setAnimation({
          el: dataObj.graphics.error[errorLen] || 'path',
          container: errorGroupContainer,
          component: dataSet,
          attr: attr,
          dom: 'path',
          state: animState,
          callback: callbackFn(animState)
        }).shadow({ opacity: shadowOpacity }, errorShadowContainer);

        errorLineElem.show();

        chart.config.enablemousetracking && errorLineElem.data(GROUPID, groupId).data(EVENTARGS, trackerConfig.eventArgs);
      }

      if (!config.notHalfErrorBar) {
        for (k = 2; k < 4; k++) {
          dataObj.graphics.error && dataObj.graphics.error[k] && animationManager.setAnimation({
            el: dataObj.graphics.error[k],
            dom: 'path',
            callback: callbackFn('disappearing')
          }).shadow({ opacity: 0 });
        }
      }
    }
  };
  /**
   * This method handles all mouse events of an dataset.
   * @param {String} eventType name of the event
   * @param {number} plotIndex index of the plot where this event has been occured
   * @param {Event} originalEvent reference of the original mouse event
   */


  ErrorBar2DDataset.prototype._firePlotEvent = function _firePlotEvent(eventType, plotIndex, e) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        data = dataset.components.data[plotIndex],
        toolTipController = dataset.getFromEnv('toolTipController'),
        setElement = data.graphics.element,
        errorBarHovered = data.errorBarHovered,

    // originalEvent = e.originalEvent,
    style = dataset.getFromEnv('paper').canvas.style,
        config = data.config,
        setLink = config.setLink;

    if (setElement) {
      switch (eventType) {
        case 'mouseover':
          dataset._decideTooltipType(plotIndex, e);
          _rolloverResponseSetter(chart, data, e, this);
          setLink && (style.cursor = POINTER);
          break;
        case 'mouseout':
          toolTipController.hide(dataset.config.currentToolTip);
          _rolloutResponseSetter(chart, data, e, this);
          setLink && (style.cursor = DEFAULT_CURSOR);
          break;
        case 'click':
          _lib.plotEventHandler.call(setElement, chart, e);
          break;
        case 'mousemove':
          dataset._decideTooltipType(plotIndex, e);
          if (errorBarHovered && !data._isRollover) {
            setElement.showHoverEffect !== 0 && setElement.attr(setElement.getData().setRolloutAttr);
            data._isRollover = true;
            data._isRollout = false;
          } else if (!errorBarHovered && !data._isRollout) {
            setElement.showHoverEffect !== 0 && setElement.attr(setElement.getData().setRolloverAttr);
            data._isRollover = false;
            data._isRollout = true;
          }
      }
    }
  };
  // Helper function of _checkPointerOverPlot().


  ErrorBar2DDataset.prototype._checkPointerOverErrorBar = function _checkPointerOverErrorBar(pX, chartX, chartY) {
    var dataset = this,
        dataStore = dataset.components.data,
        pointObj = dataStore[pX],
        hovered,
        errorBarArr,
        errorBarCompArr,
        len,
        errorBarCompLen,
        toolText,
        xPos,
        yPos,
        height,
        width;

    if (!pointObj) {
      return;
    }

    errorBarArr = pointObj.errorBar;

    if (!errorBarArr) {
      return;
    }

    len = errorBarArr && errorBarArr.length;
    while (len--) {
      errorBarCompArr = errorBarArr[len];
      errorBarCompLen = errorBarCompArr && errorBarCompArr.length;
      while (errorBarCompLen--) {
        if (!(errorBarCompArr[errorBarCompLen] && errorBarCompArr[errorBarCompLen]._xPos)) {
          continue;
        }
        xPos = errorBarCompArr[errorBarCompLen]._xPos;
        yPos = errorBarCompArr[errorBarCompLen]._yPos;
        height = errorBarCompArr[errorBarCompLen]._height;
        width = errorBarCompArr[errorBarCompLen]._width;
        toolText = errorBarCompArr[errorBarCompLen]._toolText;

        hovered = chartX >= xPos && chartX <= xPos + width && chartY >= yPos && chartY <= yPos + height;

        if (hovered) {
          return {
            pointIndex: pX,
            hovered: hovered,
            pointObj: dataStore[pX],
            toolText: toolText
          };
        }
      }
    }
  };
  // Helper function of _getHoverPlot()


  ErrorBar2DDataset.prototype._checkPointerOverPlot = function _checkPointerOverPlot(pX, chartX, chartY) {
    var dataSet = this,
        dataStore = dataSet.components.data,
        data = dataStore[pX],
        config = data && data.config,
        hoverInfo;

    if (!data) {
      return;
    }

    hoverInfo = dataSet._checkPointerOverErrorBar(pX, chartX, chartY);
    if (hoverInfo) {
      data.errorBarHovered = true;
      config.finalTooltext = hoverInfo.toolText;
    } else {
      hoverInfo = dataSet._checkPointerOverColumn(pX, chartX, chartY);
      data.errorBarHovered = false;

      hoverInfo && (config.finalTooltext = config.toolText !== false && config.toolText + config.toolTipValue);
    }

    return hoverInfo;
  };
  /**
         * Function that retunr the nearest plot details
         * @param {number} x x-axis position of the mouse cordinate
         * @param {number} y y-axis position of the mouse cordinate
         * @return {object} return an object with details of nearest polt and whether it is hovered or not
         */


  ErrorBar2DDataset.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        xAxis = dataset.getFromEnv('xAxis'),
        x,
        pX;

    x = xAxis.getValue(chartX);
    pX = Math.round(x);

    // Checking for overlap between two cosecutive column plots along x-axis
    return pX - x > 0 ? dataset._checkPointerOverPlot(pX, chartX, chartY) || dataset._checkPointerOverPlot(pX - 1, chartX, chartY) : dataset._checkPointerOverPlot(pX + 1, chartX, chartY) || dataset._checkPointerOverPlot(pX, chartX, chartY);
  };
  // Function to remove a data from a dataset during real time update.


  ErrorBar2DDataset.prototype.removeElements = function removeElements() {
    var dataSet = this,
        components = dataSet.components,
        removeDataArr = components.removeDataArr,
        pool = components.pool || (components.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        len = removeDataArr.length,
        removeData,
        graphics,
        callbackFn = function callbackFn(state) {
      return function () {
        if (state === 'disappearing') {
          this.hide();
        }
      };
    },
        animationManager = dataSet.getFromEnv('animationManager'),
        i,
        k;

    for (i = 0; i < len; i++) {
      removeData = removeDataArr[0];
      removeDataArr.splice(0, 1);
      // In case of non existing data plot continue;
      if (!removeData || !removeData.graphics) {
        continue;
      }

      graphics = removeData.graphics;

      graphics.element && graphics.element.hide() && graphics.element.shadow({ opacity: 0 });
      for (k = 0; k < 4; k++) {
        graphics.error[k] && animationManager.setAnimation({
          el: graphics.error[k],
          dom: 'path',
          callback: callbackFn('disappearing')
        }).shadow({ opacity: 0 });
      }

      // Storing the graphic elements for reuse.
      removeData.graphics.element && (pool.element = pool.element.concat(removeData.graphics.element));
      removeData.graphics.hotElement && (pool.hotElement = pool.hotElement.concat(removeData.graphics.hotElement));
      removeData.graphics.label && (pool.label = pool.label.concat(removeData.graphics.label));
    }
    components.pool = pool;
  };

  return ErrorBar2DDataset;
}(_column2['default']);

exports.removeElements = removeElements = ErrorBar2DDataset.prototype.removeElements;
exports._getHoveredPlot = _getHoveredPlot = ErrorBar2DDataset.prototype._getHoveredPlot;
exports._firePlotEvent = _firePlotEvent = ErrorBar2DDataset.prototype._firePlotEvent;
exports._checkPointerOverPlot = _checkPointerOverPlot = ErrorBar2DDataset.prototype._checkPointerOverPlot;
exports._checkPointerOverErrorBar = _checkPointerOverErrorBar = ErrorBar2DDataset.prototype._checkPointerOverErrorBar;
exports._getHoveredPlot = _getHoveredPlot;
exports.removeElements = removeElements;
exports._rolloverResponseSetter = _rolloverResponseSetter;
exports._rolloutResponseSetter = _rolloutResponseSetter;
exports._firePlotEvent = _firePlotEvent;
exports._checkPointerOverErrorBar = _checkPointerOverErrorBar;
exports._checkPointerOverPlot = _checkPointerOverPlot;
exports['default'] = ErrorBar2DDataset;

/***/ }),

/***/ 145:
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(64);
var call = __webpack_require__(378);
var isArrayIter = __webpack_require__(379);
var anObject = __webpack_require__(77);
var toLength = __webpack_require__(65);
var getIterFn = __webpack_require__(380);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ 146:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._parseToolText = exports._firePlotEvent = exports.getPlotIndices = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _errorbar2d = __webpack_require__(144);

var _errorbar2d2 = _interopRequireDefault(_errorbar2d);

var _dependencyManager = __webpack_require__(6);

var _candlestickAnimation = __webpack_require__(881);

var _candlestickAnimation2 = _interopRequireDefault(_candlestickAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var colorStrings = _lib.preDefStr.colors,
    COLOR_B90000 = colorStrings.B90000,
    COLOR_FFFFFF = colorStrings.FFFFFF,
    BLANKSTRING = '',
    UNDEF = void 0,
    DASH_DEF = 'none',
    POINTER = 'pointer',
    DEFAULT_CURSOR = 'default',
    LINE = 'line',
    BOLDSTARTTAG = '<b>',
    BOLDENDTAG = '</b>',
    BLANKSPACE = ' ',
    BREAKSTRING = '<br />',

/**
 * This method handles all mouse events of an dataset.
 * @param {string} eventType    name of the event
 * @param {number} plotIndex    index of the plot where this event has been occured
 * @param {Event}  e            reference of the original mouse event
 */
_firePlotEvent2 = function _firePlotEvent2(eventType, plotIndex, e) {
  var dataset = this,
      chart = dataset.getFromEnv('chart'),
      components = dataset.components,
      dataStore = components.dataRT || components.data,
      data = dataStore[plotIndex],
      toolText,
      currentToolTip = dataset.config.currentToolTip,
      setElement = data.graphics.element,
      originalEvent = e.originalEvent,
      style = chart.getFromEnv('paper').canvas.style,
      toolTipController = dataset.getFromEnv('toolTipController'),
      config,
      setLink;

  if (setElement) {
    config = data.config;
    toolText = config.toolText;
    setLink = config.setLink;
    switch (eventType) {
      case 'mouseover':
        if (toolText) {
          if (currentToolTip) {
            toolTipController.draw(originalEvent, toolText, currentToolTip);
          } else {
            currentToolTip = dataset.config.currentToolTip = toolTipController.draw(originalEvent, toolText);
          }
        }
        // _rolloverResponseSetter(chart, data, originalEvent);
        setLink && (style.cursor = POINTER);
        break;
      case 'mouseout':
        toolTipController.hide(currentToolTip);
        // _rolloutResponseSetter(chart, data, originalEvent);
        setLink && (style.cursor = DEFAULT_CURSOR);
        break;
      case 'click':
        _lib.plotEventHandler.call(setElement, chart, e);
        break;
      case 'mousemove':
        if (toolText) {
          if (currentToolTip) {
            toolTipController.draw(originalEvent, toolText, currentToolTip);
          } else {
            currentToolTip = dataset.config.currentToolTip = toolTipController.draw(originalEvent, toolText);
          }
        }
    }
  }
},

/**
 * fetches data indices wrt. the x pos value
 * @param {number} x  x pos value
 * @return {Array}    contains indices
 */
_getPlotIndices = function _getPlotIndices(x) {
  var dataset = this,
      i,
      minX = Math.floor(x),
      maxX = Math.ceil(x),
      data,
      returnIndices = [],
      sortedData = dataset.config.JSONData && dataset.config.JSONData.data;
  for (i = sortedData.length; i--;) {
    data = sortedData[i];
    if (data.x >= minX && data.x <= maxX) {
      returnIndices.push(i);
    }
  }
  return returnIndices;
},
    __parseToolText = function __parseToolText(i) {
  var dataset = this,
      conf = dataset.config,
      setDataArr = conf.JSONData.data,
      data = dataset.components.data,
      xAxis = dataset.getFromEnv('xAxis'),
      chartAttr = dataset.getFromEnv('chart-attrib'),
      isLine = conf.plotType === LINE ? 1 : 0,
      toolText,
      BLANK = BLANKSTRING,
      setData = setDataArr[i],
      config = data[i].config,
      label = xAxis.getLabel(config.x).label,
      open = config.open,
      close = config.close,
      yAxis = dataset.getFromEnv('yAxis'),
      high = config.high,
      low = config.low,
      volume = config.volume,
      volumeToolText = volume !== UNDEF ? setData.volumetooltext : UNDEF;

  // create the tooltext
  if (!conf.showTooltip) {
    toolText = BLANK;
  } else {
    toolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(volumeToolText, setData.tooltext, conf.volumeToolText, conf.toolText)));

    if (toolText !== UNDEF) {
      toolText = (0, _lib.parseTooltext)(toolText, [3, 5, 6, 10, 54, 55, 56, 57, 58, 59, 60, 61, 81, 82], {
        label: label,
        yaxisName: (0, _lib.parseUnsafeString)(chartAttr.yaxisname),
        xaxisName: (0, _lib.parseUnsafeString)(chartAttr.xaxisname),
        openValue: setData.open,
        openDataValue: yAxis.dataLabels(open),
        closeValue: setData.close,
        closeDataValue: yAxis.dataLabels(close),
        highValue: setData.high,
        highDataValue: yAxis.dataLabels(high),
        lowValue: setData.low,
        lowDataValue: yAxis.dataLabels(low),
        volumeValue: setData.volume,
        volumeDataValue: yAxis.dataLabels(volume)
      }, setData, chartAttr);
    } else {
      toolText = open !== null && !isLine ? BOLDSTARTTAG + 'Open:' + BOLDENDTAG + BLANKSPACE + yAxis.dataLabels(open) + BREAKSTRING : BLANK;
      toolText += close !== null ? BOLDSTARTTAG + 'Close:' + BOLDENDTAG + BLANKSPACE + yAxis.dataLabels(close) + BREAKSTRING : BLANK;
      toolText += high !== null && !isLine ? BOLDSTARTTAG + 'High:' + BOLDENDTAG + BLANKSPACE + yAxis.dataLabels(high) + BREAKSTRING : BLANK;
      toolText += low !== null && !isLine ? BOLDSTARTTAG + 'Low:' + BOLDENDTAG + BLANKSPACE + yAxis.dataLabels(low) + BREAKSTRING : BLANK;
      toolText += volume !== null ? BOLDSTARTTAG + 'Volume:' + BOLDENDTAG + BLANKSPACE + yAxis.dataLabels(volume) : BLANK;
    }
  }
  return toolText;
};

(0, _dependencyManager.addDep)({
  name: 'candlestickAnimation',
  type: 'animationRule',
  extension: _candlestickAnimation2['default']
});
/**
* Class def for bull stick chart API
* This dataset is reponsible for drawing stick depending on high and open value
*/

var CandleStickDataset = function (_ErrorBar2DDataset) {
  _inherits(CandleStickDataset, _ErrorBar2DDataset);

  function CandleStickDataset() {
    _classCallCheck(this, CandleStickDataset);

    return _possibleConstructorReturn(this, _ErrorBar2DDataset.apply(this, arguments));
  }

  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * This function is called once from the init() function of the Column class.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} Indicates whether the configuration was successful or not
    */
  CandleStickDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.config.JSONData = datasetJSON;

    var dataset = this,
        conf = dataset.config,
        chart = dataset.getFromEnv('chart'),
        rawDataObj = chart.getFromEnv('dataSource'),
        JSONData = dataset.config.JSONData,
        dataArr = JSONData.data || [],
        chartAttr = rawDataObj.chart,
        dataLength = dataArr.length,
        numberFormatter = dataset.getFromEnv('number-formatter'),
        colorM = dataset.getFromEnv('color-manager'),
        setColor,
        setBorderColor,
        setAlpha,

    // Candle stick properties.
    // Bear fill and border color - (Close lower than open)
    bearBorderColor = conf.bearBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bearbordercolor, COLOR_B90000)),
        bearFillColor = conf.bearFillColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bearfillcolor, COLOR_B90000)),

    // Bull fill and border color - Close higher than open
    bullBorderColor = conf.bullBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bullbordercolor, colorM.getColor('canvasBorderColor'))),
        bullFillColor = conf.bullFillColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bullfillcolor, COLOR_FFFFFF)),

    // Line Properties - Serves as line for bar & line and border for candle stick
    plotLineThickness = conf.linethickness = conf.plotBorderThickness = (0, _lib.pluckNumber)(chartAttr.plotlinethickness, 1),
        plotLineDashLen = conf.plotLineDashLen = (0, _lib.pluckNumber)(chartAttr.plotlinedashlen, 5),
        plotLineDashGap = conf.plotLineDashGap = (0, _lib.pluckNumber)(chartAttr.plotlinedashgap, 4),
        pointShadow,
        index,
        dataObj,
        open,
        close,
        high,
        low,
        volume,
        minValue,
        maxValue,
        x,
        closeVal,
        borderColor,
        yVal,
        dataStore,
        setData,
        config,
        isCandleStick = false,
        plotSpacePercent,
        yMax = -Infinity,
        yMin = +Infinity,
        xMax = -Infinity,
        xMin = +Infinity,
        userMaxColWidth;

    dataset.setState('visible', (0, _lib.pluckNumber)(JSONData.visible, 1) === 1);

    dataset._conatinerHidden = !!dataset.getState('visible');

    conf.defaultPadding = {
      left: 0.5,
      right: 0.5
    };
    conf.parentYAxis = 0;
    conf.toolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(JSONData.tooltext, chartAttr.plottooltext)));
    // Dataset seriesname
    conf.name = (0, _lib.getValidValue)(JSONData.seriesname);
    conf.showTooltip = (0, _lib.pluck)(chartAttr.showtooltip, 1);

    conf.showErrorValue = true;
    conf.errorBarWidthPercent = 0;
    isCandleStick = true;
    userMaxColWidth = (0, _lib.pluck)(chartAttr.maxcolwidth);
    conf.maxColWidth = Math.abs((0, _lib.pluckNumber)(userMaxColWidth, 50)) || 1;
    plotSpacePercent = Math.max((0, _lib.pluckNumber)(chartAttr.plotspacepercent, 20) % 100, 0);
    conf.plotSpacePercent = conf.groupPadding = plotSpacePercent / 200;
    dataStore = dataset.components.data = dataset.components.data || (dataset.components.data = []);
    conf.valuePadding = (0, _lib.pluckNumber)(JSONData.valuepadding, chartAttr.valuepadding, 2);
    conf.plotBorderThickness = plotLineThickness;
    // Iterate through all level data
    for (index = 0; index < dataLength; index += 1) {
      // Individual data obj
      // for further manipulation
      setData = dataArr[index];
      dataObj = dataStore[index];
      if (!dataObj) {
        dataObj = dataStore[index] = {};
      }
      !dataObj.config && (dataObj.config = {});
      !dataObj.graphics && (dataObj.graphics = {});
      config = dataObj.config;
      if (setData && !setData.vline) {
        config.setLink = (0, _lib.pluck)(setData.link);
        open = config.open = numberFormatter.getCleanValue(setData.open);
        close = config.close = numberFormatter.getCleanValue(setData.close);
        high = config.high = numberFormatter.getCleanValue(setData.high);
        low = config.low = numberFormatter.getCleanValue(setData.low);
        volume = config.volume = numberFormatter.getCleanValue(setData.volume, true);
        if (volume !== null) {
          chart.config.drawVolume = true;
        }
        x = config.x = numberFormatter.getCleanValue(setData.x);
        // openVal = config.openVal = isCandleStick ? Math.abs(close - open) : open;
        closeVal = config.closeVal = Math.min(open, close);
        yVal = config.yVal = Math.max(open, close);
        minValue = Math.min(open, close, high, low);
        maxValue = Math.max(open, close, high, low);

        // valueText = parseUnsafeString(getValidValue(setData.valuetext, BLANK));

        setBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.bordercolor, close < open ? bearBorderColor : bullBorderColor));
        setAlpha = (0, _lib.pluckNumber)(setData.alpha, 100);
        setColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.color, close < open ? bearFillColor : bullFillColor));

        config.plotBorderDashStyle = (0, _lib.pluckNumber)(setData.dashed) ? (0, _lib.getDashStyle)(plotLineDashLen, plotLineDashGap) : DASH_DEF;
        // Set alpha of the shadow
        pointShadow = {
          opacity: setAlpha / 100
        };
        config.color = isCandleStick ? setColor : setBorderColor;
        config.alpha = setAlpha;
        /*
        * Storing the set level color and set level alpha which is required in drawing of line
        * In line we are checking setColor and setAlpha of current line segment is same as the previous
        * line segment's setColor and setAlpha by accesing config.setColor and config.setAlpha
        */
        config.setColor = config.color;
        config.setAlpha = config.alpha;
        config.anchorImageUrl = (0, _lib.pluck)(setData.anchorimageurl, JSONData.anchorimageurl, chartAttr.anchorimageurl);
        // Finally add the data
        // we call getPointStub function that manage displayValue, toolText and link
        borderColor = config.borderColor = setBorderColor;
        config.borderAlpha = config.plotLineAlpha;
        config.colorArr = [{
          color: config.color,
          alpha: config.alpha
        }, {
          color: config.borderColor,
          alpha: config.borderAlpha
        }];

        config.showValue = 1;
        config.hoverEffects = {};

        config.y = Math.abs(close - open);
        config.previousY = closeVal;
        config.link = (0, _lib.pluck)(setData.link);
        config.errorValueArr = [];
        if (high - yVal > 0) {
          config.errorValue = true;
          config.errorValueArr.push({
            errorValue: yVal - high,
            errorStartValue: yVal,
            errorBarColor: borderColor,
            errorBarThickness: plotLineThickness,
            opacity: 1
          });
        }
        if (low - closeVal < 0) {
          config.errorValue = true;
          config.errorValueArr.push({
            errorValue: closeVal - low,
            errorStartValue: closeVal,
            errorBarColor: borderColor,
            errorBarThickness: plotLineThickness,
            opacity: 1
          });
        }
        config.setValue = yVal;

        if (minValue !== null) {
          yMax = Math.max(yMax, minValue);
          yMin = Math.min(yMin, minValue);
        }
        if (maxValue !== null) {
          yMax = Math.max(yMax, maxValue);
          yMin = Math.min(yMin, maxValue);
        }
        if (x !== null) {
          xMax = Math.max(xMax, x);
          xMin = Math.min(xMin, x);
        }

        x = x !== null ? x : index + 1;
        config._x = x;
        config._y = yVal;
        config._b = closeVal;
        config.high = Math.max(open, close, high, low);
        config.low = Math.min(open, close, high, low);
        config.shadow = pointShadow;
        config.toolText = dataset._parseToolText(index);
        config.toolTipValue = '';
        config.displayValue = (0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.displayvalue, setData.valuetext, BLANKSTRING));
      }
    }
    conf.yMax = yMax;
    conf.yMin = yMin;
    conf.xMax = xMax;
    conf.xMin = xMin;
    dataset.setState('dirty', true);
  };
  /**
   * parse tooltext from the dataset json
   * @param {number} i index of data
   * @return {string} tooltext
   */


  CandleStickDataset.prototype._parseToolText = function _parseToolText(i) {
    return __parseToolText.call(this, i);
  };
  /**
   * calculate min and max position to scroll
   */


  CandleStickDataset.prototype.calculateScrollRange = function calculateScrollRange() {
    var dataset = this,
        conf = dataset.config,
        dataLen = dataset.components.data && dataset.components.data.length;
    conf.scrollMinVal = conf.scrollMinValForLabel = 0;
    conf.scrollMaxVal = conf.scrollMaxValForLabel = dataLen;
  };
  /**
   * fetches data indices wrt. the x pos value
   * @param {number} x  x pos value
   * @return {Array}    contains indices
   */


  CandleStickDataset.prototype.getPlotIndices = function getPlotIndices(x) {
    return _getPlotIndices.call(this, x);
  };
  /**
   * Function that retunr the nearest plot details
   * @param {number} chartX x-axis position of the mouse cordinate
   * @param {number} chartY x-axis position of the mouse cordinate
   * @return {Object} return an object with details of nearest polt and whether it is hovered or not
   */


  CandleStickDataset.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        xAxis = dataset.getFromEnv('xAxis'),
        x,
        i,
        hoveredInfo,
        pXs,
        pX;

    x = xAxis.getValue(chartX);
    pXs = dataset.getPlotIndices(x);

    // Checking for overlap between two cosecutive column plots along x-axis
    for (i = pXs.length - 1; i > -1; i--) {
      pX = pXs[i];
      hoveredInfo = pX - x > 0 ? dataset._checkPointerOverPlot(pX, chartX, chartY) || dataset._checkPointerOverPlot(pX - 1, chartX, chartY) : dataset._checkPointerOverPlot(pX + 1, chartX, chartY) || dataset._checkPointerOverPlot(pX, chartX, chartY);
      if (hoveredInfo) {
        break;
      }
    }
    return hoveredInfo;
  };
  /**
   * This method handles all mouse events of an dataset.
   * @param {string} eventType    name of the event
   * @param {number} plotIndex    index of the plot where this event has been occured
   * @param {Event}  e            reference of the original mouse event
   */


  CandleStickDataset.prototype._firePlotEvent = function _firePlotEvent(eventType, plotIndex, e) {
    _firePlotEvent2.call(this, eventType, plotIndex, e);
  };
  /**
   * Function to get the maximum and minimum from dataset
   * @return {Object}     contains max, min value
   */


  CandleStickDataset.prototype.getDataLimits = function getDataLimits() {
    var conf = this.config;
    return {
      max: conf.yMax,
      min: conf.yMin,
      xMax: conf.xMax,
      xMin: conf.xMin
    };
  };
  /**
   * Returns the name of the component
   *
   * @return {string} The name of the component
   */


  CandleStickDataset.prototype.getName = function getName() {
    return 'candlestick';
  };
  /**
   * function to reuse dataplots on scroll draw. When scrolling is apllied on a scroll chart then those
   * plots which are outside of the view port are reused to draw new plot by appliying new attribute.
   * So that when number of data plots is huge; the number of dom elements do not get increased.
   * @param {number} start  start index
   * @param {number} end    end index
   */


  CandleStickDataset.prototype.reuseFN = function reuseFN(start, end) {
    var dataSet = this,
        components = dataSet.components,
        dataStore = components.data,
        pool = components.pool || (components.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        prop,
        graphics,
        i;

    for (i = start; i < end; i++) {
      graphics = dataStore[i] && dataStore[i].graphics || {};
      for (prop in graphics) {
        if (graphics[prop]) {
          prop !== 'error' && pool[prop].push(graphics[prop].hide());
          delete graphics[prop];
        }
      }
    }
  };

  return CandleStickDataset;
}(_errorbar2d2['default']);

exports['default'] = CandleStickDataset;
exports.getPlotIndices = _getPlotIndices;
exports._firePlotEvent = _firePlotEvent2;
exports._parseToolText = __parseToolText;

/***/ }),

/***/ 232:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.updateDataValue = exports._restore = exports._getJSONData = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */

var SETROLLOVERATTR = _lib.preDefStr.setRolloverAttrStr,
    SETROLLOUTATTR = _lib.preDefStr.setRolloutAttrStr,
    ROLLOUT = 'DataPlotRollOut',
    ROLLOVER = 'DataPlotRollOver',
    MOUSEOVER = 'mouseOver',
    MOUSEOUT = 'mouseOut',
    DATAPLOTCLICK = _lib.preDefStr.DATAPLOTCLICK,
    _getJSONData = void 0,
    _restore = void 0,
    UNDEF = void 0,
    updateDataValue = function updateDataValue(event, chart) {
  var element = this,
      yAxis = chart.getChildren('yAxis')[0],
      container = chart.getFromEnv('chart-container'),
      eventArgs = element.data('eventArgs'),
      mouseCoordinate = void 0;

  mouseCoordinate = (0, _lib.getMouseCoordinate)(container, event, chart);
  eventArgs.value = yAxis.getValue(mouseCoordinate.chartY);

  element.data('eventArgs', eventArgs);
};

/**
 * dataset class of dragcolumn inheriting from column class
 */

var DragColumnDataset = function (_ColumnDataset) {
  _inherits(DragColumnDataset, _ColumnDataset);

  function DragColumnDataset() {
    _classCallCheck(this, DragColumnDataset);

    return _possibleConstructorReturn(this, _ColumnDataset.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  DragColumnDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  DragColumnDataset.prototype.getName = function getName() {
    return 'dragColumn';
  };
  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * This function is called once from the init() function of the Column class.
    * @param  {Object} datasetJSON JSON for dataset configurations
    */


  DragColumnDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    var dataset = this,
        conf = dataset.config,
        chartAttr = dataset.getFromEnv('chart-attrib'),
        JSONData = conf.JSONData;

    conf.allowDrag = (0, _lib.pluckNumber)(JSONData.allowdrag, 1);
    conf.allowNegDrag = (0, _lib.pluckNumber)(JSONData.allownegativedrag, 1);
    conf.allowAxisChange = (0, _lib.pluckNumber)(chartAttr.allowaxischange, 1);
    conf.snapToDivOnly = (0, _lib.pluckNumber)(chartAttr.snaptodivonly, 0);
    conf.snapToDiv = conf.snapToDivOnly ? 1 : (0, _lib.pluckNumber)(chartAttr.snaptodiv, 1);
    conf.doNotSnap = (0, _lib.pluckNumber)(chartAttr.donotsnap, 0);
    conf.snapToDivRelaxation = (0, _lib.pluckNumber)(chartAttr.snaptodivrelaxation, 10);
    if (conf.doNotSnap) {
      conf.snapToDiv = conf.snapToDivOnly = 0;
    }
    _ColumnDataset.prototype.configureAttributes.call(this, datasetJSON);
  };
  /**
   * method to configure a particular data plot object
   * @param {number} i index of the data object to be configured
   * @param {Object} setData particular plot information in of i'th index in input json
   */


  DragColumnDataset.prototype._plotConfigure = function _plotConfigure(i, setData) {
    var conf = this.config,
        dataStore = this.components.data,
        dataObj = void 0,
        config = void 0;
    _ColumnDataset.prototype._plotConfigure.call(this, i, setData);
    dataObj = dataStore[i];
    config = dataObj.config;
    config.allowDrag = (0, _lib.pluckNumber)(setData.allowdrag, conf.allowDrag);
    config.allowNegDrag = (0, _lib.pluckNumber)(setData.allownegativedrag, conf.allowNegDrag);
  };
  /**
   * This method handles all mouse events of an dataset.
   * @param {string} eventType name of the event
   * @param {number} plotIndex index of the plot where this event has been occured
   * @param {Event} e reference of the original mouse event
   */


  DragColumnDataset.prototype._firePlotEvent = function _firePlotEvent(eventType, plotIndex, e) {
    var dataset = this,
        doc = document,
        chart = dataset.getFromEnv('chart'),
        dragmoveHandler,
        dragendHandler,
        dataSetConf = dataset.config,
        JSONData = dataSetConf.JSONData,
        chartAttr = chart.getFromEnv('dataSource').chart,
        currentToolTip = dataSetConf.currentToolTip,
        chartConfig = dataset.getFromEnv('chartConfig'),
        drawTrendRegion = chartConfig.drawTrendRegion,
        useplotgradientcolor = chartConfig.useplotgradientcolor,
        useroundedges = chartConfig.useroundedges,

    // chartComp = chart.components,
    paper = dataset.getFromEnv('paper'),
        canvas = paper.canvas,
        style = canvas.style,
        NumberFormatter = dataset.getFromEnv('number-formatter'),
        toolTipController = dataset.getFromEnv('toolTipController'),
        data = dataset.components.data[plotIndex],
        config = data.config,
        setElement = data.graphics.element,
        setTooltext,
        toolText = config.finalTooltext || config.toolText,

    // tip = lib.toolTip,
    originalEvent = e.originalEvent,
        dragMouseAttr = _lib.hasSVG && ('ns-resize' || 'n-resize'),
        dragStart,
        dragEnd,
        pointerMouseAttr = 'default',
        tolerance,
        coordinate = (0, _lib.getMouseCoordinate)(dataset.getFromEnv('chart-container'), originalEvent),
        chartY = coordinate.chartY,
        yPos = data._yPos,
        height = data._height,
        formattedVal,
        macroIndices = [1, 2, 3, 4, 5, 6, 7],
        yAxis = dataset.getFromEnv('yAxis'),
        yBasePos = yAxis.yBasePos,
        yaxisName = chartConfig.yaxisname,
        xaxisName = chartConfig.xaxisname,
        parserConfig = {
      xaxisName: xaxisName,
      yaxisName: yaxisName
    },
        value,
        yActual,
        canvasTop = chartConfig.canvasTop,
        canvasBottom = chartConfig.canvasBottom,
        allowDrag = config.allowDrag,
        allowNegDrag = config.allowNegDrag,
        lowerDragBoundary = allowNegDrag ? canvasBottom : yBasePos,
        eventArgsArr,
        eventArgs,
        rolloverdata,
        rolloutedata,
        fill,
        angle,
        colTop = yPos,
        colBottom = yPos + height;

    tolerance = chartConfig.dragTolerance + 1;

    value = config.setValue;

    yActual = yPos >= yBasePos ? yPos + height : yPos;

    if (setElement && toolText) {
      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(JSONData.data[plotIndex].tooltext, JSONData.plottooltext, chartAttr.plottooltext)));
      switch (eventType) {
        case 'mouseover':
          // set flag on mouse over
          dataSetConf.mouseIn = true;
          if (chartY <= colBottom - tolerance && chartY >= colTop + tolerance && !drawTrendRegion) {
            if (currentToolTip) {
              toolTipController.draw(originalEvent, toolText, currentToolTip);
            } else {
              currentToolTip = dataSetConf.currentToolTip = toolTipController.draw(originalEvent, toolText);
            }
          }

          // fire _rollOverResponseSetter if its not already fired and
          // cursor position is on column body
          if (!config._rollOverResponseSetterFire && chartY <= colBottom && chartY >= colTop) {
            DragColumnDataset._rolloverResponseSetter(chart, setElement, e, this);
            // set flag true as _rollOverResponseSetter is fired
            config._rollOverResponseSetterFire = true;
          }
          break;

        case 'mouseout':
          // set flag on mouse out
          dataSetConf.mouseIn = false;
          style.cursor = pointerMouseAttr;
          // fire _rolloutResponseSetter if _rolloverResponseSetter is fired
          config._rollOverResponseSetterFire && DragColumnDataset._rolloutResponseSetter(chart, setElement, e, this);
          // set flag false as _rolloutResponseSetter is fired
          config._rollOverResponseSetterFire = false;
          toolTipController.hide(dataSetConf.currentToolTip);
          break;

        case 'click':
          _lib.plotEventHandler.call(setElement, chart, e, DATAPLOTCLICK);
          break;

        case 'touchmove':
        case 'mousemove':
          if (!config.dragStart) {
            yActual = yPos >= yBasePos ? yPos + height : yPos;
            if (allowDrag && chartY >= yActual - tolerance && chartY <= yActual + tolerance) {
              style.cursor = dragMouseAttr;
              toolTipController.hide(dataSetConf.currentToolTip);
            } else {
              style.cursor = pointerMouseAttr;
              if (config._rollOverResponseSetterFire && !drawTrendRegion) {
                if (currentToolTip) {
                  toolTipController.draw(originalEvent, toolText, currentToolTip);
                } else {
                  currentToolTip = dataSetConf.currentToolTip = toolTipController.draw(originalEvent, toolText);
                }
              }
            }
            // fire _rollOverResponseSetter if its not already fired and
            // cursor position is on column body
            if (!config._rollOverResponseSetterFire && chartY <= colBottom && chartY >= colTop) {
              DragColumnDataset._rolloverResponseSetter(chart, setElement, e);
              config._rollOverResponseSetterFire = true;
            } else if (config._rollOverResponseSetterFire && !(chartY <= colBottom && chartY >= colTop)) {
              toolTipController.hide(dataSetConf.currentToolTip);
              config._rollOverResponseSetterFire = false;
              DragColumnDataset._rolloutResponseSetter(chart, setElement, e, this);
            }
          }
          break;

        case 'touchend':
        case 'mouseup':
          dataSetConf.mousedown = false;
          if (config.dragStart) {
            eventArgs = {
              dataIndex: plotIndex,
              datasetIndex: data.datasetIndex,
              startValue: data.startValue,
              endValue: config.setValue,
              datasetName: data.name
            };
            eventArgsArr = [chart.getFromEnv('chartInstance').id, eventArgs.dataIndex, eventArgs.datasetIndex, eventArgs.datasetName, eventArgs.startValue, eventArgs.endValue];

            // Update dataValue
            updateDataValue.call(setElement, e, chart);
            if (config._pointerDy) {
              chart.fireChartInstanceEvent('dataplotDragEnd', eventArgs);

              // Fire the ChartUpdated event
              chart.fireChartInstanceEvent('chartupdated', eventArgs, eventArgsArr);
            }
            if (useplotgradientcolor && !useroundedges) {
              angle = yPos >= yBasePos ? 90 : 270;
              if ((rolloverdata = setElement.data(SETROLLOVERATTR)) && rolloverdata.fill) {
                fill = rolloverdata.fill;
                fill = fill.split('-');
                fill[0] = angle;
                rolloverdata.fill = fill.join('-');
              }
              if ((rolloutedata = setElement.data(SETROLLOUTATTR)) && rolloutedata.fill) {
                fill = rolloutedata.fill;
                fill = fill.split('-');
                fill[0] = angle;
                rolloutedata.fill = fill.join('-');
              }
            }
          }
          // difference on actualY and chartY
          config._dragBuffer = 0;
          // counter on drag move
          config._pointerDy = 0;
          config.dragStart = false;
          if (setTooltext !== UNDEF) {
            parserConfig.formattedValue = config.toolTipValue;
            parserConfig.label = config.label;
            toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, { value: config.setValue }, UNDEF, JSONData);
            config.setTooltext = toolText;
            setTooltext = toolText;
            config.toolText = toolText;
          }
          toolText = config.finalTooltext = config.toolText !== false ? config.toolText + (setTooltext ? '' : config.toolTipValue) : '';
          if (!(chartY >= yActual - tolerance && chartY <= yActual + tolerance)) {
            style.cursor = pointerMouseAttr;
          }
          break;

        case 'touchstart':
        case 'mousedown':
          // drag move handler that will be listened on every mousemove/touchmove on the document when
          // in dragging state
          dragmoveHandler = function dragmoveHandler(oriEvent) {
            chartY = (0, _lib.getMouseCoordinate)(dataset.getFromEnv('chart-container'), oriEvent).chartY;
            oriEvent.preventDefault ? oriEvent.preventDefault() : oriEvent.returnValue = false;
            config._rollOverResponseSetterFire = false;
            style.cursor = dragMouseAttr;
            // counter on drag move
            config._pointerDy++;
            // calculate chartY with _dragBuffer
            chartY += config._dragBuffer;
            // update chartY on canvas edge crossing
            if (chartY < canvasTop) {
              chartY = canvasTop;
            } else if (chartY > lowerDragBoundary) {
              chartY = lowerDragBoundary;
            }
            // calculate yPos
            yPos = yBasePos < chartY ? yBasePos : chartY;
            // calculate height
            height = (0, _lib.mathAbs)(yBasePos - chartY);
            data._yPos = yPos;
            data._height = height;
            yActual = yPos >= yBasePos ? yPos + height : yPos;
            config._y = value = config.setValue = (0, _lib.mathRound)(yAxis.getValue(yActual));
            formattedVal = NumberFormatter.dataLabels(value);
            config.toolTipValue = formattedVal;
            config.displayValue = (0, _lib.pluck)(config.setDisplayValue, formattedVal);
            if (useplotgradientcolor && !useroundedges) {
              config.colorArr[0].FCcolor.angle = angle = yPos < yBasePos ? 90 : 270;
            }

            setElement.attr({
              y: data._yPos,
              height: data._height,
              fill: (0, _lib.toRaphaelColor)(config.colorArr[0])
            });

            dataset.drawLabel(plotIndex, plotIndex + 1);
            data.graphics.element = setElement;
            toolTipController.hide(dataSetConf.currentToolTip);

            // fire dataplotDragStart event
            if (config._pointerDy === 1) {
              eventArgs = {
                dataIndex: plotIndex,
                datasetIndex: data.datasetIndex,
                startValue: data.startValue,
                datasetName: data.name
              };
              chart.fireChartInstanceEvent('dataplotDragStart', eventArgs);
            }
          };
          // drag end handler that will be listened on every mouseup/touchend on the document when
          // in dragging state
          dragendHandler = function dragendHandler(oriEvent) {
            chartY = (0, _lib.getMouseCoordinate)(dataset.getFromEnv('chart-container'), oriEvent).chartY;
            dataSetConf.mousedown = false;
            if (config.dragStart) {
              // dataset.setMaxMin();
              // chart._setDataLimits();
              eventArgs = {
                dataIndex: plotIndex,
                datasetIndex: data.datasetIndex,
                startValue: data.startValue,
                endValue: config.setValue,
                datasetName: data.name
              };
              eventArgsArr = [chart.getFromEnv('chartInstance').id, eventArgs.dataIndex, eventArgs.datasetIndex, eventArgs.datasetName, eventArgs.startValue, eventArgs.endValue];

              if (config._pointerDy) {
                chart.fireChartInstanceEvent('dataplotDragEnd', eventArgs);

                // Fire the ChartUpdated event
                chart.fireChartInstanceEvent('chartupdated', eventArgs, eventArgsArr);
              }
              if (useplotgradientcolor && !useroundedges) {
                angle = yPos >= yBasePos ? 90 : 270;
                if ((rolloverdata = setElement.data(SETROLLOVERATTR)) && rolloverdata.fill) {
                  fill = rolloverdata.fill;
                  fill = fill.split('-');
                  fill[0] = angle;
                  rolloverdata.fill = fill.join('-');
                }
                if ((rolloutedata = setElement.data(SETROLLOUTATTR)) && rolloutedata.fill) {
                  fill = rolloutedata.fill;
                  fill = fill.split('-');
                  fill[0] = angle;
                  rolloutedata.fill = fill.join('-');
                }
              }
            }
            // difference on actualY and chartY
            config._dragBuffer = 0;
            // counter on drag move
            config._pointerDy = 0;
            config.dragStart = false;
            if (setTooltext !== UNDEF) {
              parserConfig.formattedValue = config.toolTipValue;
              parserConfig.label = config.label;
              toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, { value: config.setValue }, UNDEF, JSONData);
              config.setTooltext = toolText;
              setTooltext = toolText;
              config.toolText = toolText;
            }
            toolText = config.finalTooltext = config.toolText !== false ? config.toolText + (setTooltext ? '' : config.toolTipValue) : '';
            if (!(chartY >= yActual - tolerance && chartY <= yActual + tolerance)) {
              style.cursor = pointerMouseAttr;
            }
            // unlisten the drag events assigned on document
            if (doc.removeEventListener) {
              doc.removeEventListener('mousemove', dragStart);
              doc.removeEventListener('mouseup', dragEnd);
              doc.removeEventListener('touchmove', dragStart);
              doc.removeEventListener('touchend', dragEnd);
            } else {
              // For IE
              doc.detachEvent('onmousemove', dragStart);
              doc.detachEvent('onmouseup', dragEnd);
              doc.detachEvent('ontouchmove', dragStart);
              doc.detachEvent('ontouchend', dragEnd);
            }
          };
          dataSetConf.mousedown = true;
          yActual = yPos >= yBasePos ? yPos + height : yPos;
          if (allowDrag && chartY >= yActual - tolerance && chartY <= yActual + tolerance) {
            // set drag flag
            config.dragStart = true;
            config._pointerDy = 0;
            config._dragStartY = chartY;
            // difference on actualY and chartY
            config._dragBuffer = yActual - chartY;

            data.startValue = config.setValue;
            data.name = dataSetConf.seriesname;
            data.datasetIndex = dataSetConf.index;

            data.dragged = true;
            dragStart = function dragStart(oriEvent) {
              dragmoveHandler(oriEvent);
            };
            dragEnd = function dragEnd(oriEvent) {
              dragendHandler(oriEvent);
            };
            // assign mousemove and mouseup on document when dragging starts.
            if (doc.addEventListener) {
              doc.addEventListener('mousemove', dragStart);
              doc.addEventListener('touchmove', dragStart);
              doc.addEventListener('mouseup', dragEnd);
              doc.addEventListener('touchend', dragEnd);
            } else {
              // For IE
              doc.attachEvent('onmousemove', dragStart);
              doc.attachEvent('ontouchmove', dragStart);
              doc.attachEvent('onmouseup', dragEnd);
              doc.attachEvent('ontouchend', dragEnd);
            }
          } else {
            config.dragStart = false;
          }
      }
    }
  };

  /**
   * Function called as a callback when mouse pointer hovers over a graphic element
   * @param {Object} chart The chart object
   * @param {Object} elem The graphic element for which the function is called
   * @param {Object} event The event against which the function is called.
   * @param {Component} dataset - dataset component
   */


  DragColumnDataset._rolloverResponseSetter = function _rolloverResponseSetter(chart, elem, event, dataset) {
    var elData = elem && elem.getData(),
        animationManager = chart.getFromEnv('animationManager');
    // Check whether the plot is in dragged state or not if
    // drag then dont fire rolloverevent
    if (elem && elData.showHoverEffect !== 0 && elData.draged !== true && elem) {
      animationManager.setAnimationState(MOUSEOVER);
      animationManager.setAnimation({
        el: elem,
        label: 'rect',
        component: dataset,
        attr: elem.getData().setRolloverAttr
      });
      _lib.plotEventHandler.call(elem, chart, event, ROLLOVER);
    }
  };

  /**
   * Function called as a callback when mouse pointer hovers out a graphic element
   * @param {Object} chart The chart object
   * @param {Object} elem The graphic element for which the function is called
   * @param {Object} event The event against which the function is called.
   * @param {Component} dataset - dataset component
   */


  DragColumnDataset._rolloutResponseSetter = function _rolloutResponseSetter(chart, elem, event, dataset) {
    var elData = elem && elem.getData(),
        animationManager = chart.getFromEnv('animationManager');
    // Check whether the plot is in draggedstate or not if drag then dont fire rolloutevent
    if (elem && elData.showHoverEffect !== 0 && elData.draged !== true) {
      animationManager.setAnimationState(MOUSEOUT);
      animationManager.setAnimation({
        el: elem,
        label: 'rect',
        component: dataset,
        attr: elem.getData().setRolloutAttr
      });
      _lib.plotEventHandler.call(elem, chart, event, ROLLOUT);
    }
  };

  /**
   * Fucntion to get the updated values of data when they are dragged.
   * @return {Object} The corresponding data Array of the dataset containing the values of all the sets.
   */


  DragColumnDataset.prototype.getJSONData = function getJSONData() {
    var dataset = this,
        JSONData = dataset.config.JSONData.data,
        dataStore = dataset.components.data,
        dataArr = [],
        obj = {},
        updatedDataObj,
        dataObj,
        prop,
        len,
        i;

    for (i = 0, len = JSONData.length; i < len; i++) {
      dataObj = JSONData[i];
      updatedDataObj = dataStore[i];
      obj = {};
      for (prop in dataObj) {
        if (prop === 'value') {
          obj[prop] = updatedDataObj.config.setValue;
        } else {
          obj[prop] = dataObj[prop];
        }
      }
      dataArr.push(obj);
    }
    return {
      data: dataArr
    };
  };

  /**
   * Function to restore the values of the dataset to its original
   */


  DragColumnDataset.prototype.restore = function restore() {
    var dataset = this;
    dataset.setData(dataset.config.JSONData, true);
  };

  return DragColumnDataset;
}(_column2['default']);

exports._getJSONData = _getJSONData = DragColumnDataset.prototype.getJSONData;
exports._restore = _restore = DragColumnDataset.prototype.restore;
exports['default'] = DragColumnDataset;
exports._getJSONData = _getJSONData;
exports._restore = _restore;
exports.updateDataValue = updateDataValue;

/***/ }),

/***/ 233:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _keys = __webpack_require__(22);

var _keys2 = _interopRequireDefault(_keys);

var _area = __webpack_require__(23);

var _area2 = _interopRequireDefault(_area);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _dragnodeAnimation = __webpack_require__(782);

var _dragnodeAnimation2 = _interopRequireDefault(_dragnodeAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


// import { triggerEvent } from '../../../core/events/event-api';
// import {_getJSONData, _restore} from './dragcolumn';

var mathMax = Math.max,
    mathMin = Math.min,
    CIRCLE = _lib.preDefStr.CIRCLE,
    POLYGON = _lib.preDefStr.POLYGON,
    RECTANGLE = _lib.preDefStr.RECTANGLE,
    UNDERSCORE = _lib.preDefStr.UNDERSCORE,
    GROUPID = _lib.preDefStr.GROUPID,
    EVENTARGS = _lib.preDefStr.EVENTARGS,
    OBJECTBOUNDINGBOX = _lib.preDefStr.OBJECTBOUNDINGBOX,
    COMMA = _lib.preDefStr.COMMA,
    ROLLOVER = 'DataPlotRollOver',
    ROLLOUT = 'DataPlotRollOut',
    POSITION_TOP = _lib.preDefStr.POSITION_TOP,
    isVML = !!_lib.hasSVG,

// CLEAR_TIME_1000 = 1000,
// stubEvent = {
//   pageX: 0,
//   pageY: 0
// },
// animType = 'linear',
defined = function defined(obj) {
  return obj !== undefined && obj !== null;
},

/**
 * Helper function of createContainer
 * @param {string} groupName The new group name
 * @param {Object} animationManager The renderer
 * @param {Object} parentContainer The container under which the new container has to be created
 * @param {Object} component The component for which the group is being created
 * @return {Object}  the newly created contaier
 */
createGroup = function createGroup(groupName, animationManager, parentContainer, component) {
  return animationManager.setAnimation({
    el: 'group',
    attr: {
      name: groupName
    },
    container: parentContainer,
    component: component
  });
},
    clearLongPress = function clearLongPress() {
  var ele = this;
  ele.data('move', false);
},

// Function that produce the point color
getPointColor = function getPointColor(color, alpha, shapeType) {
  var colorObj, innerColor, outerColor;
  color = (0, _lib.getFirstColor)(color);
  alpha = (0, _lib.getFirstAlpha)(alpha);
  innerColor = _lib.graphics.getLightColor(color, 80);
  outerColor = _lib.graphics.getDarkColor(color, 65);
  colorObj = {
    FCcolor: {
      gradientUnits: OBJECTBOUNDINGBOX,
      color: innerColor + COMMA + outerColor,
      alpha: alpha + COMMA + alpha,
      ratio: _lib.BGRATIOSTRING
    }
  };

  if (shapeType) {
    if (shapeType === 1) {
      colorObj.FCcolor.angle = 0;
    } else {
      colorObj.FCcolor.angle = 180;
    }
  } else {
    colorObj.FCcolor.cx = 0.4;
    colorObj.FCcolor.cy = 0.4;
    colorObj.FCcolor.r = '50%';
    colorObj.FCcolor.radialGradient = true;
  }

  return colorObj;
},
    _configureTooltext = function _configureTooltext(config, datasetConf, chartAttr) {
  var setTooltext = config.setTooltext,
      formatedVal = config.formatedVal,
      seriesname = datasetConf.seriesname,
      label = config.label,
      xValue = config.xValue,
      pointLabel = config.pointLabel,
      tooltipSepChar = datasetConf.tooltipSepChar,
      toolText;
  if (setTooltext !== undefined) {
    toolText = (0, _lib.parseTooltext)(setTooltext, [3, 4, 5, 6, 8, 9, 10, 11], {
      yaxisName: (0, _lib.parseUnsafeString)(chartAttr.yaxisname),
      xaxisName: (0, _lib.parseUnsafeString)(chartAttr.xaxisname),
      yDataValue: formatedVal,
      xDataValue: xValue,
      label: label
    }, config, chartAttr, datasetConf);
  } else if (pointLabel !== undefined) {
    toolText = label;
  } else {
    // determine the tooltext then
    if (formatedVal === null) {
      toolText = false;
    } else {
      if (datasetConf.seriesNameInToolTip) {
        seriesname = (0, _lib.getFirstValue)(datasetConf.seriesname);
      }
      toolText = seriesname ? seriesname + tooltipSepChar : _lib.BLANK;
      toolText += xValue ? xValue + tooltipSepChar : _lib.BLANK;
      toolText += formatedVal;
    }
  }
  return toolText;
},
    rolloverResponseSetter = function rolloverResponseSetter(elem, enabled, dataset) {
  return function (data) {
    var ele = this,
        _data = ele.data('drag-options'),
        chart = _data.chart,
        dataObj = _data.dataObj,
        config = dataObj.config,
        dragStart = config.dragStart,
        keysNo = dragStart && (0, _keys2['default'])(dragStart).length,
        hoverAttr = ele.data('hoverAttr');
    if (!keysNo) {
      enabled && dataset.getFromEnv('animationManager').setAnimation({
        el: elem.graphics.element,
        attr: hoverAttr,
        component: dataset
      });
      chart && _lib.plotEventHandler.call(ele, chart, data, ROLLOVER);
    }
  };
},
    rolloutResponseSetter = function rolloutResponseSetter(elem, enabled, dataset) {
  return function (data) {
    var ele = this,
        _data = ele.data('drag-options'),
        dataObj = _data.dataObj,
        chart = _data.chart,
        config = dataObj.config,
        dragStart = config.dragStart,
        keysNo = dragStart && (0, _keys2['default'])(dragStart).length,
        unHoverAttr = ele.data('unHoverAttr');
    if (!keysNo) {
      enabled && dataset.getFromEnv('animationManager').setAnimation({
        el: elem.graphics.element,
        attr: unHoverAttr,
        component: dataset
      });
      chart && _lib.plotEventHandler.call(ele, chart, data, ROLLOUT);
    }
  };
};
(0, _dependencyManager.addDep)({
  name: 'dragNodeAnimation',
  type: 'animationRule',
  extension: _dragnodeAnimation2['default']
});
/**
 * dataset class of dragcolumn inheriting from column class
 */

var DragNodeDataset = function (_Areadataset) {
  _inherits(DragNodeDataset, _Areadataset);

  function DragNodeDataset() {
    _classCallCheck(this, DragNodeDataset);

    return _possibleConstructorReturn(this, _Areadataset.apply(this, arguments));
  }

  /**
   * Return the name of component
   * @return {string} name
   */
  DragNodeDataset.prototype.getName = function getName() {
    return 'dragNode';
  };
  /**
   * Return the type of component
   * @return {string} type
   */


  DragNodeDataset.prototype.getType = function getType() {
    return 'dataset';
  };

  /**
   * Function to hide the dataset on legend click
   */


  DragNodeDataset.prototype.hide = function hide() {
    var dataSet = this,
        parent = dataSet.getLinkedParent(),
        changeInfo = {};

    changeInfo.hide = true;
    dataSet.setState('dirty', true);
    dataSet.setState('visible', false);
    parent.childChanged(changeInfo);
    dataSet.getFromEnv('chart').getChildren('legend')[0].getItem(dataSet.config.legendItemId).setLegendState('hidden');
    dataSet.asyncDraw();
  };

  /**
   * Function to show the dataset on legend click
   */


  DragNodeDataset.prototype.show = function show() {
    var dataSet = this,
        parent = dataSet.getLinkedParent(),
        legendItem = dataSet.getFromEnv('legend').getItem(dataSet.config.legendItemId),
        changeInfo = {};

    changeInfo.show = true;
    dataSet.setState('visible', true);
    dataSet.setState('dirty', true);
    parent.childChanged(changeInfo);
    legendItem && legendItem.removeLegendState('hidden');
    dataSet.asyncDraw();
  };

  /**
   * Function to set the index of the dataset from amongst the other datasets
   */


  DragNodeDataset.prototype._setDatasetIndex = function _setDatasetIndex() {
    var dataset = this,
        parent = dataset.getLinkedParent().getChildren(),
        childrenArr = parent[dataset.getType()];

    dataset.config.datasetIndex = childrenArr.indexOf(dataset);
  };

  /**
   * Callback function when dragging of the node is stopped
   * @param {Object} event The actual event object
   */


  DragNodeDataset.prototype.dragUp = function dragUp(event) {
    var ele = this,
        data = ele.data('drag-options'),
        dataset = data.dataset;
    dataset._dragUp.call(ele, event);
  };

  /**
   * Callback function when a node is being dragged
   * @param {Object} event The actual event object
   * @param {Object} customData Object containing the details related to drag coordinates
   */


  DragNodeDataset.prototype.dragMove = function dragMove(event, customData) {
    // eslint-disable-line no-unused-vars
    var ele = this,
        data = ele.data('drag-options'),
        dataset = data.dataset,
        dx = customData[0],
        dy = customData[1],
        px = customData[2],
        py = customData[3];
    dataset._dragMove.call(ele, dx, dy, px, py);
  };

  /**
   * Callback function when dragging of a node is started
   * @param {Object} event The actual event object
   */


  DragNodeDataset.prototype.dragStart = function dragStart(event) {
    var ele = this,
        data = ele.data('drag-options'),
        dataset = data.dataset;
    dataset._dragStart.call(ele, event);
  };

  /**
   * Helper function of dragStart()
   * @param {Object} e The actual event object
   */


  DragNodeDataset.prototype._dragStart = function _dragStart() {
    var element = this,
        data = element.data('drag-options'),
        dataObj = data.dataObj,
        dataGraphics = dataObj.graphics,
        ele = dataGraphics.element,
        bBox = ele.getBBox(),
        config = dataObj.config,
        dataset = data.dataset,
        chart = dataset.getFromEnv('chart'),
        sourceEvent = 'dataplotdragstart',
        groupManager = dataset.getLinkedParent(),

    // graphics = groupManager.graphics,
    // waitElement = graphics.waitElement,
    conf = data.dataset.config,
        viewMode = conf.viewMode,

    // touchEvent = (hasTouch && getTouchEvent(e)) || stubEvent,
    // layerX = e.layerX || touchEvent.layerX,
    // layerY = e.layerY || touchEvent.layerY,
    // paper = dataset.getFromEnv('paper'),
    // waitGroup = dataset.getContainer('dataLabelsGroup'),
    dragStart = config.dragStart || (config.dragStart = {}),
        cloneGraphic = dataObj.graphics.cloneGraphic,
        cloneGraphicGroup = dataset.getContainer('cloneGraphicGroup'),
        cloneText = dataObj.graphics.cloneText,
        image = dataObj.graphics.image,

    // displayValue = config.displayValue,
    cloneImage = dataObj.graphics.cloneImage,

    // style = chart.config.dataLabelStyle,
    // labelAttr,
    label = dataObj.graphics.label,
        eventArgs;
    // shapesInfo = {
    //   circle: 'circ',
    //   rectangle: 'rect',
    //   polygon: 'poly'
    // };
    // attr;
    // Set dirty flag to 1 so that bbox is recalculated again
    if (isVML) {
      ele._.dirty = 1;
    }

    // attr = [config.symbol.split(UNDERSCORE)[1], config._xPos,
    //   config._yPos, config.radius, config.startAngle, 0];
    // labelAttr = {
    //   text: displayValue,
    //   'class': 'fusioncharts-label',
    //   x: config._xPos,
    //   y: config._yPos,
    //   fill: 'rgba(96,99,78,.4)',
    //   'font-size': style.fontSize,
    //   'font-weight': style.fontWeight,
    //   'font-style': style.fontStyle,
    //   'font-family': style.fontFamily,
    //   visibility: visibleStr
    // };
    if (config.allowDrag) {
      if (!cloneGraphic && dataObj.graphics.element) {
        cloneGraphic = dataObj.graphics.cloneGraphic = dataObj.graphics.element.clone();
        cloneGraphicGroup.appendChild(cloneGraphic);
      }
      if (label && !cloneText) {
        cloneText = dataObj.graphics.cloneText = dataObj.graphics.label.clone();
        if (cloneText.followers[0] && cloneText.followers[0].el) {
          cloneGraphicGroup.appendChild(cloneText.followers[0].el);
        }
        cloneGraphicGroup.appendChild(cloneText);
      }
      if (image && !cloneImage) {
        cloneImage = dataObj.graphics.cloneImage = dataObj.graphics.image.clone();
        cloneGraphicGroup.appendChild(cloneImage);
      }
      cloneText && cloneText.show();
      cloneImage && cloneImage.show();
      cloneGraphic && cloneGraphic.show();
    }
    dragStart.xPos = config._xPos;
    dragStart.yPos = config._yPos;
    dragStart.x = config.x;
    dragStart.y = config.y;
    dragStart.bBox = bBox;
    // store original x, y positions
    dragStart.origX = dragStart.lastDx || (dragStart.lastDx = 0);
    dragStart.origY = dragStart.lastDy || (dragStart.lastDy = 0);
    eventArgs = ele.data(EVENTARGS);
    // Whether to fire the click event ot not
    ele.data('fire_click_event', 1);
    ele.data('mousedown', 1);
    clearTimeout(ele._longpressactive);
    chart.fireChartInstanceEvent(sourceEvent, eventArgs);
    // DragNode mouse progress cursor added.
    ele.data('move', true);
    // If view mode is enabled, don't open the node edit UI.
    if (!viewMode) {
      groupManager.drawWaitingRing(dataObj, dataset.config.datasetIndex);
    }
    cloneGraphic && cloneGraphic.show();
    cloneText && cloneText.show();
    cloneImage && cloneImage.show();
  };

  /**
   * Helper function of dragMove()
   * @param {number} dx the drag coordinates
   * @param {number} dy the drag coordinates
   * @param {number} px the drag coordinates
   * @param {number} py the drag coordinates
   */


  DragNodeDataset.prototype._dragMove = function _dragMove(dx, dy) {
    var element = this,
        data = element.data('drag-options'),
        dataObj = data.dataObj,
        ele = dataObj.graphics.element,
        cloneGraphic = dataObj.graphics.cloneGraphic,
        cloneImage = dataObj.graphics.cloneImage,
        cloneText = dataObj.graphics.cloneText,
        config = dataObj.config,
        dragStart = config.dragStart,
        startX = dragStart.bBox.x + dx,
        endX = dragStart.bBox.x2 + dx,
        startY = dragStart.bBox.y + dy,
        endY = dragStart.bBox.y2 + dy,
        dataset = data.dataset,
        animationManager = dataset.getFromEnv('animationManager'),
        parent = dataset.getLinkedParent(),

    // graphics = .getContainer('waitGroup'),
    chartConfig = dataset.getFromEnv('chartConfig'),
        canvasLeft = chartConfig.canvasLeft,
        canvasRight = chartConfig.canvasRight,
        transform,
        canvasTop = chartConfig.canvasTop,
        canvasBottom = chartConfig.canvasBottom;

    // Bound limits
    if (startX < canvasLeft) {
      dx += canvasLeft - startX;
    }
    if (endX > canvasRight) {
      dx -= endX - canvasRight;
    }
    if (startY < canvasTop) {
      dy += canvasTop - startY;
    }
    if (endY > canvasBottom) {
      dy -= endY - canvasBottom;
    }
    if (dx || dy) {
      // graphics.waitElement && graphics.waitElement.hide();
      // Whether to fire the click event or not
      ele.data('fire_click_event', 0);
      parent.hideWaitElem();
      clearLongPress.call(ele);
      parent.clearLongPress();
    }
    if (config.allowDrag) {
      dragStart.draged = true;
      dragStart.lastDx = dx;
      dragStart.lastDy = dy;

      transform = data._transformObj = {
        transform: 't' + (dragStart.origX + dx) + COMMA + (dragStart.origY + dy)
      };
      if (cloneGraphic) {
        animationManager.setAnimation({
          el: cloneGraphic,
          attr: transform,
          component: dataset
        });
      }
      if (cloneImage) {
        animationManager.setAnimation({
          el: cloneImage,
          attr: transform,
          component: dataset
        });
      }
      if (cloneText) {
        animationManager.setAnimation({
          el: cloneText,
          attr: {
            x: config._xPos + dx,
            y: config._yPos + dy
          },
          component: dataset
        });
      }
    }
  };

  /**
   * Helper function of dragUp()
   * @param {Object} event The actual event object
   */


  DragNodeDataset.prototype._dragUp = function _dragUp(event) {
    var element = this,
        data = element.data('drag-options'),
        dataset = data.dataset,

    // chartConfig = dataset.getFromEnv('chartConfig'),
    chart = dataset.getFromEnv('chart'),
        dataStore = dataset.components.data,
        dataObj = data.dataObj,
        ele = dataObj.graphics.element,
        groupManager = dataset.getLinkedParent(),
        startConnectors,
        endConnectors,
        sourceEvent = 'dataplotdragend',
        fireClick = ele.data('fire_click_event'),
        config = dataObj.config,

    // canvasTop = chartConfig.canvasTop,
    // canvasLeft = chartConfig.canvasLeft,
    dragStart = dataObj.config.dragStart || {},
        yAxis = dataset.getFromEnv('yAxis'),
        i,
        setObj,
        len,
        eventCord,
        eventArgs,
        cloneText = dataObj.graphics.cloneText,

    // graphics = dataset.groupManager.graphics,
    xAxis = dataset.getFromEnv('xAxis'),
        updateObj = {},
        datasetIndex = dataset.config.datasetIndex,
        cloneGraphic = dataObj.graphics.cloneGraphic,
        cloneImage = dataObj.graphics.cloneImage;

    groupManager.hideWaitElem();
    clearLongPress.call(this);
    groupManager.clearLongPress();
    ele.data('mousedown', 0);
    fireClick && _lib.plotEventHandler.call(ele, chart, event);
    if (dragStart.draged) {
      dragStart.origX += dragStart.lastDx;
      dragStart.origY += dragStart.lastDy;
      dataObj.config._xPos = dragStart.xPos + dragStart.lastDx;
      dataObj.config._yPos = dragStart.yPos + dragStart.lastDy;
      updateObj.x = xAxis.getValue(dataObj.config._xPos);
      updateObj.y = yAxis.getValue(dataObj.config._yPos);
      updateObj.update = true;
      for (i = 0, len = dataStore.length; i < len; i++) {
        setObj = dataStore[i];
        if (dataObj.config.id === setObj.config.id) {
          break;
        }
      }

      dataset.updatePointConfig(updateObj, i);
      eventArgs = ele.data(EVENTARGS);
      eventArgs.x = updateObj.x;
      eventArgs.y = updateObj.y;
      dataset.parsePlotAttributes(i);
      dataset._drawNode(i);
      // dataset.drawTracker(i, i + 1);
      startConnectors = dataObj.config.startConnectors;
      endConnectors = dataObj.config.endConnectors;
      groupManager.drawNodeConnectors(startConnectors, datasetIndex);
      groupManager.drawNodeConnectors(endConnectors, datasetIndex);
      eventCord = (0, _lib.getMouseCoordinate)(chart.getFromEnv('chart-container'), event);
      eventCord.sourceEvent = sourceEvent;
      // Fire the ChartUpdated event
      // lib.raiseEvent('chartupdated', extend2(eventCord, eventArgs),
      //     chart.chartInstance);

      // groupManager.draw();
      chart.fireChartInstanceEvent(sourceEvent, eventArgs);
      dragStart.draged = false;
    }
    cloneText && cloneText.hide();
    cloneGraphic && cloneGraphic.hide();
    cloneImage && cloneImage.hide();
    delete config.dragStart;
  };

  /**
   * Function to update a specific node at the end of dragging
   * @param {Object} updateConf Having values regarding the new position of the node
   * @param {number} index the index of the node that is to be updated
   */


  DragNodeDataset.prototype.updatePointConfig = function updatePointConfig(updateConf, index) {
    var dataset = this,

    // chart = dataset.chart,
    dataStore = dataset.components.data,
        conf = dataset.config,
        dataObj = dataStore[index] || {},
        config = dataObj.config,
        numberFormatter = dataset.getFromEnv('number-formatter'),
        chartAttr = dataset.getFromEnv('chart-attrib'),

    // yMin = conf.yMin || +Infinity,
    // yMax = conf.yMax || -Infinity,
    // xMax = conf.xMax || -Infinity,
    // xMin = conf.xMin || +Infinity,
    xValue;
    if (config === undefined) {
      return;
    }
    config.y = numberFormatter.getCleanValue((0, _lib.pluck)(updateConf.y));
    config.x = numberFormatter.getCleanValue((0, _lib.pluck)(updateConf.x));
    config._options.x = config.x;
    config._options.y = config.y;
    // yMax = mathMax(yMax, config.y);
    // yMin = mathMin(yMin, config.y);
    // xMax = mathMax(xMax, config.x);
    // xMin = mathMin(xMin, config.x);
    xValue = numberFormatter.xAxis(config.x);
    // push the point object
    config.formatedVal = config.y === null ? config.y : numberFormatter.dataLabels(config.y);
    config.xValue = xValue;
    if (!conf.showTooltip) {
      config.toolText = false;
    } else {
      config.toolText = _configureTooltext(config, conf, chartAttr);
    }
    config.update = updateConf.update;
  };

  /**
   * Returns a node corresponding to the given id
   * @param {string} id The id of the enquired node
   * @return {Object} The object conatining the info about the node
   */


  DragNodeDataset.prototype.getNode = function getNode(id) {
    return id ? this.components.nodes[id] : this.components.nodes;
  };

  /**
    * Function for parsing all the attributes and value given by the user at chart and dataset level.
    * This function is called once from the init() function of the Column class.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} if no datasetJSON is found
    */


  DragNodeDataset.prototype.configure = function configure(datasetJSON) {
    if (datasetJSON) {
      this.trimData(datasetJSON);
      this.config.JSONData = datasetJSON;
    } else if (!datasetJSON && !this.config.JSONData) {
      return false;
    }

    var dataset = this,
        dIndex = dataset.index,
        JSONData = dataset.config.JSONData,
        data = JSONData.data || [],
        chartAttr = dataset.getFromEnv('chart-attrib'),
        chartConfig = dataset.getFromEnv('chartConfig'),
        dataLength = data.length,
        conf = dataset.config,

    // showValues,
    ZERO = _lib.ZEROSTRING,
        colorM = dataset.getFromEnv('color-manager'),
        index,
        plotFillAlpha,
        showPlotBorder,
        plotBorderColor,
        plotBorderThickness,
        plotBorderAlpha,

    // datasetId,
    datasetPlotBorderThickness,

    // dataStore,
    // dataStoreLen,
    useRoundEdges,
        HUNDRED = _lib.HUNDREDSTRING;
    conf.context = {};
    dataset.components.nodes = {};
    conf.showValues = (0, _lib.pluckNumber)(JSONData.showvalues, chartAttr.showvalues, 1);
    useRoundEdges = conf.useRoundEdges = (0, _lib.pluckNumber)(chartAttr.useroundedges);
    conf.zIndex = 1;
    conf.name = (0, _lib.getValidValue)(JSONData.seriesname);
    conf.viewMode = (0, _lib.pluckNumber)(chartAttr.viewmode, 0);
    conf.id = (0, _lib.pluck)(JSONData.id, dataset.index);
    if ((0, _lib.pluckNumber)(JSONData.includeinlegend) === 0 || conf.name === undefined) {
      conf.showInLegend = false;
    }
    conf.includeInLegend = (0, _lib.pluckNumber)(JSONData.includeinlegend, 1);

    conf.showTooltip = (0, _lib.pluckNumber)(chartAttr.showtooltip, 1);
    conf.seriesNameInTooltip = (0, _lib.pluckNumber)(chartAttr.seriesnameintooltip, 1);
    conf.tooltipSepChar = (0, _lib.pluck)(chartAttr.tooltipsepchar, ' - ');
    // Plot Properties
    plotFillAlpha = conf.plotFillAlpha = (0, _lib.pluck)(chartAttr.plotfillalpha, HUNDRED);
    showPlotBorder = conf.showPlotBorder = (0, _lib.pluckNumber)(chartAttr.showplotborder, 1);
    plotBorderColor = conf.plotBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.plotbordercolor, '666666'));
    plotBorderThickness = conf.plotBorderThickness = (0, _lib.pluckNumber)(chartAttr.plotborderthickness, useRoundEdges ? 2 : 1);
    plotBorderAlpha = conf.plotBorderAlpha = (0, _lib.pluck)(chartAttr.plotborderalpha, chartAttr.plotfillalpha, useRoundEdges ? '35' : '95');

    // Node Properties
    conf.use3DLighting = Boolean((0, _lib.pluckNumber)(chartAttr.use3dlighting, chartAttr.is3d, useRoundEdges ? 1 : 0));
    // Store attributeshc
    conf.color = (0, _lib.getFirstColor)((0, _lib.pluck)(JSONData.color, colorM.getPlotColor(dIndex)));
    conf.alpha = (0, _lib.pluck)(JSONData.plotfillalpha, JSONData.nodeFillAlpha, JSONData.alpha, plotFillAlpha);
    // Data set plot properties
    conf.datasetShowPlotBorder = Boolean((0, _lib.pluckNumber)(JSONData.showplotborder, showPlotBorder));
    conf.datasetPlotBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(JSONData.plotbordercolor, JSONData.nodebordercolor, plotBorderColor));
    conf.datasetPlotBorderThickness = (0, _lib.pluckNumber)(JSONData.plotborderthickness, JSONData.nodeborderthickness, plotBorderThickness);
    conf.datasetPlotBorderAlpha = conf.datasetShowPlotBorder ? (0, _lib.pluck)(JSONData.plotborderalpha, JSONData.nodeborderalpha, JSONData.alpha, plotBorderAlpha) : ZERO;
    conf.seriesname = (0, _lib.parseUnsafeString)(JSONData.seriesname);
    // Drag Border properties
    conf.datasetAllowDrag = Boolean((0, _lib.pluckNumber)(JSONData.allowdrag, 1));

    conf.colorObj = {
      fillColor: (0, _lib.convertColor)(conf.color, conf.alpha),
      lineColor: {
        FCcolor: {
          color: conf.datasetPlotBorderColor,
          alpha: conf.datasetPlotBorderAlpha
        }
      }
    };
    conf.lineWidth = datasetPlotBorderThickness;
    conf.symbol = 'poly_4';
    // dataStore = dataset.components.data =
    dataset.components.data || (dataset.components.data = []);
    // dataStoreLen = dataStore.length;
    // if (dataStoreLen > dataLength) {
    //   dataStore.splice(dataLength, dataStoreLen - dataLength);
    // }

    dataset.setState('visible', (0, _lib.pluckNumber)(JSONData.visible, !Number(JSONData.initiallyhidden), 1) === 1);
    conf.yMin = conf.yMax = conf.xMax = conf.xMin = 0;
    // This flag is true when data update is fired
    dataset._refreshData = true;
    // Iterate through all level data
    for (index = 0; index < dataLength; index += 1) {
      this._setConfigure(index);
    }
    dataset._refreshData = false;
    chartConfig.showLegend && dataset._addLegend();
    dataset._setDatasetIndex();
    dataset.setState('dirty', true);
  };

  /**
   * Function for parsing all the attributes and value given by the user at set level.
   * @param {number} index The data index for which the configuration is to be prsed.
   * @param {Object} updateObj It has the information of the data given by the user
   */


  DragNodeDataset.prototype._setConfigure = function _setConfigure(index, updateObj) {
    var dataset = this,
        JSONData = dataset.config.JSONData,
        data = JSONData.data,
        setData = updateObj || data[index],
        dataStore = dataset.components.data,
        conf = dataset.config,
        dataObj = dataStore[index] = dataStore[index] || (dataStore[index] = {}),
        config = dataObj.config = dataObj.config || (dataObj.config = {}),
        datasetId = conf.id,
        shape,
        yMin = conf.yMin || +Infinity,
        yMax = conf.yMax || -Infinity,
        xMax = conf.xMax || -Infinity,
        xMin = conf.xMin || +Infinity,
        itemValueY,
        itemValueX,
        label,
        safeLabel,
        shapeType,
        use3DLighting = conf.use3DLighting,
        datasetPlotBorderThickness = conf.datasetPlotBorderThickness,
        datasetPlotBorderColor = conf.datasetPlotBorderColor,
        datasetPlotBorderAlpha = conf.datasetPlotBorderAlpha,

    // chart = dataset.chart,
    chartAttr = dataset.getFromEnv('chart-attrib'),
        datasetColor = conf.color,
        datasetAlpha = conf.alpha,

    // fillColor,
    datasetAllowDrag = conf.datasetAllowDrag,
        numberFormatter = dataset.getFromEnv('number-formatter');

    !dataObj.graphics && (dataObj.graphics = {});
    config._options = (0, _lib.extend2)({}, setData);
    if (setData || updateObj) {
      itemValueY = config.y = numberFormatter.getCleanValue((0, _lib.pluck)(setData.y));
      itemValueX = config.x = numberFormatter.getCleanValue((0, _lib.pluck)(setData.x));
      config.index = index;
      if (!config.dragStart) {
        config.dragStart = {};
      }
      yMax = mathMax(yMax, config.y);
      yMin = mathMin(yMin, config.y);
      xMax = mathMax(xMax, config.x);
      xMin = mathMin(xMin, config.x);
      if (itemValueY === null) {
        config.value = null;
      } else {
        label = numberFormatter.xAxis(itemValueX);
        // push the point object
        config.formatedVal = itemValueY === null ? itemValueY : numberFormatter.dataLabels(itemValueY);
        config.setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.tooltext, JSONData.plottooltext, chartAttr.plottooltext)));
        config.pointLabel = (0, _lib.pluck)(setData.label, setData.name);
        safeLabel = (0, _lib.parseUnsafeString)(config.pointLabel);
        config.label = safeLabel;
        config.name = safeLabel;
        config.displayValue = safeLabel;
        config.xValue = label;
        if (!updateObj) {
          config.startConnectors = {};
          config.endConnectors = {};
        }
        // create the tooltext
        if (!conf.showTooltip) {
          config.toolText = false;
        } else {
          config.toolText = _configureTooltext(config, conf, chartAttr);
        }
        config.link = setData.link;
        // Shape and cosmetics related attributes
        config.id = (0, _lib.pluck)(setData.id, datasetId + _lib.preDefStr.UNDERSCORE + index);
        config.allowDrag = Boolean((0, _lib.pluckNumber)(setData.allowdrag, datasetAllowDrag));
        shape = config.shape = (0, _lib.getValidValue)((0, _lib.pluck)(setData.shape), _lib.preDefStr.RECTANGLE).toLowerCase();
        config.height = (0, _lib.getValidValue)((0, _lib.pluck)(setData.height), 10);
        config.width = (0, _lib.getValidValue)((0, _lib.pluck)(setData.width), 10);
        config.radius = (0, _lib.getValidValue)((0, _lib.pluck)(setData.radius), 10);
        config.numSides = (0, _lib.getValidValue)((0, _lib.pluck)(setData.numsides), 4);
        config.color = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.color, datasetColor));
        config.borderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.bordercolor, datasetPlotBorderColor));
        config.alpha = (0, _lib.pluck)(setData.alpha, datasetAlpha);
        config.imageURL = (0, _lib.getValidValue)(setData.imageurl);
        config.imageNode = Boolean((0, _lib.pluckNumber)(setData.imagenode));
        config.imageWidth = setData.imagewidth;
        config.imageHeight = setData.imageheight;
        config.imageAlign = (0, _lib.getValidValue)(setData.imagealign, _lib.BLANK).toLowerCase();
        config.labelAlign = (0, _lib.pluck)(setData.labelalign, config.imageNode && defined(config.imageURL) ? POSITION_TOP : _lib.preDefStr.POSITION_MIDDLE);
        // If not required shape then set it to rectangle
        switch (config.shape) {
          case CIRCLE:
            shapeType = 0;
            break;
          case POLYGON:
            shapeType = 2;
            shape = _lib.graphics.mapSymbolName(config.numSides);
            break;
          default:
            shapeType = 1;
            break;
        }
        config.symbol = shape;
        if (use3DLighting) {
          config.fillColor = getPointColor(config.color, config.alpha, shapeType);
          config.cloneFillColor = getPointColor(config.color, 50, shapeType);
        } else {
          config.fillColor = {
            color: config.color,
            alpha: config.alpha
          };
          config.cloneFillColor = (0, _lib.convertColor)(config.color, 50);
        }

        config.rollOverProperties = dataset.pointHoverOptions(dataObj, chartAttr, {
          shapeType: shapeType,
          use3D: use3DLighting,
          height: config.height,
          width: config.width,
          radius: config.radius,
          color: config.color,
          alpha: config.alpha,
          borderColor: config.borderColor,
          borderAlpha: datasetPlotBorderAlpha,
          borderThickness: datasetPlotBorderThickness
        });
      }
      !config.update && updateObj && (config.update = updateObj.update);
      !config.add && updateObj && (config.add = updateObj.add);
      if (dataset._refreshData === true) {
        delete dataObj.removed;
      }
    }
    dataObj.dataset = dataset;
    conf.xMax = xMax;
    conf.xMin = xMin;
    conf.yMin = yMin;
    conf.yMax = yMax;
  };

  /**
   * Function for parsing the hover effects
   * @param {Object} dataObj Containing the set level information used for creating the hover effect
   * @param {Object} chartAttr Containing the chart level information used for creating the hover effect
   * @param {Object} defaults Containing the default information used for creating the hover effect
   * @return {Object} Containg the final parsed hover properties
   */


  DragNodeDataset.prototype.pointHoverOptions = function pointHoverOptions(dataObj, chartAttr, defaults) {
    var dataset = this,
        hoverEffect = (0, _lib.pluckNumber)(dataObj.showhovereffect, dataset.showhovereffect, chartAttr.plothovereffect, chartAttr.showhovereffect),
        rolloverProperties = {},
        hoverAttr = !!(0, _lib.pluck)(dataObj.hovercolor, dataset.hovercolor, chartAttr.plotfillhovercolor, dataObj.hoveralpha, dataset.hoveralpha, chartAttr.plotfillhoveralpha, dataObj.borderhovercolor, dataset.borderhovercolor, chartAttr.plotborderhovercolor, dataObj.borderhoveralpha, dataset.borderhoveralpha, chartAttr.plotborderhoveralpha, dataObj.borderhoverthickness, dataset.borderhoverthickness, chartAttr.plotborderhoverthickness, dataObj.hoverheight, dataset.hoverheight, chartAttr.plothoverheight, dataObj.hoverwidth, dataset.hoverwidth, chartAttr.plothoverwidth, dataObj.hoverradius, dataset.hoverradius, chartAttr.plothoverradius, hoverEffect),
        enabled = false,
        color,
        alpha,
        fillColor;

    if (hoverEffect === undefined && hoverAttr || hoverEffect) {
      enabled = true;
      color = (0, _lib.pluck)(dataObj.hovercolor, dataset.hovercolor, chartAttr.plotfillhovercolor, _lib.graphics.getLightColor(defaults.color, 70));
      alpha = (0, _lib.pluck)(dataObj.hoveralpha, dataset.hoveralpha, chartAttr.plotfillhoveralpha, defaults.alpha);

      rolloverProperties = {
        stroke: (0, _lib.convertColor)((0, _lib.pluck)(dataObj.borderhovercolor, dataset.borderhovercolor, chartAttr.plotborderhovercolor, defaults.borderColor), (0, _lib.pluckNumber)(dataObj.borderhoveralpha, dataset.borderhoveralpha, chartAttr.plotborderhoveralpha, alpha, defaults.borderAlpha)),
        'stroke-width': (0, _lib.pluckNumber)(dataObj.borderhoverthickness, dataset.borderhoverthickness, chartAttr.plotborderhoverthickness, defaults.borderThickness),
        height: (0, _lib.pluckNumber)(dataObj.hoverheight, dataset.hoverheight, chartAttr.plothoverheight, defaults.height),
        width: (0, _lib.pluckNumber)(dataObj.hoverwidth, dataset.hoverwidth, chartAttr.plothoverwidth, defaults.width),
        r: (0, _lib.pluckNumber)(dataObj.hoverradius, dataset.hoverradius, chartAttr.plothoverradius, defaults.radius)
      };

      if (defaults.use3D) {
        fillColor = getPointColor((0, _lib.getFirstColor)((0, _lib.pluck)(dataObj.hovercolor, dataset.hovercolor, chartAttr.plotfillhovercolor, _lib.graphics.getLightColor(defaults.color, 70))), (0, _lib.pluck)(dataObj.hoveralpha, dataset.hoveralpha, chartAttr.plotfillhoveralpha, defaults.alpha), defaults.shapeType);
      } else {
        fillColor = (0, _lib.convertColor)(color, alpha);
      }

      rolloverProperties.fill = (0, _lib.toRaphaelColor)(fillColor);
    }

    return {
      enabled: enabled,
      rollOverAttrs: rolloverProperties
    };
  };

  /**
   * Function for attaching a legend with a dataset
   */


  DragNodeDataset.prototype._addLegend = function _addLegend() {
    var dataset = this,

    // chart = dataset.chart,
    conf = dataset.config,
        legendItem,
        legend = dataset.getFromEnv('legend'),
        config = {
      enabled: conf.includeInLegend,
      type: dataset.type,
      anchorSide: 4,
      label: (0, _lib.getFirstValue)(dataset.config.JSONData.seriesname)
    };
    if (conf.includeinlegend) {
      legendItem = legend.getItem(dataset.config.legendItemId);
      if (!legendItem) {
        dataset.config.legendItemId = legend.createItem(dataset);
        legendItem = legend.getItem(dataset.config.legendItemId);
        dataset.addExtEventListener('click', function () {
          dataset.legendInteractivity(legendItem);
        }, legendItem);
      } else {
        legendItem.configure({ style: legend.config.itemStyle,
          hiddenStyle: legend.config.itemHiddenStyle,
          datasetVisible: legend.config.datasetVisible,
          hoverStyle: legend.config.itemHoverStyle });
      }
      legendItem.configure(config);
      legendItem.setStateCosmetics('default', {
        symbol: {
          fill: (0, _lib.toRaphaelColor)({
            color: conf.color,
            alpha: conf.alpha
          }),
          stroke: (0, _lib.toRaphaelColor)({
            color: conf.plotBorderColor,
            alpha: _lib.HUNDREDSTRING
          }),
          'stroke-width': conf.anchorBorderThickness
        }
      });
      // check if dataset is initiallyhidden
      if (!dataset.getState('visible')) {
        legendItem.setLegendState('hidden');
      }
    } else if (dataset.config.legendItemId) {
      legend.disposeItem(dataset.config.legendItemId);
    }
  };

  /**
   * Function to create graphical container for the specific dataset
   */


  DragNodeDataset.prototype.createContainer = function createContainer() {
    var dataset = this,
        animationManager = dataset.getFromEnv('animationManager'),
        parentContainer = dataset.getLinkedParent().getChildContainer();

    !dataset.getContainer('nodesGroup') && dataset.addContainer('nodesGroup', createGroup('nodesGroup', animationManager, parentContainer.defaultVcanvasGroup, dataset));

    !dataset.getContainer('dataLabelsGroup') && dataset.addContainer('dataLabelsGroup', createGroup('dataLabelsGroup', animationManager, parentContainer.vcanvasLabelGroup, dataset));

    !dataset.getContainer('cloneGraphicGroup') && dataset.addContainer('cloneGraphicGroup', createGroup('cloneGraphicGroup', animationManager, parentContainer.defaultVcanvasGroup, dataset));
  };

  /**
   * Draw function of DragNodeDataset
   */


  DragNodeDataset.prototype.draw = function draw() {
    var dataset = this,
        components = dataset.components,

    // parent = dataset.getLinkedParent(),
    // datasetGraphics = parent.getChildContainer(),
    // chart = dataset.chart,
    // jobList = chart.getJobList(),
    smartLabel = dataset.getFromEnv('smartLabel'),
        data = components.data,
        removeDataArr = dataset.components.removeDataArr || [],
        removeDataArrLen = removeDataArr.length,
        i,

    // paper = dataset.getFromEnv('paper'),
    ln,
        group,

    // config,
    style = dataset.getFromEnv('dataLabelStyle'),

    // css = {
    //   fontFamily: style.fontFamily,
    //   fontSize: style.fontSize,
    //   lineHeight: style.lineHeight,
    //   fontWeight: style.fontWeight,
    //   fontStyle: style.fontStyle
    // },
    // dragLabelGroup,
    removed;
    // layers = chart.graphics, // requird for series
    // gDataset = layers.datasetGroup;

    if (!dataset.getState('dirty') && !dataset._contextChanged()) {
      return;
    }
    dataset.createContainer();
    group = dataset.getContainer('nodesGroup');
    // dragLabelGroup = dataset.getContainer('dataLabelsGroup');
    dataset.getFromEnv('animationManager').setAnimation({
      el: dataset.getContainer('cloneGraphicGroup'),
      attr: { opacity: 0.3 },
      component: dataset
    });
    // group.trackTooltip(true);
    group.css(style);
    smartLabel.useEllipsesOnOverflow(dataset.getFromEnv('chartConfig').useEllipsesWhenOverflow);
    // smartLabel.setStyle(style);
    // group.css(css);
    // draw data
    for (i = 0, ln = data.length; i < ln; i += 1) {
      // config = data[i].config;
      removed = data[i].removed;
      !removed && this._drawNode(i);
    }
    // jobList.trackerDrawID.push(schedular.addJob(dataset.drawTracker, dataset, [],
    //     lib.priorityList.tracker));
    // !dataset.drawn && jobList.labelDrawID.push(schedular.addJob(function () {
    // dataset.drawLabel();
    // }, lib.priorityList.label));
    dataset.config.drawn = true;

    // if (dataset.visible) {
    //   group.show();
    //   // dragLabelGroup.show();
    // }
    // Remove the extra elements
    for (i = 0; i < removeDataArrLen; i++) {
      dataset._removeDataVisuals(removeDataArr.shift());
    }
  };

  /**
   * Draw the individual data labels for the nodes
   * @param {number} index The index of the datalabel that is to be drawn
   */


  DragNodeDataset.prototype.drawLabel = function drawLabel(index) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        datasetIndex = dataset.config.datasetIndex,
        animationManager = dataset.getFromEnv('animationManager'),
        toolTipController = dataset.getFromEnv('toolTipController'),
        dataStore = dataset.components.data,
        i,
        len = dataStore.length,
        labelAttrs,
        labelElement,
        group = dataset.getContainer('nodesGroup'),

    // style = chart.config.dataLabelStyle,
    // animationObj = chart.get('config', 'animationObj'),
    // dummyAnimElem = animationObj.dummyObj,
    // dummyAnimObj = animationObj.animObj,
    config,
        valueString,
        chartConfig = dataset.getFromEnv('chartConfig'),
        style = dataset.getFromEnv('dataLabelStyle'),
        cursor,
        smartTextObj,
        labelDisplacement,
        eventArgs,
        set,
        yAdjustment,

    // animType = animationObj.animType,
    xPos,
        labelY,
        groupId,
        cloneText,
        plotWidth,
        plotHeight,
        labelAlign,
        setGraphics,
        dragUp = dataset.dragUp,
        dragMove = dataset.dragMove,
        dragStart = dataset.dragStart,
        rollOverProperties,
        shapeType,
        yPos,
        smartLabel = dataset.getFromEnv('smartLabel'),
        setElement,
        visible = dataset.getState('visible');

    if (index !== undefined) {
      i = index;
      len = i + 1;
    } else {
      i = 0;
    }

    for (; i < len; i++) {
      set = dataStore[i];
      config = set.config;
      plotWidth = config._plotWidth;
      plotHeight = config._plotHeight;
      valueString = config.displayValue;
      labelAlign = config.labelAlign;
      setGraphics = set.graphics;
      cloneText = setGraphics.cloneText;
      rollOverProperties = set.config.rollOverProperties;
      shapeType = config.shapeType;

      if (visible && (defined(valueString) || valueString !== _lib.BLANK)) {
        // Get the displayValue text according to the canvas width.
        smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
        smartTextObj = smartLabel.getSmartText(valueString, plotWidth, plotHeight);

        // label displacement for top or bottom
        labelDisplacement = plotHeight * 0.5 - smartTextObj.height * 0.5;
        // label at TOP
        switch (labelAlign) {
          case POSITION_TOP:
            labelDisplacement = -labelDisplacement;
            break;
          case _lib.POSITION_BOTTOM:
            break;
          default:
            labelDisplacement = 0;
            break;
        }
        xPos = config._xPos;
        yPos = config._yPos;
        set._yAdjustment = yAdjustment = labelDisplacement;
        labelY = yPos + yAdjustment;
        cursor = config.link ? _lib.POINTER : config.allowDrag ? 'move' : _lib.BLANKSTRING;

        labelAttrs = {
          text: smartTextObj.text,
          title: smartTextObj.tooltext || _lib.BLANKSTRING,
          fill: style.color,
          'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash],
          x: xPos,
          y: labelY,
          cursor: cursor
        };

        labelElement = setGraphics.label;

        labelElement = animationManager.setAnimation({
          el: labelElement || 'text',
          attr: labelAttrs,
          container: group,
          component: dataset
        });

        if (!setGraphics.label) {
          labelElement = dataset.addGraphicalElement('plotLabel', labelElement, true);
          setGraphics.label = labelElement;

          labelElement.hover(rolloverResponseSetter(set, rollOverProperties && rollOverProperties.enabled, dataset), rolloutResponseSetter(set, rollOverProperties && rollOverProperties.enabled, dataset));

          // If dragging is allowed for that node then only we bind drag functions to the labelElement
          labelElement.drag(dragMove, dragStart, dragUp);
        } else {
          labelElement.show();
        }

        setElement = setGraphics && (setGraphics.image || setGraphics.element);

        setElement && labelElement.insertAfter(setElement);

        if (cloneText) {
          animationManager.setAnimation({
            el: cloneText,
            attr: {
              transform: _lib.BLANKSTRING,
              x: xPos,
              y: labelY,
              text: smartTextObj.text,
              title: smartTextObj.tooltext || _lib.BLANKSTRING,
              fill: style.color,
              'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
            },
            component: dataset
          });
        }

        toolTipController.enableToolTip(labelElement, config.toolText);
        // labelElement.tooltip(config.toolText);

        labelElement.data('drag-options', {
          dataObj: set,
          dataset: dataset,
          datasetIndex: datasetIndex,
          pointIndex: set.config.index,
          cursor: cursor,
          chart: chart,
          link: set.link
        });

        eventArgs = {
          index: i,
          link: config.link,
          y: config.y,
          x: config.x,
          shape: (0, _lib.pluck)(shapeType, 'rect'),
          width: config.width,
          height: config.height,
          radius: config.radius,
          sides: config.numSides,
          label: config.displayValue,
          toolText: config.toolText,
          id: config.id,
          datasetIndex: datasetIndex,
          datasetName: dataset.config.JSONData.seriesname,
          sourceType: 'dataplot'
        };

        groupId = datasetIndex + '_' + i;
        labelElement.data(GROUPID, groupId);
        labelElement.data(EVENTARGS, eventArgs);
        labelElement.data('hoverAttr', rollOverProperties && rollOverProperties.rollOverAttrs);
        labelElement.data('unHoverAttr', setElement.data('unHoverAttr'));
      } else {
        setGraphics.label && setGraphics.label.hide();
      }
    }
  };

  /**
   * Parses plot cosmetics and calculates position
   *
   * @param {any} i index
   * @memberof DragNodeDataset
   */


  DragNodeDataset.prototype.parsePlotAttributes = function parsePlotAttributes(i) {
    var dataset = this,
        datasetIndex = dataset.config.datasetIndex,
        datasetComponents = dataset.components,
        nodes = datasetComponents.nodes,
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),
        data = datasetComponents.data,
        set = data[i],
        config = set.config,
        conf = dataset.config,
        xPos,
        yPos,
        setGraphics = set.graphics || (set.graphics = {}),
        symbol = config.symbol,
        width,
        height,
        radius,
        id,
        imageNode,
        confShapeArg,
        imageURL,
        imageAlign,
        lineColor = conf.colorObj.lineColor,
        lineWidth = conf.datasetPlotBorderThickness,
        plotWidth,
        plotHeight,
        isRectangle,
        rollOverProperties = set.config.rollOverProperties,
        imageWidth,
        imageHeight,
        imageY,
        pointAttr,
        fill,
        shapeType = config.shape,
        cursor = config.link ? _lib.POINTER : config.allowDrag ? 'move' : _lib.BLANKSTRING,
        rollOverAttrs,
        polypath,
        cloneImage = setGraphics.cloneImage,
        attr,
        cloneImageAttr,
        imageElementAttr;

    config._yPos = yPos = yAxis.getPixel(config.y);
    config._xPos = xPos = xAxis.getPixel(config.x);
    // only draw the point if y is defined
    if (yPos !== undefined && !isNaN(yPos)) {
      config.shapeArg = {};
      confShapeArg = config.shapeArg;
      height = (0, _lib.pluckNumber)(config.height);
      width = (0, _lib.pluckNumber)(config.width);
      radius = (0, _lib.pluckNumber)(config.radius);
      isRectangle = symbol === RECTANGLE;
      id = config.id;
      imageNode = config.imageNode;
      imageURL = config.imageURL;
      imageAlign = config.imageAlign; // TOP, MIDDLE or BOTTOM
      plotWidth = isRectangle ? width : radius * 1.4;
      imageWidth = (0, _lib.pluckNumber)(config.imageWidth, plotWidth);
      plotHeight = isRectangle ? height : radius * 1.4;
      imageHeight = (0, _lib.pluckNumber)(config.imageHeight, plotHeight);
      fill = (0, _lib.toRaphaelColor)(config.fillColor);
      config._plotWidth = plotWidth;
      config._plotHeight = plotHeight;
      pointAttr = {
        fill: fill,
        'stroke-width': lineWidth,
        stroke: (0, _lib.toRaphaelColor)(lineColor)
      };
      symbol = confShapeArg.symbol = (0, _lib.pluck)(config.symbol, conf.symbol, _lib.BLANK);
      symbol = symbol.split(UNDERSCORE);

      polypath = [symbol[1], xPos, yPos, config.radius, config.startAngle, 0];

      if (symbol[0] === 'poly' || symbol[0] === CIRCLE) {
        config.shapeType = symbol[0];
        config.elemType = 'polypath';
        attr = {
          polypath: polypath
        };
        confShapeArg.x = xPos;
        confShapeArg.y = yPos;
        confShapeArg.radius = config.radius;
        confShapeArg.sides = symbol[1];
      } else {
        config.shapeType = _lib.SHAPE_RECT;
        config.elemType = 'rect';
        confShapeArg.x = xPos - width / 2;
        confShapeArg.y = yPos - height / 2;
        confShapeArg.r = 0;
        confShapeArg.width = width;
        confShapeArg.height = height;
        attr = {
          x: confShapeArg.x,
          y: confShapeArg.y,
          width: width,
          height: height,
          r: 0
        };
        pointAttr.width = width;
        pointAttr.height = height;
        pointAttr.x = xPos - width / 2;
        pointAttr.y = yPos - height / 2;
        // Readjust x and y of the rectangle if hover width or height is
        // changed
        if (rollOverProperties && rollOverProperties.enabled) {
          rollOverAttrs = rollOverProperties.rollOverAttrs;
          rollOverAttrs.x = xPos - rollOverAttrs.width / 2;
          rollOverAttrs.y = yPos - rollOverAttrs.height / 2;
          delete rollOverAttrs.r;
        }
      }

      attr.fill = fill;
      attr['stroke-width'] = lineWidth;
      attr.stroke = (0, _lib.toRaphaelColor)(lineColor);

      config.eventArgs = {
        index: i,
        link: config.link,
        y: config.y,
        x: config.x,
        shape: (0, _lib.pluck)(shapeType, 'rect'),
        width: width,
        height: height,
        radius: radius,
        sides: config.numSides,
        label: config.displayValue,
        toolText: config.toolText,
        id: config.id,
        datasetIndex: datasetIndex,
        datasetName: dataset.config.JSONData.seriesname,
        sourceType: 'dataplot'
      };

      // Draw the imageNode if available
      if (imageNode && imageURL) {
        if (imageHeight > plotHeight) {
          imageHeight = plotHeight;
        }
        if (imageWidth > plotWidth) {
          imageWidth = plotWidth;
        }
        switch (imageAlign) {
          case _lib.POSITION_MIDDLE:
            imageY = yPos - imageHeight / 2;
            break;
          case _lib.POSITION_BOTTOM:
            imageY = plotHeight > imageHeight ? yPos + plotHeight / 2 - imageHeight : yPos - imageHeight / 2;
            break;
          default:
            imageY = plotHeight > imageHeight ? yPos - plotHeight * 0.5 : yPos - imageHeight / 2;
            break;
        }
        config.imageX = xPos - imageWidth / 2;
        config.imageY = imageY;
        config.imageWidth = imageWidth;
        config.imageHeight = imageHeight;

        imageElementAttr = {
          src: imageURL,
          x: config.imageX,
          y: imageY,
          width: imageWidth,
          height: imageHeight,
          cursor: cursor
        };
        if (cloneImage) {
          cloneImageAttr = {
            transform: _lib.BLANKSTRING,
            src: imageURL,
            x: config.imageX,
            y: imageY,
            width: imageWidth,
            height: imageHeight
          };
        }
      }
      config.pointAttr = pointAttr;
      nodes[id] = set;
      config.props = {
        element: {
          attr: attr
        },
        imageElement: {
          attr: imageElementAttr
        },
        cloneImage: {
          attr: cloneImageAttr
        },
        cloneGraphic: {
          attr: attr
        }
      };
    }
  };
  /**
   * Allocates position and parses cosmetics during post space management
   *
   * @memberof DragNodeDataset
   */


  DragNodeDataset.prototype.allocatePosition = function allocatePosition() {
    var dataset = this,
        data = dataset.components.data,
        i,
        len;

    len = data.length;
    for (i = 0; i < len; i++) {
      dataset.parsePlotAttributes(i);
    }
  };
  /**
   * Draw the individual nodes of the dataset
   * @param {number} i The index of the node that is to be drawn
   */


  DragNodeDataset.prototype._drawNode = function _drawNode(i) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        toolTipController = dataset.getFromEnv('toolTipController'),
        datasetIndex = dataset.config.datasetIndex,
        manager = dataset.getLinkedParent(),
        datasetComponents = dataset.components,
        nodes = datasetComponents.nodes,
        animationManager = dataset.getFromEnv('animationManager'),
        data = datasetComponents.data,
        set = data[i],
        config = set.config,
        setGraphics = set.graphics || (set.graphics = {}),
        id,
        groupId,
        imageNode,
        imageURL,
        group = dataset.getContainer('nodesGroup'),
        rollOverProperties = set.config.rollOverProperties,
        dragUp = dataset.dragUp,
        dragMove = dataset.dragMove,
        dragStart = dataset.dragStart,
        cursor = config.link ? _lib.POINTER : config.allowDrag ? 'move' : _lib.BLANKSTRING,
        type,
        setElement = setGraphics.graphic,
        cloneText = setGraphics.cloneText,
        cloneGraphic = setGraphics.cloneGraphic,
        cloneImage = setGraphics.cloneImage,
        imageElement = setGraphics.image,
        labelElement = setGraphics.label,
        visible = dataset.getState('visible');

    // only draw the point if y is defined
    if (config._yPos !== undefined && !isNaN(config._yPos)) {
      setElement = setGraphics.element;
      type = setElement && setElement.type;
      if (config.elemType.indexOf(type) === -1 && setElement) {
        setElement.remove();
        setElement = setGraphics.element = null;
        labelElement && labelElement.remove();
        imageElement && imageElement.remove();
        delete setGraphics.label;
        delete setGraphics.image;
        imageElement = null;
        labelElement = null;
      }
      setElement = animationManager.setAnimation({
        el: setElement || config.elemType,
        label: 'node',
        attr: config.props.element.attr,
        container: group,
        component: dataset
      });
      // Create a new element
      if (!setGraphics.graphic) {
        setElement.hover(rolloverResponseSetter(set, rollOverProperties && rollOverProperties.enabled, dataset), rolloutResponseSetter(set, rollOverProperties && rollOverProperties.enabled, dataset));

        // If dragging is allowed for that node then only we bind drag functions to the setElement
        setElement.drag(dragMove, dragStart, dragUp);
      }
      setGraphics.element = setElement;
      setElement.show();
      manager.animationDone = true;

      groupId = datasetIndex + '_' + i;

      if (cloneGraphic) {
        if (cloneGraphic.type === setElement.type) {
          animationManager.setAnimation({
            el: cloneGraphic,
            attr: config.props.element.attr,
            component: dataset
          }).transform(_lib.BLANKSTRING);
        } else {
          cloneGraphic.remove();
          delete set.graphics.cloneGraphic;
          if (cloneText) {
            cloneText.remove();
            delete set.graphics.cloneText;
          }
        }
      }

      // Draw the imageNode if available
      if (imageNode && imageURL) {
        imageElement = animationManager.setAnimation({
          el: setGraphics.image || 'image',
          attr: config.props.imageElement.attr,
          container: group,
          component: dataset
        });
        if (!setGraphics.image) {
          // imageElement.tooltip(config.toolText);
          imageElement.hover(rolloverResponseSetter(set, rollOverProperties && rollOverProperties.enabled, dataset), rolloutResponseSetter(set, rollOverProperties && rollOverProperties.enabled, dataset));
          // If dragging is allowed for that node then only
          // we bind drag functions to the imageElement
          imageElement.drag(dragMove, dragStart, dragUp);
        }
        setGraphics.image = imageElement;
        imageElement.show();
        toolTipController.enableToolTip(imageElement, config.toolText);
        // imageElement.tooltip(config.toolText);

        imageElement.data('drag-options', {
          dataObj: set,
          dataset: dataset,
          datasetIndex: dataset.index,
          pointIndex: set.config.index,
          cursor: cursor,
          link: set.link
        });

        imageElement.data(GROUPID, groupId);
        imageElement.data(EVENTARGS, config.eventArgs);
        imageElement.data('hoverAttr', rollOverProperties && rollOverProperties.rollOverAttrs);
        imageElement.data('unHoverAttr', config.pointAttr);

        if (cloneImage) {
          animationManager.setAnimation({
            el: cloneImage,
            attr: config.props.cloneImage.attr,
            component: dataset
          });
        }
      }
      dataset.drawLabel(i);
      nodes[id] = set;
      animationManager.setAnimation({
        el: setElement,
        attr: { cursor: cursor },
        component: dataset
      });
      toolTipController.enableToolTip(setElement, config.toolText);

      setElement.data('drag-options', {
        dataObj: set,
        dataset: dataset,
        datasetIndex: dataset.index,
        pointIndex: set.config.index,
        cursor: cursor,
        chart: chart,
        link: set.link
      });
      setElement.data(GROUPID, groupId);
      setElement.data(EVENTARGS, config.eventArgs);
      setElement.data('hoverAttr', rollOverProperties && rollOverProperties.rollOverAttrs);
      setElement.data('unHoverAttr', config.pointAttr);

      visible ? setElement.show() : setElement.hide();
    } else {
      setElement && setElement.remove();
      labelElement && labelElement.remove();
      imageElement && imageElement.remove();
    }
  };

  /**
   * function to Remove data plots if the number of current data plots/categories
   * is more than the existing ones.
   * @param  {Object} datasetJSON JSON for dataset configurations
   */


  DragNodeDataset.prototype.trimData = function trimData(datasetJSON) {
    if (!this.config.JSONData) {
      return;
    }
    var dataSet = this,
        prevData = dataSet.config.JSONData,
        prevDataLength = prevData.data && prevData.data.length,
        currDataLength = datasetJSON.data && datasetJSON.data.length || 0,
        dataDiff = prevDataLength - currDataLength;

    // Removing data plots if the number of current data plots/categories
    // is more than the existing ones.
    if (dataDiff > 0) {
      dataSet.removeData(currDataLength, dataDiff);
    }
  };

  /**
   * Function to remove data during update if number of data has reduced than the previous render
   * @param {number} index The data index from which data has to be removed.
   * @param {number} stretch The index upto which data has to be removed
   */


  DragNodeDataset.prototype.removeData = function removeData(index, stretch) {
    var dataSet = this,
        components = dataSet.components,
        manager = dataSet.getLinkedParent(),
        dataStore = components.data,
        removeDataArr = components.removeDataArr || (components.removeDataArr = []);

    stretch = stretch || 1;
    index = index || 0;

    if (index < 0) {
      index = 0;
    }
    components.removeDataArr = removeDataArr = removeDataArr.concat(dataStore.splice(index, stretch));
    manager._clearConnectors();
  };

  /**
   * Function to remove graphics during update if number of data has reduced than the previous render
   * @param {Object} dataObj The object corresponding to the data whose graphics has to be removed
   */


  DragNodeDataset.prototype._removeDataVisuals = function _removeDataVisuals(dataObj) {
    var dataSet = this,
        ele,
        graphics,
        graphicsObj;
    if (!dataObj) {
      return;
    }
    graphics = dataObj.graphics;
    for (ele in graphics) {
      graphicsObj = graphics[ele];

      if (graphicsObj.hide && typeof graphicsObj.hide === 'function') {
        dataSet.getFromEnv('animationManager').setAnimation({
          el: graphicsObj,
          attr: { 'text-bound': [] },
          component: dataSet
        });
        graphicsObj.hide();
        graphicsObj.transform && graphicsObj.transform(_lib.BLANKSTRING);
      }
    }
  };

  /**
   * Get json data of dragnode dataset
   * @return {Object} jsonData
   */


  DragNodeDataset.prototype.getJSONData = function getJSONData() {
    var dataset = this,
        dataStore = dataset.components.data,
        len = dataStore.length,
        jsonData = [],
        dataObj,
        i;
    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      if (!dataObj.removed) {
        if (dataObj.config._options) {
          delete dataObj.config._options.update;
          delete dataObj.config._options.add;
          jsonData.push(dataObj.config._options);
        }
      }
    }
    return jsonData;
  };

  return DragNodeDataset;
}(_area2['default']);

exports['default'] = DragNodeDataset;

/***/ }),

/***/ 234:
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(121);
var TAG = __webpack_require__(24)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ 235:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(843);
var $export = __webpack_require__(20);
var redefine = __webpack_require__(78);
var hide = __webpack_require__(76);
var has = __webpack_require__(63);
var Iterators = __webpack_require__(112);
var $iterCreate = __webpack_require__(844);
var setToStringTag = __webpack_require__(236);
var getPrototypeOf = __webpack_require__(846);
var ITERATOR = __webpack_require__(24)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ 236:
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(60).f;
var has = __webpack_require__(63);
var TAG = __webpack_require__(24)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ 360:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(361);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _dragcolumn = __webpack_require__(232);

var _dragcolumn2 = _interopRequireDefault(_dragcolumn);

var _dragcolumn3 = __webpack_require__(777);

var _dragcolumn4 = _interopRequireDefault(_dragcolumn3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */

/**
 * API class of dragcolumn inheriting from column class
 */
var DragColumn = function (_DragBase) {
  _inherits(DragColumn, _DragBase);

  function DragColumn() {
    _classCallCheck(this, DragColumn);

    return _possibleConstructorReturn(this, _DragBase.apply(this, arguments));
  }

  /**
   * Sets the name of the component
   * @return {string} name
   */
  DragColumn.prototype.getName = function getName() {
    return 'DragColumn';
  };
  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */


  DragColumn.getName = function getName() {
    return 'DragColumn2D';
  };

  /**
   * This method return the dataset-group definations for this charts
   * @return {Object}       Multiseries Dragcolumn group definition
   */


  DragColumn.prototype.getDSGroupdef = function getDSGroupdef() {
    return _dragcolumn4['default'];
  };

  /**
   * Function to parse chart specific configurations.
   */


  DragColumn.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _DragBase.prototype.__setDefaultConfig.call(this);
    this.config.isDrag = true;
  };
  /**
   * Function to return the dataset liked with the current API
   * @return {Object} The DragColumnDataset class
   */


  DragColumn.prototype.getDSdef = function getDSdef() {
    return _dragcolumn2['default'];
  };

  return DragColumn;
}(_fusioncharts2['default']);

exports['default'] = DragColumn;

/***/ }),

/***/ 361:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _stringify = __webpack_require__(36);

var _stringify2 = _interopRequireDefault(_stringify);

var _fusioncharts = __webpack_require__(71);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _lib = __webpack_require__(5);

var _ajax = __webpack_require__(80);

var _ajax2 = _interopRequireDefault(_ajax);

var _dependencyManager = __webpack_require__(6);

var _realtime = __webpack_require__(223);

var _schedular = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var UNDEF = void 0,
    transcoders = (0, _dependencyManager.getDepsByType)('transcoder'),
    UNDERSCORE = _lib.preDefStr.UNDERSCORE,
    BLANK = _lib.BLANKSTRING,

/**
 * sanitise the format given by the user
 * @param {string} str value to be sanitised
 * @return {string} a string in lower case
 */
sanitiseFormatStr = function sanitiseFormatStr(str) {
  return str.toString().toLowerCase();
};

/**
 * API class of dragcolumn inheriting from column class
 */

var DragBase = function (_MSColumn2D) {
  _inherits(DragBase, _MSColumn2D);

  /**
   * constructor to define the ei methods
   */
  function DragBase() {
    _classCallCheck(this, DragBase);

    var _this = _possibleConstructorReturn(this, _MSColumn2D.call(this));

    _this.eiMethods.getDataWithId = function () {
      var chartInstance = this,
          dataObj = chartInstance.apiInstance && chartInstance.apiInstance.getJSONData(),
          returnObj = [[BLANK]],
          datasets = dataObj.dataset,
          catArr = dataObj.categories && dataObj.categories[0] && dataObj.categories[0].category,
          i = datasets && datasets.length || 0,
          vLinePassed = 0,
          setArr,
          catName,
          catObj,
          set,
          DS,
          item,
          dsID,
          id,
          j,
          ln;

      while (i--) {
        DS = datasets[i];
        if (DS) {
          returnObj[0][i + 1] = DS.id || DS.seriesname;
          dsID = DS.id || i + 1;
          set = DS.data;
          ln = set && set.length || 0;
          for (j = 0; j < ln; j += 1) {
            item = j + 1;
            if (!returnObj[item]) {
              catObj = catArr && catArr[j + vLinePassed] || {};
              while (catObj.vline) {
                vLinePassed += 1;
                catObj = catArr[j + vLinePassed] || {};
              }
              catName = catObj.label || catObj.name || BLANK;
              returnObj[item] = [catName];
            }
            setArr = returnObj[item];
            id = set[j].id || item + UNDERSCORE + dsID;
            setArr[i + 1] = [id, Number(set[j].value)];
          }
        }
      }

      return returnObj;
    };
    /**
     * Data of the chart in format user wants or in a 2d array
     * @param {string} [format] in which the data will be returned
     * @return {string | Object} chart data
     */
    _this.eiMethods.getData = function (format) {
      var chartInstance = this,
          jsonData = chartInstance.apiInstance && chartInstance.apiInstance.getJSONData(),
          returnData,
          datasets = jsonData.dataset,
          len = datasets && datasets.length || 0,
          i = 0,
          transcoderObjSource,
          sanitisedFormat;

      // When a format is provided
      if (format) {
        sanitisedFormat = sanitiseFormatStr(format);
        // no transcoding needed for json
        if (/^json$/ig.test(sanitisedFormat)) {
          returnData = jsonData;
        } else {
          transcoderObjSource = transcoders[sanitisedFormat]();
          returnData = transcoderObjSource.fromJSON(jsonData, chartInstance).data;
        }
      } else {
        returnData = _realtime._getData.call(chartInstance.apiInstance);
        returnData.unshift([BLANK]);
        while (i < len) {
          returnData[0][i + 1] = datasets[i++].seriesname;
        }
      }
      return returnData;
    };
    /**
     * Function to set the upper limit of the chart
     * @param {number} limit new upper limit for the chart
     * @param {Function} callback is the function which gets the return value in its paramter if
     * asyncRender is 1
     * @return {number} value of the returned function
     */
    _this.eiMethods.setUpperLimit = function (limit, callback) {
      var chartInstance = this,
          iapi = chartInstance.apiInstance,
          output,
          asyncRender = chartInstance.args.asyncRender;

      if (callback || asyncRender) {
        iapi.addJob('setUpperLimitId', function () {
          output = iapi.changeUpperLimits(limit);
          if (typeof callback === 'function') {
            callback(output);
          }
        }, _schedular.priorityList.postRender);
      } else {
        return iapi.changeUpperLimits(limit);
      }
    };
    /**
     * Function to set the lower limit of the chart
     * @param {number} limit new lower limit for the chart
     * @param {Function} callback is the function which gets the return value in its paramter if
     * asyncRender is 1
     * @return {number} value of the returned function
     */
    _this.eiMethods.setLowerLimit = function (limit, callback) {
      var chartInstance = this,
          iapi = chartInstance.apiInstance,
          output,
          asyncRender = chartInstance.args.asyncRender;

      if (callback || asyncRender) {
        iapi.addJob('setLowerLimitId', function () {
          output = iapi.changeLowerLimits(limit);
          if (typeof callback === 'function') {
            callback(output);
          }
        }, _schedular.priorityList.postRender);
      } else {
        return iapi.changeLowerLimits(limit);
      }
    };
    /**
     * Function to get the lower limit of the chart
     * @param {Function} callback is the function which gets the return value in its paramter if
     * asyncRender is 1
     * @return {number} lower limit value
     */
    _this.eiMethods.getLowerLimit = function (callback) {
      var chartInstance = this,
          iapi = chartInstance.apiInstance,
          yAxis = iapi.getChildren('yAxis')[0],
          asyncRender = chartInstance.args.asyncRender;

      if (yAxis) {
        if (asyncRender || callback) {
          iapi.addJob('getLowerLimitId', function () {
            if (typeof callback === 'function') {
              callback(yAxis.config.axisRange.min);
            }
          }, _schedular.priorityList.postRender);
        } else {
          return yAxis.config.axisRange.min;
        }
      }
    };
    /**
     * Function to get the upper limit of the chart
     * @param {Function} callback is the function which gets the return value in its paramter if
     * asyncRender is 1
     * @return {number} upper limit value
     */
    _this.eiMethods.getUpperLimit = function (callback) {
      var chartInstance = this,
          iapi = chartInstance.apiInstance,
          yAxis = iapi.getChildren('yAxis')[0],
          asyncRender = chartInstance.args.asyncRender;

      if (yAxis) {
        if (asyncRender || callback) {
          iapi.addJob('getUpperLimitId', function () {
            if (typeof callback === 'function') {
              callback(yAxis.config.axisRange.max);
            }
          }, _schedular.priorityList.postRender);
        } else {
          return yAxis.config.axisRange.max;
        }
      }
    };
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  DragBase.prototype.getName = function getName() {
    return 'DragBase';
  };

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */


  DragBase.getName = function getName() {
    return 'DragBase';
  };

  /**
   * Function which determines on which particular data of a dataset the mouse pointer is hovered
   * @param {Object} e A wrapper over the original event
   * @param  {Object} data The Data Object
   */


  DragBase.prototype._mouseEvtHandler = function _mouseEvtHandler(e, data) {
    var chart = this,
        mouseTracker = data.mouseTracker,
        oriEvent = e.originalEvent,
        chartConfig = chart.config,
        datasets = chartConfig.datasetOrder || chart.getDatasets(),
        coordinate = (0, _lib.getMouseCoordinate)(chart.getFromEnv('chart-container'), oriEvent, chart),
        chartX = coordinate.chartX,
        chartY = coordinate.chartY,
        dataset,
        hoveredInfo,
        pointFound = false,
        i = datasets.length,
        j,
        l,
        derivedEvensInfo,
        _lastDatasetIndex = mouseTracker._lastDatasetIndex,
        _lastPointIndex = mouseTracker._lastPointIndex,
        dragStart,
        eventType;

    _lastPointIndex !== UNDEF && (dragStart = datasets[_lastDatasetIndex].components.data[_lastPointIndex].config.dragStart);
    if (!dragStart) {
      // @todo we have to implement this for charts with more than one canvas like candle stick
      while (i-- && !pointFound) {
        dataset = datasets[i];
        if (dataset && dataset.getState('visible')) {
          hoveredInfo = dataset._getHoveredPlot && dataset._getHoveredPlot(chartX, chartY);
          if (hoveredInfo && hoveredInfo.hovered) {
            pointFound = true;
            hoveredInfo.datasetIndex = i;
            derivedEvensInfo = mouseTracker.getMouseEvents(e, hoveredInfo.datasetIndex, hoveredInfo.pointIndex);
          }
        }
      }
    }

    // for drag event
    if (dragStart && _lastDatasetIndex !== UNDEF) {
      eventType = e.type === _lib.MOUSEOUT ? _lib.MOUSEMOVE : e.type;
      datasets[_lastDatasetIndex] && datasets[_lastDatasetIndex]._firePlotEvent && datasets[_lastDatasetIndex]._firePlotEvent(eventType, _lastPointIndex, e);
    }
    // @todo instead of sending event names, create a event object of that type and send it
    // fire out on last hovered plot
    if (!dragStart && (!pointFound || derivedEvensInfo && derivedEvensInfo.fireOut) && _lastDatasetIndex !== UNDEF) {
      // delete stored last ds details
      delete mouseTracker._lastDatasetIndex;
      delete mouseTracker._lastPointIndex;

      datasets[_lastDatasetIndex] && datasets[_lastDatasetIndex]._firePlotEvent && datasets[_lastDatasetIndex]._firePlotEvent(_lib.MOUSEOUT, _lastPointIndex, e);
    }
    // fire remaining events
    if (pointFound) {
      l = derivedEvensInfo.events && derivedEvensInfo.events.length;
      // store the index of the hovered DS and plot
      mouseTracker._lastDatasetIndex = hoveredInfo.datasetIndex;
      _lastPointIndex = mouseTracker._lastPointIndex = hoveredInfo.pointIndex;
      for (j = 0; j < l; j += 1) {
        dataset && dataset._firePlotEvent && dataset._firePlotEvent(derivedEvensInfo.events[j], _lastPointIndex, e);
      }
    }
  };

  /**
   * Parsing the default configuration of the chart and over-writting the limitUpdaterEnabled
   */


  DragBase.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSColumn2D.prototype.__setDefaultConfig.call(this);
    this.config.limitUpdaterEnabled = true;
  };

  /**
   * Configure function calls the parent configure function and adds eventListener to needed children
   * @param {Object} dataObj contains json data of the chart
   */


  DragBase.prototype.parseChartAttr = function parseChartAttr(dataObj) {
    _MSColumn2D.prototype.parseChartAttr.call(this, dataObj);
    var chart = this,
        jsonData = chart.getFromEnv('dataSource'),
        chartAttr = jsonData.chart,
        fontSize,
        chartConfig;
    chartConfig = chart.config;
    chartConfig.formAction = (0, _lib.getValidValue)(chartAttr.formaction);

    if (chartAttr.submitdataasxml === _lib.ZEROSTRING && !chartAttr.formdataformat) {
      chartAttr.formdataformat = transcoders.csv().format;
    }

    chartConfig.formDataFormat = (0, _lib.pluck)(chartAttr.formdataformat, transcoders.xml().format);
    chartConfig.formTarget = (0, _lib.pluck)(chartAttr.formtarget, '_self');
    chartConfig.formMethod = (0, _lib.pluck)(chartAttr.formmethod, 'POST');
    chartConfig.submitFormAsAjax = (0, _lib.pluckNumber)(chartAttr.submitformusingajax, 1);
    chartConfig.restoreBtnTitle = (0, _lib.pluck)(chartAttr.restorebtntitle, 'Restore');
    chartConfig.submitBtnTitle = (0, _lib.pluck)(chartAttr.formbtntitle, 'Submit');

    // Form Button
    chartConfig.showFormBtn = (0, _lib.pluckNumber)(chartAttr.showformbtn, 1) && chartConfig.formAction;
    chartConfig.showRestoreBtn = (0, _lib.pluckNumber)(chartAttr.showrestorebtn, 1);
    chartConfig.formBtnTitle = (0, _lib.pluck)(chartAttr.formbtntitle, 'Submit');
    chartConfig.formBtnBorderColor = (0, _lib.pluck)(chartAttr.formbtnbordercolor, 'CBCBCB');
    chartConfig.formBtnBgColor = (0, _lib.pluck)(chartAttr.formbtnbgcolor, _lib.preDefStr.COLOR_FFFFFF);
    chartConfig.btnPadding = (0, _lib.pluckNumber)(chartAttr.btnpadding, 7); // 2 px more for better presentation
    chartConfig.btnSpacing = (0, _lib.pluckNumber)(chartAttr.btnspacing, 5);
    chartConfig.formBtnStyle = {
      fontSize: chartConfig.style.outCanfontSize,
      fontFamily: chartConfig.style.outCanfontFamily,
      fontWeight: 'bold'
    };
    chartConfig.formBtnLabelFill = chartConfig.style.outCancolor;
    if (chartAttr.btntextcolor) {
      chartConfig.formBtnLabelFill = chartAttr.btntextcolor.replace(_lib.dropHash, _lib.HASHSTRING);
    }
    if ((fontSize = (0, _lib.pluckNumber)(chartAttr.btnfontsize)) >= 0) {
      chartConfig.formBtnStyle.fontSize = fontSize + 'px';
    }
    chartConfig.restoreBtnWidth = (0, _lib.pluckNumber)(chartAttr.restorebtnwidth, 0);
    chartConfig.formBtnWidth = (0, _lib.pluckNumber)(chartAttr.formbtnwidth, 0);
    // Restore Button configuration
    chartConfig.restoreBtnBorderColor = (0, _lib.pluck)(chartAttr.restorebtnbordercolor, chartConfig.formBtnBorderColor);
    chartConfig.restoreBtnBgColor = (0, _lib.pluck)(chartAttr.restorebtnbgcolor, chartConfig.formBtnBgColor);
    chartConfig.restoreBtnStyle = {
      fontSize: chartConfig.formBtnStyle.fontSize,
      fontFamily: chartConfig.formBtnStyle.fontFamily,
      fontWeight: 'bold'
    };
    chartConfig.restoreBtnLabelFill = chartConfig.formBtnLabelFill;
    if (chartAttr.toolbary || chartAttr.toolbarx) {
      chartConfig.spaceHardCoded = true;
    } else {
      delete chartConfig.spaceHardCoded;
    }
    chartConfig.drawTrendRegion = (0, _lib.pluckNumber)(chartAttr.drawcrossline, 0);
  };

  /**
   * Function to store the initial axis value
   */


  DragBase.prototype._storeIntialLimit = function _storeIntialLimit() {
    var chart = this,
        yAxis = chart.getChildren('yAxis')[0];
    chart.config.axisInitialLimit = yAxis.getLimit();
  };

  /**
   * Over-writing mscartesian createToolBox function
   */


  DragBase.prototype._createToolBox = function _createToolBox() {
    _MSColumn2D.prototype._createToolBox.call(this);
    this.addConfigureOptions();
  };

  /**
   * Function for adding menu otions to be shown in the drop-down menu
   */


  DragBase.prototype.addConfigureOptions = function addConfigureOptions() {
    var chart = this,
        sListRef = chart.getFromEnv('chartMenuList'),
        chartAttr = chart.getFromEnv('chart-attrib'),
        allowAxisChange = (0, _lib.pluckNumber)(chartAttr.allowaxischange, 1),
        chartConf = chart.config,
        restore,
        submit,
        submitBtnTitle = chartConf.submitBtnTitle,
        restoreBtnTitle = chartConf.restoreBtnTitle,
        configureTools = [{
      'Increase Upper Limit': {
        handler: function handler() {
          var yAxis = chart.getChildren('yAxis')[0],
              axisRange = yAxis.getLimit(),
              max = axisRange.max,
              tickInterval = axisRange.tickInterval;
          chart.changeUpperLimits(max + tickInterval);
        },
        action: 'click'
      }
    }, {
      'Increase Lower Limit': {
        handler: function handler() {
          var yAxis = chart.getChildren('yAxis')[0],
              axisRange = yAxis.getLimit(),
              min = axisRange.min,
              tickInterval = axisRange.tickInterval;
          chart.changeLowerLimits(min + tickInterval);
        },
        action: 'click'
      }
    }, {
      'Decrease Upper Limit': {
        handler: function handler() {
          var yAxis = chart.getChildren('yAxis')[0],
              axisRange = yAxis.getLimit(),
              max = axisRange.max,
              tickInterval = axisRange.tickInterval;
          chart.changeUpperLimits(max - tickInterval);
        },
        action: 'click'
      }
    }, {
      'Decrease Lower Limit': {
        handler: function handler() {
          var yAxis = chart.getChildren('yAxis')[0],
              axisRange = yAxis.getLimit(),
              min = axisRange.min,
              tickInterval = axisRange.tickInterval;
          chart.changeLowerLimits(min - tickInterval);
        },
        action: 'click'
      }
    }];

    if (chartConf.formAction) {
      submit = {};
      submit[submitBtnTitle] = {
        handler: function handler() {
          chart.submitData();
        },
        action: 'click'
      };
      configureTools.push(submit);
    }

    if (chartConf.showRestoreBtn) {
      restore = {};
      restore[restoreBtnTitle] = {
        handler: function handler() {
          chart.restoreData();
        },
        action: 'click'
      };
      configureTools.push(restore);
    }

    if (allowAxisChange) {
      sListRef.appendAsList(configureTools);
    }
  };

  /**
   * Function to restore all the data to the original json Data
   */


  DragBase.prototype.restoreData = function restoreData() {
    var chart = this,
        yAxis = chart.getChildren('yAxis')[0],
        axisInitialLimit = chart.config.axisInitialLimit;

    chart.iterateComponents(function (child) {
      var data = void 0;
      if (data = child.getChildren('dataset')) {
        data.forEach(function (dataset) {
          dataset.restore();
        });
      }
    });
    yAxis.setAxisConfig({
      axisMaxValue: axisInitialLimit.max,
      axisMinValue: axisInitialLimit.min
    });
    yAxis.setDataLimit(axisInitialLimit.max, axisInitialLimit.min);
    chart.fireChartInstanceEvent('dataRestored', {});
  };

  /**
   * Function to change the lowerLimit of the axis using the drop down menu item
   * @param {number} lowerLimit The limit to which lower limit of the axis has to be extended
   * @return {boolean} if axis limit is changed
   */


  DragBase.prototype.changeLowerLimits = function changeLowerLimits(lowerLimit) {
    var chart = this,
        yAxis = chart.getChildren('yAxis')[0],
        axisRange = yAxis.getLimit(),
        min = axisRange.min,
        yMin = axisRange.min,
        config = chart.config,
        minValue = config.yMin,
        limitchanged = false,
        max = axisRange.max;
    chart.getFromEnv('animationManager').setAnimationState('update');
    if (lowerLimit !== UNDEF && lowerLimit < minValue && lowerLimit !== yMin) {
      min = lowerLimit;
      limitchanged = true;
    } else {
      lowerLimit = minValue < yMin ? minValue : yMin;
    }

    if (limitchanged) {
      yAxis.setAxisConfig({
        axisMaxValue: max,
        axisMinValue: lowerLimit
      });
      yAxis.setDataLimit(max, min);
    }
    return limitchanged;
  };

  /**
   * Function to change the upperLimit of the axis using the drop down menu item
   * @param {number} upperLimit The limit to which upper limit of the axis has to be extended
   * @return {boolean} if axis limit is changed
   */


  DragBase.prototype.changeUpperLimits = function changeUpperLimits(upperLimit) {
    var chart = this,

    // components = chart.components,
    yAxis = chart.getChildren('yAxis')[0],
        axisRange = yAxis.getLimit(),
        min = axisRange.min,
        yAxisMax = axisRange.max,
        config = chart.config,
        maxValue = config.yMax,
        limitchanged = false,
        max;

    chart.getFromEnv('animationManager').setAnimationState('update');

    if (upperLimit !== UNDEF && upperLimit > maxValue && upperLimit !== yAxisMax) {
      max = upperLimit;
      limitchanged = true;
    } else {
      max = maxValue > yAxisMax ? maxValue : yAxisMax;
    }

    if (limitchanged) {
      yAxis.setAxisConfig({
        axisMaxValue: max,
        axisMinValue: min,
        showUpperLimit: true
      });
      yAxis.setDataLimit(max, min);
    }
    return limitchanged;
  };

  /**
   * Call back function when submit button is pressed.
   */


  DragBase.prototype.submitData = function submitData() {
    var chart = this,

    // iapi = chart.apiInstance,
    ajaxObj = new _ajax2['default'](),
        chartConf = chart.config,
        json = transcoders.json(),
        csv = transcoders.csv && transcoders.csv() || 'csv',
        xml = transcoders.xml(),
        url = chartConf.formAction,
        chartInstance = chart.getFromEnv('chartInstance'),
        submitAsAjax = chartConf.submitFormAsAjax,
        requestType,
        data,
        paramObj,
        tempSpan,
        formEle;

    if (chartConf.formDataFormat === json.format) {
      requestType = json.format;
      data = (0, _stringify2['default'])(chart.getJSONData());
    } else if (chartConf.formDataFormat === csv.format) {
      requestType = csv.format;
      data = chart.getCSVString && chart.getCSVString();
      if (data === UNDEF) {
        data = csv.fromJSON(chart.getJSONData()).data;
      }
    } else {
      requestType = xml.format;
      data = xml.fromJSON(chart.getJSONData()).data;
    }

    // cancel data submit function added in event options
    /**
     * For interative charts like `Select Scatter`, `DragNode`, `Dragable Column2D ` and etc., data
     * points value can be selected for `Scatter Chart` and values can be changed for dragable charts by
     * clicking and dragging the data points whose data point values can be sent to an URL by ajax POST.
     * This is the first event raised when `Submit` button is clicked where the current chart data is
     * about to be sent to the set URL.
     *
     * @event FusionCharts#beforeDataSubmit
     * @group chart-powercharts
     *
     * @param {string} data - Contains the XML string with complete chart data at it's current state.
     *
     */
    chart.fireChartInstanceEvent('beforeDataSubmit', {
      data: data
    }, UNDEF, function () {
      // After the collation is done, we have to submit the data using
      // ajax or form submit method.
      if (!submitAsAjax) {
        // Create a hidden form with data inside it.
        tempSpan = window.document.createElement('span');
        tempSpan.innerHTML = '<form style="display:none" action="' + url + '" method="' + chartConf.formMethod + '" target="' + chartConf.formTarget + '"> <input type="hidden" name="strXML" value="' + (0, _lib.xssEncode)(data) + '"><input type="hidden" name="dataFormat" value="' + requestType.toUpperCase() + '" /></form>';

        formEle = tempSpan.removeChild(tempSpan.firstChild);

        // Append the form to body and then submit it.
        window.document.body.appendChild(formEle);
        formEle.submit && formEle.submit();
        // cleanup
        formEle.parentNode.removeChild(formEle);
        tempSpan = formEle = null;
      } else {
        // eslint-disable-next-line
        ajaxObj.onError = function (response, wrapper, ajaxData, url) {
          /**
           * For interative charts like `Select Scatter`, `DragNode`, `Dragable Column2D ` and etc.,
           * data points value can be selected for `Scatter Chart` and values can be changed for
           * dragable charts by clicking and dragging the data points whose data point values can be
           * sent to an URL by ajax POST. This event is raised if there is an ajax error in sending
           * the chart XML data.
           *
           * @event FusionCharts#dataSubmitError
           * @group chart-powercharts
           *
           * @param {string} data - Contains the XML string with complete chart data.
           * @param {number} httpStatus - Tells the status code of the ajax POST request
           * @param {string} statusText - Contains the ajax error message.
           * @param {string} url - URL to which the data is sent as ajax POST request.
           * @param {object} xhrObject - XMLHttpRequest object which takes care of sending the XML
           * chart data. In case of error, this object won't be defined.
           */
          chart.fireChartInstanceEvent('dataSubmitError', {
            xhrObject: wrapper.xhr,
            url: url,
            statusText: response,
            httpStatus: wrapper.xhr && wrapper.xhr.status ? wrapper.xhr.status : -1,
            data: data
          }, [chartInstance.id, response, wrapper.xhr && wrapper.xhr.status]);
        };
        // eslint-disable-next-line
        ajaxObj.onSuccess = function (response, wrapper, ajaxData, url) {
          /**
           * For interative charts like `Select Scatter`, `DragNode`, `Dragable Column2D ` and etc.,
           * data points value can be selected for `Scatter Chart` and values can be changed for
           * dragable charts by clicking and dragging the data points whose data point values can be
           * sent to an URL by ajax POST. This event is raised when the ajax POST request is
           * successfully completed.
           *
           * @event FusionCharts#dataSubmitted
           * @group chart-powercharts
           *
           * @param {string} data - Contains the XML string with complete chart data.
           * @param {string} reponse - Contains the reponse returned by the web server to which the
           * HTTP POST request was submitted.
           * @param {string} url - URL to which the data is sent as HTTP POST request.
           * @param {object} xhrObject - XMLHttpRequest object which takes care of sending the XML
           * chart data
           */
          chart.fireChartInstanceEvent('dataSubmitted', {
            xhrObject: ajaxObj,
            response: response,
            url: url,
            data: data
          }, [chartInstance.id, response]);
        };

        paramObj = {};
        paramObj['str' + requestType.toUpperCase()] = data;

        if (ajaxObj.open) {
          ajaxObj.abort();
        }
        ajaxObj.post(url, paramObj);
      }
    }, function () {
      /**
       * For interative charts like `Select Scatter`, `DragNode`, `Dragable Column2D ` and etc.,
       * data points value can be selected for `Scatter Chart` and values can be changed for
       * dragable charts by clicking and dragging the data points whose data point values can be
       * sent to an URL by ajax POST. This event is raised when `preventDefault()` method is called
       * from the `eventObject` of FusionCharts#beforeDataSubmit event.
       *
       * @event FusionCharts#dataSubmitCancelled
       * @group chart-powercharts
       *
       * @param {string} data - Contains the XML string with complete chart data.
       * @param {number} httpStatus - Tells the status code of the ajax POST request
       * @param {string} statusText - Contains the ajax error message.
       * @param {string} url - URL to which the data is sent as ajax POST request.
       * @param {object} xhrObject - XMLHttpRequest object which takes care of sending the XML
       * chart data. In case of error, this object won't be defined.
       * @example
       * FusionCharts.addEventListener('beforeDataSubmit', function(eventObject, parameterObject) {
       *  eventObject.preventDefault();
       * }
       */
      chart.fireChartInstanceEvent('dataSubmitCancelled', {
        data: data
      });
    });
  };

  /**
   * Function to get the jsonData
   * @return {Object} the jsonData
   */


  DragBase.prototype.getJSONData = function getJSONData() {
    var chart = this,
        canvas = chart.getChildren('canvas')[0],
        vCanvas = canvas.getChildren('vCanvas')[0],
        rawObj = chart.getFromEnv('dataSource'),
        groupManager,
        datasetsArr = [],
        jsonObj;

    vCanvas.iterateComponents(function (component) {
      if (component.getType() === 'group') {
        groupManager = component;
      }
    });

    datasetsArr = groupManager.getJSONData && groupManager.getJSONData();

    jsonObj = (0, _lib.extend2)({}, rawObj);
    jsonObj.dataset = datasetsArr;
    return jsonObj;
  };

  return DragBase;
}(_fusioncharts2['default']);

exports['default'] = DragBase;

/***/ }),

/***/ 362:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(360);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _dragarea = __webpack_require__(363);

var _dragarea2 = _interopRequireDefault(_dragarea);

var _lib = __webpack_require__(5);

var _fusioncharts3 = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */

/**
 * API class of dragcolumn inheriting from area class
 */
var DragArea = function (_DragColumn) {
  _inherits(DragArea, _DragColumn);

  function DragArea() {
    _classCallCheck(this, DragArea);

    return _possibleConstructorReturn(this, _DragColumn.apply(this, arguments));
  }

  /**
   * Sets the name of the component
   * @return {string} name
   */
  DragArea.prototype.getName = function getName() {
    return 'DragArea';
  };
  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */


  DragArea.getName = function getName() {
    return 'DragArea';
  };

  // eslint-disable-next-line


  DragArea.prototype.getDSGroupdef = function getDSGroupdef() {};
  /**
   * Function to parse chart specific configurations. It first calls the __setDefaultConfig of areabase class.
   */


  DragArea.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _DragColumn.prototype.__setDefaultConfig && _DragColumn.prototype.__setDefaultConfig.call(this);
    var chart = this,
        config = chart.config;
    _fusioncharts3._setDefaultConfig.call(chart);
    config.isDrag = true;
    config.anchoralpha = _lib.HUNDREDSTRING;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
  };
  /**
   * Function to return the dataset liked with the current API
   * @return {Object} The DragAreaDataset class
   */


  DragArea.prototype.getDSdef = function getDSdef() {
    return _dragarea2['default'];
  };

  return DragArea;
}(_fusioncharts2['default']);

exports['default'] = DragArea;

/***/ }),

/***/ 363:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._updateImage = exports.configurer = exports.__firePlotEvent = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _area = __webpack_require__(23);

var _area2 = _interopRequireDefault(_area);

var _lib = __webpack_require__(5);

var _dragcolumn = __webpack_require__(232);

var _dragAreaAnimation = __webpack_require__(778);

var _dragAreaAnimation2 = _interopRequireDefault(_dragAreaAnimation);

var _dependencyManager = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */

var SETROLLOVERATTR = 'setRolloverAttr',
    SETROLLOUTATTR = 'setRolloutAttr',
    ROLLOUT = 'DataPlotRollOut',
    ROLLOVER = 'DataPlotRollOver',
    DRAGLINE = 'dragLine',
    DATAPLOTCLICK = 'dataplotclick',
    BLANKSTRING = '',
    mathMin = Math.min,
    mathMax = Math.max,
    isVML = false,
    _updateImage = void 0,
    _configure = void 0,
    __firePlotEvent = void 0,
    UNDEF = void 0;

(0, _dependencyManager.addDep)({
  name: 'dragAreaAnimation',
  type: 'animationRule',
  extension: _dragAreaAnimation2['default']
});
/**
 * dataset class of dragcolumn inheriting from column class
 */

var DragAreaDataset = function (_AreaDataset) {
  _inherits(DragAreaDataset, _AreaDataset);

  function DragAreaDataset() {
    _classCallCheck(this, DragAreaDataset);

    return _possibleConstructorReturn(this, _AreaDataset.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  DragAreaDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  DragAreaDataset.prototype.getName = function getName() {
    return 'dragArea';
  };
  /**
  * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
  * This function is called once from the init() function of the Column class.
  * @param  {Object} datasetJSON JSON for dataset configurations
  */


  DragAreaDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    var dataset = this,
        conf = dataset.config,
        chartAttr = dataset.getFromEnv('chart-attrib'),
        JSONData = conf.JSONData;

    conf.allowDrag = (0, _lib.pluckNumber)(JSONData.allowdrag, 1);
    conf.allowNegDrag = (0, _lib.pluckNumber)(JSONData.allownegativedrag, 1);
    conf.allowAxisChange = (0, _lib.pluckNumber)(chartAttr.allowaxischange, 1);
    conf.snapToDivOnly = (0, _lib.pluckNumber)(chartAttr.snaptodivonly, 0);
    conf.doNotSnap = (0, _lib.pluckNumber)(chartAttr.donotsnap, 0);
    conf.snapToDiv = (0, _lib.pluckNumber)(chartAttr.snaptodiv, 1);
    conf.snapToDivRelaxation = (0, _lib.pluckNumber)(chartAttr.snaptodivrelaxation, 10);
    if (conf.doNotSnap) {
      conf.snapToDiv = conf.snapToDivOnly = 0;
    }
    _AreaDataset.prototype.configureAttributes.call(this, datasetJSON);
  };
  /**
   * method to configure a particular data plot object
   * @param {number} i index of the data object to be configured
   * @param {Object} setData particular plot information in of i'th index in input json
   */


  DragAreaDataset.prototype._plotConfigure = function _plotConfigure(i, setData) {
    var conf = this.config,
        dataStore = this.components.data,
        dataObj = void 0,
        config = void 0;
    _AreaDataset.prototype._plotConfigure.call(this, i, setData);
    dataObj = dataStore[i];
    config = dataObj.config;
    config.allowDrag = (0, _lib.pluckNumber)(setData.allowdrag, conf.allowDrag);
    config.allowNegDrag = (0, _lib.pluckNumber)(setData.allownegativedrag, conf.allowNegDrag);
  };

  /**
   * Function to update image while dragging.
   * @param {Object} dataObj The object by which the dataset is to be updated.
   */


  DragAreaDataset.prototype.updateImage = function updateImage(dataObj) {
    var dataset = this,
        graphics = dataObj.graphics,
        image = graphics.image || graphics.element,
        config = dataObj.config,
        anchorProps = config.anchorProps,
        hoverEffects = config.hoverEffects,
        imgRef = image && image.data('imgRef'),
        getPathString = function getPathString(data) {
      var PathArrLength = data.length,
          pathString = BLANKSTRING,
          ittr;
      for (ittr = 0; ittr < PathArrLength; ittr += 1) {
        pathString += ' ' + data[ittr];
      }
      return pathString;
    },
        scale = anchorProps.imageScale,
        paper = dataset.getFromEnv('paper'),
        imgH = imgRef.height * scale * 0.01,
        imgW = imgRef.width * scale * 0.01,
        x = dataObj._xPos,
        y = dataObj._yPos,
        hoverScale = hoverEffects.imageHoverScale,
        hotW = imgRef.width * hoverScale * 0.01,
        hotH = imgRef.height * hoverScale * 0.01,
        isAnchorRadius = anchorProps.isAnchorRadius,
        markerRadius = anchorProps.radius = isAnchorRadius ? anchorProps.radius : mathMin(imgW, imgH) / 2,
        imagePadding = anchorProps.imagePadding,
        rolloutClipRadius = markerRadius - imagePadding - anchorProps.borderThickness * 0.5,
        rolloverClipRadius = hoverEffects.radius - imagePadding - hoverEffects.anchorBorderThickness * 0.5,
        symbol = anchorProps.symbol[1],
        imageRollOverPath,
        setRolloverAttr,
        tempPath = paper.polypath(symbol || 2, x, y, rolloutClipRadius > 0 ? rolloutClipRadius : 0, anchorProps.startAngle, 0).attr({ visibility: _lib.hiddenStr }),
        imageRolloutPath = getPathString(tempPath.attrs.path),
        setRolloutAttr = {
      x: x - imgRef.width * scale * 0.005,
      y: y - imgRef.height * scale * 0.005,
      width: imgW,
      height: imgH,
      alpha: 100
    };

    if (!isVML) {
      setRolloutAttr['clip-path'] = imageRolloutPath;
    }
    tempPath.remove();

    tempPath = paper.polypath(symbol || 2, x, y, rolloverClipRadius > 0 ? rolloverClipRadius : 0, hoverEffects.startAngle, hoverEffects.dip);

    imageRollOverPath = getPathString(tempPath.attrs.path);

    tempPath.remove();
    setRolloverAttr = {
      x: x - imgRef.width * hoverScale * 0.005,
      y: y - imgRef.height * hoverScale * 0.005,
      width: hotW,
      height: hotH,
      alpha: 100
    };

    if (!isVML) {
      setRolloverAttr['clip-path'] = imageRollOverPath;
    }
    image.attr(setRolloutAttr);
    image.data(SETROLLOVERATTR, setRolloverAttr);
    image.data(SETROLLOUTATTR, setRolloutAttr);
  };
  /**
   * This method handles all mouse events of an dataset.
   * @param {string} eventType name of the event
   * @param {number} plotIndex index of the plot where this event has been occured
   * @param {Event} e reference of the original mouse event
   */


  DragAreaDataset.prototype._firePlotEvent = function _firePlotEvent(eventType, plotIndex, e) {
    var dataset = this,
        dataSetConf = dataset.config,
        chartAttr = dataset.getFromEnv('chart-attrib'),
        chart = dataset.getFromEnv('chart'),
        chartConfig = dataset.getFromEnv('chartConfig'),
        drawTrendRegion = chartConfig.drawTrendRegion,
        JSONData = dataSetConf.JSONData,
        dragmoveHandler,
        dragendHandler,
        dragStart,
        dragEnd,
        doc = document,

    // chartComp = chart.components,
    paper = dataset.getFromEnv('paper'),
        toolTipController = dataset.getFromEnv('toolTipController'),
        canvas = paper.canvas,
        style = canvas.style,
        NumberFormatter = dataset.getFromEnv('number-formatter'),
        datasetComp = dataset.components,
        plotItem = datasetComp.data[plotIndex],
        dataArr,
        currentToolTip = dataSetConf.currentToolTip,
        datasetIndex = dataSetConf.index,
        originalEvent = e.originalEvent,
        dragMouseAttr = _lib.hasSVG && 'ns-resize' || 'n-resize',
        pointerMouseAttr = 'default',
        tolerance,
        coordinate,
        chartY,
        chartX,
        yPos,
        xPos,
        pathArr,
        startIndex,
        endIndex,
        element,
        hoverEnabled,
        setTooltext,
        toolText,
        eventArgs,
        eventArgsArr,
        config,
        formattedVal,
        changedTouch,
        value,
        yAxis = dataset.getFromEnv('yAxis'),
        yBasePos = yAxis.yBasePos,
        macroIndices = [1, 2, 3, 4, 5, 6, 7],
        yaxisName = chartConfig.yaxisname,
        xaxisName = chartConfig.xaxisname,
        parserConfig = {
      xaxisName: xaxisName,
      yaxisName: yaxisName
    },
        canvasTop = chartConfig.canvasTop,
        canvasBottom = chartConfig.canvasBottom,
        allowDrag,
        allowNegDrag,
        datasetGraphics = dataset.getGraphicalElement(),
        mainLineElement = datasetGraphics.lineElement,
        anchorProps,
        anchorImageUrl,
        anchorElement,
        image,
        lowerDragBoundary = allowNegDrag ? canvasBottom : yBasePos,
        anchorStartAngle,

    // rolloverData,
    rolloverdata,
        rolloutdata,
        isHoverEnabled,
        isDragLine = dataset.getName() === DRAGLINE;

    if (eventType === 'touchend') {
      changedTouch = originalEvent.changedTouches[0];
      originalEvent.pageX = changedTouch && changedTouch.pageX;
      originalEvent.pageY = changedTouch && changedTouch.pageY;
    }
    coordinate = (0, _lib.getMouseCoordinate)(chart.getFromEnv('chart-container'), originalEvent);
    chartY = coordinate.chartY;
    chartX = coordinate.chartX;

    if (plotItem) {
      element = plotItem.graphics.element;
      config = plotItem.config;
      anchorProps = config.anchorProps;
      anchorImageUrl = anchorProps.imageUrl;
      image = plotItem.graphics.image;
      anchorElement = element;
      isHoverEnabled = config.hoverEffects && config.hoverEffects.enabled;
      anchorStartAngle = anchorProps.startAngle || 90;
      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(JSONData.data[plotIndex].tooltext, JSONData.plottooltext, chartAttr.plottooltext)));
      toolText = config.finalTooltext;
      hoverEnabled = config.hoverEffects.enabled;
      eventArgs = config.eventArgs;
      yPos = plotItem._yPos;
      xPos = plotItem._xPos;
      allowDrag = config.allowDrag;
      allowNegDrag = config.allowNegDrag;
      lowerDragBoundary = allowNegDrag ? canvasBottom : yBasePos;
      // radius = anchorProps.radius;
      config.dragTolerance = config.dragTolerance < anchorProps.markerRadius ? anchorProps.markerRadius + 0.5 : config.dragTolerance;
      tolerance = mathMax(config.dragTolerance, config.hoverEffects.anchorRadius || 0) + 1;

      switch (eventType) {
        case 'mouseover':
          dataSetConf.mouseIn = true;
          if (config.allowDrag) {
            style.cursor = dragMouseAttr;
          }
          if (!config.dragStart && toolText && !config.dragStart && !drawTrendRegion) {
            if (currentToolTip) {
              toolTipController.draw(originalEvent, toolText, currentToolTip);
            } else {
              currentToolTip = dataSetConf.currentToolTip = toolTipController.draw(originalEvent, toolText);
            }
          }
          if (!config.dragStart) {
            hoverEnabled && dataset._hoverPlotAnchor(plotItem, ROLLOVER);
            element && _lib.plotEventHandler.call(element, chart, e, ROLLOVER, eventArgs);
          }
          break;

        case 'mouseout':
          dataSetConf.mouseIn = false;
          style.cursor = pointerMouseAttr;

          hoverEnabled && dataset._hoverPlotAnchor(plotItem, ROLLOUT);
          element && _lib.plotEventHandler.call(element, chart, e, ROLLOUT, eventArgs);
          toolTipController.hide(dataSetConf.currentToolTip);
          break;

        case 'touchmove':
        case 'mousemove':
          if (!config.dragStart && toolText && chartY >= yPos - tolerance && chartY <= yPos + tolerance && chartX <= xPos + tolerance && chartX >= xPos - tolerance) {
            config.allowDrag && (style.cursor = dragMouseAttr);
            if (currentToolTip) {
              toolTipController.draw(originalEvent, toolText, currentToolTip);
            } else {
              currentToolTip = dataSetConf.currentToolTip = toolTipController.draw(originalEvent, toolText);
            }
          } else {
            toolTipController.hide(dataSetConf.currentToolTip);
          }

          break;

        case 'click':
          element && _lib.plotEventHandler.call(element, chart, e, DATAPLOTCLICK, eventArgs);
          break;

        case 'touchend':
        case 'mouseup':
          dataSetConf.mousedown = false;
          if (setTooltext !== UNDEF) {
            parserConfig.formattedValue = config.toolTipValue;
            parserConfig.label = config.label;
            toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, { value: config.setValue }, UNDEF, JSONData);
            config.setTooltext = toolText;
            setTooltext = toolText;
            config.toolText = toolText;
          }
          toolText = config.finalTooltext = config.toolText !== false ? setTooltext || config.toolText.substring(0, config.toolText.indexOf(config.formatedVal)) + config.toolTipValue : '';

          if (!(chartY >= yPos - tolerance && chartY <= yPos + tolerance && chartX <= xPos + tolerance && chartX >= xPos - tolerance)) {
            style.cursor = pointerMouseAttr;
          }
          if (dataSetConf.mouseIn && !config.dragStart) {
            if (currentToolTip) {
              toolTipController.draw(originalEvent, toolText, currentToolTip);
            } else {
              currentToolTip = dataSetConf.currentToolTip = toolTipController.draw(originalEvent, toolText);
            }
          }
          config._dragBuffer = 0;
          config._pointerDy = 0;
          config.dragStart = false;
          break;

        case 'touchstart':
        case 'mousedown':
          // drag move handler that will be listened on every mousemove/touchmove on the document when
          // in dragging state
          dragmoveHandler = function dragmoveHandler(oriEvent, mainLineElement) {
            chartY = (0, _lib.getMouseCoordinate)(dataset.getFromEnv('chart-container'), oriEvent).chartY;
            originalEvent.preventDefault ? originalEvent.preventDefault() : originalEvent.returnValue = false;
            config.allowDrag && (style.cursor = dragMouseAttr);
            config._pointerDy++;
            chartY += config._dragBuffer;
            if (chartY < canvasTop) {
              chartY = canvasTop;
            } else if (chartY > lowerDragBoundary) {
              chartY = lowerDragBoundary;
            }
            plotItem._yPos = yPos = chartY;
            config._y = value = config.setValue = (0, _lib.mathRound)(yAxis.getValue(yPos));
            config._Py = yAxis.getPixel(config._y);
            formattedVal = NumberFormatter.dataLabels(value);
            config.toolTipValue = formattedVal;
            config.displayValue = formattedVal;

            dataset.drawLabel(plotIndex, plotIndex + 1);
            plotItem.graphics.element = element;

            if (isVML && anchorImageUrl) {
              image = anchorElement;
            } else {
              if (isHoverEnabled && (rolloverdata = anchorElement.data(SETROLLOVERATTR))) {
                rolloverdata.polypath[2] = plotItem._yPos;
              }
              if (isHoverEnabled && (rolloutdata = anchorElement.data(SETROLLOUTATTR))) {
                rolloutdata.polypath[2] = plotItem._yPos;
              }

              anchorElement && anchorElement.attr(rolloutdata || {
                polypath: [anchorProps.symbol[1] || 2, xPos, plotItem._yPos, anchorProps.radius, anchorStartAngle, 0]
              });
            }

            if (image) {
              dataset.updateImage(plotItem);
            }

            dataArr = datasetComp.data;
            if (isDragLine) {
              dataset.drawCommonElements();
            }

            if (mainLineElement) {
              dataSetConf = dataset.config;
              startIndex = config.pathStartIndex;
              endIndex = config.pathEndIndex;
              pathArr = config.lastPath;
              pathArr = dataset.getLinePath(dataArr, {}, {
                begin: startIndex,
                end: endIndex
              });
              mainLineElement.attr({
                path: pathArr.getPathArr()
              });
            }

            if (config._pointerDy === 1) {
              eventArgs = {
                dataIndex: plotIndex,
                datasetIndex: datasetIndex,
                startValue: plotItem.startValue,
                endValue: config.setValue,
                datasetName: plotItem.name
              };
              chart.fireChartInstanceEvent('dataplotDragStart', eventArgs);
            }
          };
          // drag end handler that will be listened on every mouseup/touchend on the document when
          // in dragging state
          dragendHandler = function dragendHandler(oriEvent) {
            chartY = (0, _lib.getMouseCoordinate)(dataset.getFromEnv('chart-container'), oriEvent).chartY;
            eventArgs = {
              dataIndex: plotIndex,
              datasetIndex: datasetIndex,
              startValue: plotItem.startValue,
              endValue: config.setValue,
              datasetName: plotItem.name
            };
            eventArgsArr = [chart.getFromEnv('chartInstance').id, eventArgs.dataIndex, eventArgs.datasetIndex, eventArgs.datasetName, eventArgs.startValue, eventArgs.endValue];
            /**
            * The four dragable charts: `dragnode`, `dragcolumn2d`, `dragline` and `dragarea`
            * fires this event when their data plots are stopped being dragged.
            *
            * @event FusionCharts#dataplotDragEnd
            * @group chart-powercharts:drag
            */
            element && _dragcolumn.updateDataValue.call(element, e, chart); // Update dataValue
            if (config._pointerDy) {
              hoverEnabled && dataset._hoverPlotAnchor(plotItem, ROLLOUT);
              chart.fireChartInstanceEvent('dataplotDragEnd', eventArgs);
              // Fire the ChartUpdated event
              chart.fireChartInstanceEvent('chartupdated', eventArgs, eventArgsArr);
            }
            // unlisten the drag events assigned on document
            if (doc.removeEventListener) {
              doc.removeEventListener('mousemove', dragStart);
              doc.removeEventListener('mouseup', dragEnd);
              doc.removeEventListener('touchmove', dragStart);
              doc.removeEventListener('touchend', dragEnd);
            } else {
              // For IE
              doc.detachEvent('onmousemove', dragStart);
              doc.detachEvent('onmouseup', dragEnd);
              doc.detachEvent('ontouchmove', dragStart);
              doc.detachEvent('ontouchend', dragEnd);
            }
          };
          dataSetConf.mousedown = true;
          if (allowDrag && chartY >= yPos - tolerance && chartY <= yPos + tolerance && chartX <= xPos + tolerance && chartX >= xPos - tolerance) {
            config.dragStart = true;
            config._pointerDy = 0;
            config._dragStartY = chartY;
            config._dragBuffer = yPos - chartY;

            plotItem.dragged = true;

            plotItem.startValue = config.setValue;
            plotItem.name = dataSetConf.seriesname;
            plotItem.datasetIndex = dataSetConf.index;
            eventArgs = {
              dataIndex: plotIndex + 1,
              datasetIndex: plotItem.datasetIndex,
              startValue: plotItem.startValue,
              datasetName: plotItem.name
            };
            dragStart = function dragStart(originalEvent) {
              dragmoveHandler(originalEvent, mainLineElement);
            };
            dragEnd = function dragEnd(originalEvent) {
              dragendHandler(originalEvent);
            };
            // assign mousemove and mouseup on document when dragging starts.
            if (doc.addEventListener) {
              doc.addEventListener('mousemove', dragStart);
              doc.addEventListener('touchmove', dragStart);
              doc.addEventListener('mouseup', dragEnd);
              doc.addEventListener('touchend', dragEnd);
            } else {
              // For IE
              doc.attachEvent('onmousemove', dragStart);
              doc.attachEvent('ontouchmove', dragStart);
              doc.attachEvent('onmouseup', dragEnd);
              doc.attachEvent('ontouchend', dragEnd);
            }
          } else {
            config.dragStart = false;
          }
      }
    }
  };

  /**
   * Fucntion to get the updated values of data when they are dragged.
   * @return {Object} The corresponding data Array of the dataset containing the values of all the sets.
   */
  // getJSONData () {
  //   return _getJSONData.call(this);
  // }

  /**
   * Function to restore the values of the dataset to its original
   */


  DragAreaDataset.prototype.restore = function restore() {
    _dragcolumn._restore.call(this);
  };

  /**
   * Fucntion to get the updated values of data when they are dragged.
   * @return {Object} The corresponding data Array of the dataset containing the values of all the sets.
   */


  DragAreaDataset.prototype.getJSONData = function getJSONData() {
    return _dragcolumn._getJSONData.call(this);
  };

  return DragAreaDataset;
}(_area2['default']);

exports._updateImage = _updateImage = DragAreaDataset.prototype.updateImage;
exports.__firePlotEvent = __firePlotEvent = DragAreaDataset.prototype._firePlotEvent;
exports.configurer = _configure = DragAreaDataset.prototype.configureAttributes;

exports.__firePlotEvent = __firePlotEvent;
exports.configurer = _configure;
exports._updateImage = _updateImage;
exports['default'] = DragAreaDataset;

/***/ }),

/***/ 364:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.configurer = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(361);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _dragnode = __webpack_require__(233);

var _dragnode2 = _interopRequireDefault(_dragnode);

var _connector = __webpack_require__(783);

var _connector2 = _interopRequireDefault(_connector);

var _dragablelabels = __webpack_require__(365);

var _dragablelabels2 = _interopRequireDefault(_dragablelabels);

var _dragnode3 = __webpack_require__(786);

var _dragnode4 = _interopRequireDefault(_dragnode3);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _dragnodeDataset = __webpack_require__(787);

var _dragnodeDataset2 = _interopRequireDefault(_dragnodeDataset);

var _xyAxis = __webpack_require__(339);

var _xyAxis2 = _interopRequireDefault(_xyAxis);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var configurer = void 0;
/**
 * API class of dragcolumn inheriting from column class
 */

var DragNode = function (_DragBase) {
  _inherits(DragNode, _DragBase);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  DragNode.getName = function getName() {
    return 'DragNode';
  };

  /**
   * Constructor function of DragNode class
   */


  function DragNode() {
    _classCallCheck(this, DragNode);

    var _this = _possibleConstructorReturn(this, _DragBase.call(this));

    var chart = _this;
    chart.fireGroupEvent = true;
    chart.numVDivLines = 0;
    chart.numDivLines = 0;
    chart.usesXYinCategory = true;
    chart.showLimits = 0;
    chart.setadaptivexmin = 1;
    chart.showdivlinevalues = 0;
    chart.showzeroplane = 0;
    chart.showyaxisvalues = 0;
    chart.dontShowLegendByDefault = true;
    _this.registerFactory('dataset', _dragnodeDataset2['default'], ['vCanvas']);
    _this.registerFactory('axis', _xyAxis2['default'], ['canvas']);
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  DragNode.prototype.getName = function getName() {
    return 'DragNode';
  };
  /**
   * function to check if the chart specific data is proper is not
   * this fn is define for specific chart types
   * @return {boolean} if JSON data is valid or not
   */


  DragNode.prototype._checkInvalidSpecificData = function _checkInvalidSpecificData() {
    var jsonData = this.getFromEnv('dataSource'),
        datasetsJSON = jsonData.dataset;
    if (!datasetsJSON) {
      return true;
    }
  };
  /**
   * Function to parse the common configurations at dataset level
   * @param {Object} dataObj contains json data of the chart
   */


  DragNode.prototype.parseChartAttr = function parseChartAttr(dataObj) {
    var iapi = this,
        jsonData = iapi.getFromEnv('dataSource'),
        chartAttr = jsonData.chart,
        config,
        transcoders = (0, _dependencyManager.getDepsByType)('transcoder');
    _DragBase.prototype.parseChartAttr.call(this, dataObj);
    config = iapi.config;
    config.formAction = (0, _lib.getValidValue)(chartAttr.formaction);
    config.showLegend = (0, _lib.pluckNumber)(chartAttr.showlegend, 0);

    if (chartAttr.submitdataasxml === _lib.ZEROSTRING && !chartAttr.formdataformat) {
      chartAttr.formdataformat = transcoders.csv().format;
    }

    config.formDataFormat = (0, _lib.pluck)(chartAttr.formdataformat, transcoders.xml().format);
    config.formTarget = (0, _lib.pluck)(chartAttr.formtarget, '_self');
    config.formMethod = (0, _lib.pluck)(chartAttr.formmethod, 'POST');
    config.submitFormAsAjax = (0, _lib.pluckNumber)(chartAttr.submitformusingajax, 1);
    config.viewMode = (0, _lib.pluckNumber)(chartAttr.viewmode, 0);
    config.drawTrendRegion = 0;
  };

  /**
   * Parsing the default configuration of the chart and over-writting the limitUpdaterEnabled
   */


  DragNode.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _DragBase.prototype.__setDefaultConfig.call(this);
    var chart = this;
    chart.config.hasLegend = true;
    chart.config.friendlyName = 'Dragable Node Chart';
    chart.config.defaultDatasetType = 'dragnode';
    chart.config.limitUpdaterEnabled = false;
    chart.config.skipClipping = true;
  };

  /**
   * Function to add the menu options for the menu list
   */


  DragNode.prototype.addConfigureOptions = function addConfigureOptions() {
    var chart = this,
        chartConf = chart.config,
        restore,
        submit,
        restoreBtnTitle = chartConf.restoreBtnTitle,
        submitBtnTitle = chartConf.submitBtnTitle,
        sListRef = chart.getFromEnv('chartMenuList'),
        viewMode = chart.config.viewMode,
        configureTools = [{
      'Add Node': {
        handler: function handler() {
          var manager = chart.getChildren('canvas')[0].getChildren('vCanvas')[0].getChildren('datasetGroup_dragNode')[0];
          manager.showNodeAddUI();
        },
        action: 'click'
      }
    }, {
      'Add Connector': {
        handler: function handler() {
          var manager = chart.getChildren('canvas')[0].getChildren('vCanvas')[0].getChildren('datasetGroup_dragNode')[0];
          manager.showConnectorAddUI();
        },
        action: 'click'
      }
    }, {
      'Add Label': {
        handler: function handler() {
          var manager = chart.getChildren('canvas')[0].getChildren('vCanvas')[0].getChildren('datasetGroup_dragNode')[0];
          manager.showLabelUpdateUI();
        },
        action: 'click'
      }
    }];

    if (chartConf.showRestoreBtn) {
      restore = {};
      restore[restoreBtnTitle] = {
        handler: function handler() {
          var manager = chart.getChildren('canvas')[0].getChildren('vCanvas')[0].getChildren('datasetGroup_dragNode')[0];
          manager.restoreData();
        },
        action: 'click'
      };
      configureTools.push(restore);
    }

    if (chartConf.formAction) {
      submit = {};
      submit[submitBtnTitle] = {
        handler: function handler() {
          chart.submitData();
        },
        action: 'click'
      };
      configureTools.push(submit);
    }

    // setChartTools(configureTools);
    !viewMode && sListRef.appendAsList(configureTools);
  };

  /**
   * Function to map the dataset class to its type
   * @param {string} dsType the type of the dataset.
   * @return {Class} The corresponding dataset class.
   */


  DragNode.prototype.getDSdef = function getDSdef(dsType) {
    switch (dsType) {
      case 'connector':
        return _connector2['default'];
      case 'dragnode':
        return _dragnode2['default'];
      case 'dragableLabels':
        return _dragablelabels2['default'];
    }
  };

  /**
   * Function to determine the group manager associated with the current chartAPI
   * @return {Class} The group class
   */


  DragNode.prototype.getDSGroupdef = function getDSGroupdef() {
    return _dragnode4['default'];
  };

  /**
   * Fucntion to set the categories of X axes.
   */


  DragNode.prototype._setCategories = function _setCategories() {
    var iapi = this,
        dataObj = iapi.getFromEnv('dataSource'),
        xAxis = iapi.getChildren('xAxis'),
        categories = dataObj.categories && dataObj.categories[0].category || [],
        catLen = categories.length,
        catArr = [],
        i,
        catObj;

    for (i = 0; i < catLen; i++) {
      catObj = categories[i] || {};
      if (catObj.x !== undefined) {
        catArr.push(catObj);
      }
    }

    xAxis && xAxis[0].setTickValues(catArr);
  };

  /**
   * Function to get the jsonData
   * @return {Object} the jsonData
   */


  DragNode.prototype.getJSONData = function getJSONData() {
    var chart = this,
        canvas = chart.getChildren('canvas')[0],
        vCanvas = canvas.getChildren('vCanvas')[0],
        groupManager = vCanvas.getChildren('datasetGroup_dragNode')[0],
        rawObj = chart.getFromEnv('dataSource'),
        datasetsArr = {},
        jsonObj;

    if (groupManager) {
      datasetsArr = groupManager.getJSONData();
    }

    jsonObj = (0, _lib.extend2)({}, rawObj);
    jsonObj.dataset = datasetsArr.dataset;
    jsonObj.connectors = datasetsArr.connectors;
    jsonObj.labels = datasetsArr.labels;
    return jsonObj;
  };

  return DragNode;
}(_fusioncharts2['default']);

exports.configurer = configurer = DragNode.prototype.configure;
exports['default'] = DragNode;
exports.configurer = configurer;

/***/ }),

/***/ 365:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _dragnode = __webpack_require__(233);

var _dragnode2 = _interopRequireDefault(_dragnode);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _draggablelabelAnimation = __webpack_require__(785);

var _draggablelabelAnimation2 = _interopRequireDefault(_draggablelabelAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var PX = _lib.preDefStr.PX,
    EVENTARGS = 'eventArgs',
    TRACKER_FILL = 'rgba(192,192,192,' + (_lib.isIE ? 0.002 : 0.000001) + ')'; // invisible but clickable

/**
 * Dataset class for draggable labels
 */

var DragNodeLabels = function (_DragNodeDataset) {
  _inherits(DragNodeLabels, _DragNodeDataset);

  /**
   * Creates an instance of DragNodeLabels.
   * @memberof DragNodeLabels
   */
  function DragNodeLabels() {
    _classCallCheck(this, DragNodeLabels);

    var _this = _possibleConstructorReturn(this, _DragNodeDataset.call(this));

    (0, _dependencyManager.addDep)({
      name: 'draggablelabelAnimation',
      type: 'animationRule',
      extension: _draggablelabelAnimation2['default']
    });
    return _this;
  }
  /**
   * Sets the type of the component
   * @return {string} type
   */


  DragNodeLabels.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  DragNodeLabels.prototype.getName = function getName() {
    return 'dragNodeLabels';
  };

  /**
    * Function for parsing all the attributes and value given by the user at chart and dataset level.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} if no datasetJSON is found
    */


  DragNodeLabels.prototype.configure = function configure(datasetJSON) {
    if (datasetJSON) {
      this.trimData(datasetJSON);
      this.config.JSONData = datasetJSON.label;
    } else if (!datasetJSON && !this.config.JSONData) {
      return false;
    }

    var dataset = this,

    // chart = dataset.chart,
    // jsonData = chart.jsonData,
    chartAttr = dataset.getFromEnv('chart-attrib'),
        conf = dataset.config,
        setDataArr = dataset.config.JSONData || [],
        len = setDataArr.length,

    // dataStoreLen,
    dataStore = dataset.components.data,
        i;
    conf.viewMode = (0, _lib.pluckNumber)(chartAttr.viewmode, 0);
    if (!dataStore) {
      dataStore = dataset.components.data = [];
    }
    // dataStoreLen = dataStore.length;

    for (i = 0; i < len; i++) {
      dataset._setConfigure(i);
    }
  };

  /**
   * Function for parsing all the attributes and value given by the user at set level.
   * @param {number} index The data index for which the configuration is to be parsed.
   * @param {Object} updateObj It has the information of the data given by the user at the set level
   */


  DragNodeLabels.prototype._setConfigure = function _setConfigure(index, updateObj) {
    var dataset = this,
        setDataArr = dataset.config.JSONData,

    // chart = dataset.chart,
    setData = updateObj || setDataArr[index],
        dataStore = dataset.components.data,
        dataObj,
        text,

    // style = chart.config.style,
    inCanvasStyle = dataset.getFromEnv('style').inCanvasStyle,
        inCanFontSize = inCanvasStyle.fontSize,

    // labelColor,
    // labelBGColor,
    config,

    // labelBDColor,
    // alpha,
    labelFontSize;
    dataObj = dataStore[index];
    !dataObj && (dataObj = dataStore[index] = {});
    !dataObj.graphics && (dataObj.graphics = {});

    config = dataObj.config = dataObj.config || (dataObj.config = {});
    text = (0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.text, setData.label));
    config._options = setData;
    config.add = setData.add;
    if (text) {
      config.text = text;
      config.x = setData.x || 0;
      config.y = setData.y || 0;
      config.labelFontSize = labelFontSize = (0, _lib.pluckNumber)(setData.fontsize, inCanFontSize);

      config.labelColor = (0, _lib.hashify)((0, _lib.pluck)(setData.color, inCanvasStyle.color));
      config.alpha = (0, _lib.pluckNumber)(setData.alpha, 100) / 100;
      config.allowdrag = (0, _lib.pluckNumber)(setData.allowdrag, 1);
      config.padding = (0, _lib.pluckNumber)(setData.padding, 5);

      // config.labelColor = labelColor = convertColor(pluck(setData.color, inCanvasStyle.color),
      //   pluckNumber(setData.alpha, 100));

      if (setData.fontsize) {
        config.labelCSS = {
          fontSize: labelFontSize + PX
        };
      } else {
        config.labelCSS = undefined;
      }

      config.labelBGColor = (0, _lib.pluck)(setData.bgcolor && setData.bgcolor.replace(_lib.dropHash, _lib.HASHSTRING));
      config.labelBDColor = (0, _lib.pluck)(setData.bordercolor && setData.bordercolor.replace(_lib.dropHash, _lib.HASHSTRING));
      config.link = setData.link;
      config.allowDrag = (0, _lib.pluckNumber)(setData.allowdrag, 1);
      config.borderThickness = setData.borderthickness;
      config.dashLen = setData.dashlen;
      config.dashGap = setData.dashgap;
      config.dashed = setData.dashed;
      config.radius = setData.radius;
    }
  };

  /**
   * Get jsondata of dragable label dataset
   * @return {Object} The JSON data
   */


  DragNodeLabels.prototype.getJSONData = function getJSONData() {
    var dataset = this,
        dataStore = dataset.components.data,
        len = dataStore.length,
        jsonData = [],
        dataObj,
        i;
    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      if (!dataObj.removed) {
        if (dataObj.config._options) {
          jsonData.push(dataObj.config._options);
        }
      }
    }
    return jsonData;
  };

  /**
   * Function to create container at the dataset level
   */


  DragNodeLabels.prototype.createContainer = function createContainer() {
    var dataset = this,
        animationManager = dataset.getFromEnv('animationManager'),
        parentContainer = dataset.getLinkedParent().getChildContainer();

    !dataset.getContainer('dragLabelGroup') && dataset.addContainer('dragLabelGroup', animationManager.setAnimation({
      el: 'group',
      attr: {
        name: 'dragLabelGroup'
      },
      dom: 'group',
      component: dataset,
      container: parentContainer.defaultVcanvasGroup
    }));
  };

  /**
   * Parses and sets the attributes during post space management
   *
   * @memberof DragNodeLabels
   */


  DragNodeLabels.prototype.allocatePosition = function allocatePosition() {
    this.parsePlotAttributes();
  };

  /**
   * Parsing of attributes
   *
   * @memberof DragNodeLabels
   */


  DragNodeLabels.prototype.parsePlotAttributes = function parsePlotAttributes() {
    var dataset = this,
        dataStore = dataset.components.data,
        yAxis = dataset.getFromEnv('yAxis'),
        xAxis = dataset.getFromEnv('xAxis'),
        SmartLabel = dataset.getFromEnv('smartLabel'),
        style = dataset.getFromEnv('dataLabelStyle'),
        dashLen,
        dashGap,
        dashed,
        x,
        y,
        color,
        text,
        bgColor,
        borderColor,
        padding,
        config,
        attr,

    // alpha,
    dataObj,
        allowDrag,
        fontSize,
        radius,
        dim,
        borderThickness,
        len = dataStore && dataStore.length,
        lStyle,
        chartConfig = dataset.getFromEnv('chartConfig'),
        i,
        labelCSS;

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      if (dataObj.removed) {
        continue;
      }
      config = dataObj.config;
      !dataObj.graphics && (dataObj.graphics = {});
      config.index = i;
      x = xAxis.getPixel(config.x);
      y = yAxis.getPixel(config.y);
      text = config.text;
      bgColor = config.labelBGColor;
      borderColor = config.labelBDColor;
      padding = config.padding;
      allowDrag = config.allowDrag;
      fontSize = config.labelFontSize;
      color = config.labelColor;
      radius = config.radius;
      dashed = config.dashed;
      borderThickness = config.borderThickness;
      dashLen = config.dashLen;
      dashGap = config.dashGap;
      borderThickness = config.borderThickness;
      labelCSS = config.labelCSS;

      attr = {
        x: x,
        y: y,
        text: text,
        align: _lib.POSITION_CENTER,
        fill: color,
        'text-bound': [bgColor || _lib.BLANKSTRING, borderColor || _lib.BLANKSTRING, (0, _lib.pluckNumber)(borderThickness, 1), padding, (0, _lib.pluckNumber)(radius, 0), (0, _lib.pluckNumber)(dashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(dashLen, 5), (0, _lib.pluckNumber)(dashGap, 4)) : _lib.DASH_DEF],
        visibility: _lib.visibleStr
      };

      lStyle = {
        backgroundColor: bgColor,
        borderColor: borderColor,
        borderPadding: padding,
        fontSize: fontSize + _lib.PXSTRING,
        fontStyle: style.fontStyle,
        fontWeight: style.fontWeight,
        borderRadius: 0,
        borderDash: _lib.DASH_DEF,
        fontFamily: style.fontFamily
      };
      (0, _lib.setLineHeight)(lStyle);
      SmartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
      SmartLabel.setStyle(lStyle);
      config.eventArgs = {
        link: config.link,
        text: text,
        x: x,
        y: y,
        allowdrag: allowDrag,
        sourceType: 'labelnode'
      };

      config.props = {
        element: {
          attr: attr
        }
      };

      config.labelCSSApplied = labelCSS;

      dim = SmartLabel.getOriSize(text);
      config.width = dim.width;
      config.height = dim.height;
      config.xPos = x;
      config.yPos = y;
    }
  };
  /**
   * Function ot draw the entire dataset
   */


  DragNodeLabels.prototype.draw = function draw() {
    var dataset = this,
        dataStore = dataset.components.data,
        animationManager = dataset.getFromEnv('animationManager'),
        style = dataset.getFromEnv('dataLabelStyle'),
        config,
        dataObj,
        element,
        elementCheck,
        len = dataStore && dataStore.length,
        removeDataArr = dataset.components.removeDataArr || [],
        removeDataArrLen = removeDataArr.length,
        i,
        dataLabelContainer,
        labelCSS;

    dataset.createContainer();
    dataLabelContainer = dataset.getContainer('dragLabelGroup');
    dataLabelContainer.css({
      'font-weight': style.fontWeight,
      'font-style': style.fontStyle,
      'font-size': style.fontSize,
      'font-family': style.fontFamily
    });

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      if (dataObj.removed) {
        continue;
      }
      config = dataObj.config;
      elementCheck = dataObj.graphics.element;

      element = animationManager.setAnimation({
        el: elementCheck || 'text',
        container: dataLabelContainer,
        css: config.labelCSS,
        attr: config.props.element.attr,
        component: dataset
      });

      if (!elementCheck) {
        dataObj.graphics.element = element;
      } else {
        // If label css was applied on this element and now label css is not given then remove css
        if (config.labelCSSApplied && !labelCSS) {
          element.removeCSS();
        }
        element.show().css(config.labelCSS);
      }

      element.data('eventArgs', config.eventArgs);
    }
    // jobList.trackerDrawID.push(schedular.addJob(function () {
    dataset.drawTracker();
    // }, lib.priorityList.tracker));
    for (i = 0; i < removeDataArrLen; i++) {
      dataset._removeDataVisuals(removeDataArr.shift());
    }
  };

  /**
   * Function ot draw the tracker over the lables for showing the tooltips and other mouse interactivity
   */


  DragNodeLabels.prototype.drawTracker = function drawTracker() {
    var dataset = this,
        dataStore = dataset.components.data,
        animationManager = dataset.getFromEnv('animationManager'),
        chart = dataset.getFromEnv('chart'),
        manager = dataset.getLinkedParent(),
        conf = dataset.config,
        trackerGroup = dataset.getContainer('dragLabelGroup'),
        len = dataStore && dataStore.length,
        dataObj,
        config,
        padding,
        elemMouseDownFN = function elemMouseDownFN(labelObj) {
      // Long press eve
      var ele = this;
      ele.data('fire_click_event', 1);
      manager.clearLongPress();
      manager.triggerLabelUI(ele, labelObj);
    },
        elemMouseMoveFN = function elemMouseMoveFN() {
      // Whether to fire the click event ot not
      var ele = this;
      if (ele.data('fire_click_event')) {
        ele.data('fire_click_event', 0);
        manager.clearLongPress();
      }
    },
        elemMouseUPFN = function elemMouseUPFN(data) {
      var ele = this,
          fireClick = ele.data('fire_click_event');
      manager.clearLongPress();
      if (fireClick) {
        /**
           *
           * > Applicable to `dragnode` chart only.
           *
           * @event FusionCharts#labelClick
           * @group chart-powercharts:dragnode
           *
           * @param {number} chartX - x-coordinate of the pointer relative to the chart.
           * @param {number} chartY - y-coordinate of the pointer relative to the chart.
           * @param {number} pageX - x-coordinate of the pointer relative to the page.
           * @param {number} pageY - y-coordinate of the pointer relative to the page.
           *
           * @param {number} x - The x-value of the label node scaled as per the axis of the chart.
           * @param {number} y - The y-value of the label node scaled as per the axis of the chart.
           *
           * @param {string} text - The text value of the label.
           */
        _lib.plotEventHandler.call(ele, chart, data, 'LabelClick');
      }
    },
        elemHoverFN = function elemHoverFN(data) {
      var ele = this;
      /**
       *
       * > Applicable to `dragnode` chart only.
       *
       * @event FusionCharts#labelRollOver
       * @group chart-powercharts:dragnode
       *
       * @param {number} chartX - x-coordinate of the pointer relative to the chart.
       * @param {number} chartY - y-coordinate of the pointer relative to the chart.
       * @param {number} pageX - x-coordinate of the pointer relative to the page.
       * @param {number} pageY - y-coordinate of the pointer relative to the page.
       *
       * @param {number} x - The x-value of the label node scaled as per the axis of the chart.
       * @param {number} y - The y-value of the label node scaled as per the axis of the chart.
       *
       * @param {string} text - The text value of the label.
       */
      _lib.plotEventHandler.call(ele, chart, data, 'LabelRollover');
    },
        elemOutFN = function elemOutFN(data) {
      var ele = this;
      /**
       *
       * > Applicable to `dragnode` chart only.
       *
       * @event FusionCharts#labelRollOut
       * @group chart-powercharts:dragnode
       *
       * @param {number} chartX - x-coordinate of the pointer relative to the chart.
       * @param {number} chartY - y-coordinate of the pointer relative to the chart.
       * @param {number} pageX - x-coordinate of the pointer relative to the page.
       * @param {number} pageY - y-coordinate of the pointer relative to the page.
       *
       * @param {number} x - The x-value of the label node scaled as per the axis of the chart.
       * @param {number} y - The y-value of the label node scaled as per the axis of the chart.
       *
       * @param {string} text - The text value of the label.
       */
      _lib.plotEventHandler.call(ele, chart, data, 'LabelRollout');
    },
        eventArgs,
        attr,
        allowDrag,
        text,
        trackerElement,
        trackerElementCheck,
        x,
        y,
        width,
        height,
        dragMove = function dragMove(event, data) {
      var ele = this;
      dataset._labelDragMove.call(ele, event, data, chart);
    },
        dragStart = function dragStart(event) {
      var ele = this;
      dataset._labelDragStart.call(ele, event, chart);
    },
        dragUp = function dragUp(event) {
      var ele = this;
      dataset._labelDragUp.call(ele, event);
    },
        i;

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      if (dataObj.removed) {
        continue;
      }
      config = dataObj.config;
      padding = config.padding || 0;
      width = config.width;
      height = config.height;
      x = config.xPos - width / 2;
      y = config.yPos - height / 2;
      allowDrag = config.allowDrag;
      text = config.text;
      trackerElementCheck = dataObj.graphics.trackerElement;
      attr = {
        x: x - padding,
        y: y - padding,
        width: width + padding * 2,
        height: height + padding * 2,
        cursor: config.allowDrag ? 'move' : _lib.BLANKSTRING,
        fill: TRACKER_FILL,
        stroke: TRACKER_FILL,
        ishot: true
      };
      eventArgs = {
        link: config.link,
        text: text,
        x: x,
        y: y,
        allowdrag: allowDrag,
        sourceType: 'labelnode'
      };
      trackerElement = animationManager.setAnimation({
        el: trackerElementCheck || 'rect',
        container: trackerGroup,
        attr: attr,
        component: dataset
      });
      if (!trackerElementCheck) {
        dataObj.graphics.trackerElement = trackerElement;
        trackerElement.mousedown(elemMouseDownFN).mousemove(elemMouseMoveFN).mouseup(elemMouseUPFN).data('viewMode', conf.viewMode).data(_lib.preDefStr.EVENTARGS, eventArgs).hover(elemHoverFN, elemOutFN).drag(dragMove, dragStart, dragUp);
      }
      trackerElement.data('drag-options', {
        index: i,
        dataset: dataset
      });
    }
  };

  /**
   * Callback function when the dragging of the label starts
   */


  DragNodeLabels.prototype._labelDragStart = function _labelDragStart() {
    var ele = this,
        bBox = ele.getBBox(),
        data = ele.data('drag-options'),
        dataset = data.dataset,
        manager = dataset.getLinkedParent(),
        index = data.index,
        labelObj = dataset.components.data[index],
        labelElement = labelObj.graphics.element,
        dragStart = labelObj.dragStart = labelObj.dragStart || (labelObj.dragStart = {});
    data.ox = labelElement.attr('x');
    data.oy = labelElement.attr('y');
    data.bBox = bBox;
    dragStart.xPos = labelObj.config.xPos;
    dragStart.yPos = labelObj.config.yPos;
    dragStart.bBox = bBox;
    ele.data('fire_click_event', 1);
    ele.data('fire_dragend', 0);
    manager.clearLongPress();
    manager.triggerLabelUI(ele, labelObj);
  };

  /**
   * Callback function when the labels are dragged around
   * @param {Event} event The actual mouse event
   * @param {Object} positionData Contains the coordinates of the label elements while they are dragged
   */


  DragNodeLabels.prototype._labelDragMove = function _labelDragMove(event, positionData) {
    // eslint-disable-line no-unused-vars
    var ele = this,
        data = ele.data('drag-options'),
        index = data.index,
        dataset = data.dataset,
        chart = dataset.getFromEnv('chart'),
        chartConfig = dataset.getFromEnv('chartConfig'),
        canvasLeft = chartConfig.canvasLeft,
        canvasRight = chartConfig.canvasRight,
        canvasBottom = chartConfig.canvasBottom,
        canvasTop = chartConfig.canvasTop,
        manager = dataset.getLinkedParent(),
        labelObj = dataset.components.data[index],
        labelElement = labelObj.graphics.element,
        dragStart = labelObj.dragStart,
        bBox = dragStart.bBox,
        dx = positionData[0],
        dy = positionData[1],
        startX = dragStart.bBox.x + dx,
        endX = dragStart.bBox.x2 + dx,
        startY = dragStart.bBox.y + dy,
        endY = dragStart.bBox.y2 + dy,
        yAxis = dataset.getFromEnv('yAxis'),
        xAxis = dataset.getFromEnv('xAxis'),
        xPos,
        yPos;
    // Bound limits
    if (startX < canvasLeft) {
      dx += canvasLeft - startX;
    }
    if (endX > canvasRight) {
      dx -= endX - canvasRight;
    }
    if (startY < canvasTop) {
      dy += canvasTop - startY;
    }
    if (endY > canvasBottom) {
      dy -= endY - canvasBottom;
    }
    dragStart.draged = true;
    ele.attr({
      x: bBox.x + dx,
      y: bBox.y + dy
    });

    xPos = data.ox + dx;
    yPos = data.oy + dy;
    labelElement.attr({
      x: data.ox + dx,
      y: data.oy + dy
    });
    labelObj.config.x = xAxis.getValue(xPos - canvasLeft);
    labelObj.config.y = yAxis.getValue(yPos - canvasTop);
    if (!ele.data('fire_dragend')) {
      /**
         *
         * > Applicable to `dragnode` chart only.
         *
         * @event FusionCharts#labelDragStart
         * @group chart-powercharts:dragnode
         *
         * @param {number} chartX - x-coordinate of the pointer relative to the chart.
         * @param {number} chartY - y-coordinate of the pointer relative to the chart.
         * @param {number} pageX - x-coordinate of the pointer relative to the page.
         * @param {number} pageY - y-coordinate of the pointer relative to the page.
         *
         * @param {number} x - The x-value of the label node scaled as per the axis of the chart.
         * @param {number} y - The y-value of the label node scaled as per the axis of the chart.
         *
         * @param {string} text - The text value of the label.
         */
      _lib.plotEventHandler.call(ele, chart, event, 'LabelDragStart');
      ele.data('fire_dragend', 1);
    }
    if (ele.data('fire_click_event')) {
      ele.data('fire_click_event', 0);
      manager.clearLongPress();
    }
  };

  /**
   * Callback function when dragging is stopped over a label
   * @param {Event} event The actual event object
   */


  DragNodeLabels.prototype._labelDragUp = function _labelDragUp(event) {
    var ele = this,
        data = ele.data('drag-options'),
        index = data.index,
        dataset = data.dataset,
        chart = dataset.getFromEnv('chart'),
        xAxis = chart.getChildren('xAxis')[0],
        yAxis = chart.getChildren('yAxis')[0],
        manager = dataset.getLinkedParent(),
        sourceEvent = 'labeldragend',
        labelObj = dataset.components.data[index],
        dragStart = labelObj.dragStart,
        eventArgs = ele.data(EVENTARGS);

    eventArgs.x = xAxis.getValue(ele.attr('x'));
    eventArgs.y = yAxis.getValue(ele.attr('y'));

    dragStart.draged = false;
    if (ele.data('fire_dragend')) {
      // eventCord = getMouseCoordinate(chart.linkedItems.container, event);
      // eventCord.sourceEvent = sourceEvent;

      // Fire the ChartUpdated event
      // lib.raiseEvent('chartupdated',
      //   extend2(eventCord, eventArgs),
      //   chart.chartInstance);
      /**
         *
         * > Applicable to `dragnode` chart only.
         *
         * @event FusionCharts#labelDragEnd
         * @group chart-powercharts:dragnode
         *
         * @param {number} chartX - x-coordinate of the pointer relative to the chart.
         * @param {number} chartY - y-coordinate of the pointer relative to the chart.
         * @param {number} pageX - x-coordinate of the pointer relative to the page.
         * @param {number} pageY - y-coordinate of the pointer relative to the page.
         *
         * @param {number} x - The x-value of the label node scaled as per the axis of the chart.
         * @param {number} y - The y-value of the label node scaled as per the axis of the chart.
         *
         * @param {string} text - The text value of the label.
         */
      _lib.plotEventHandler.call(ele, chart, event, sourceEvent);
    }
    manager.clearLongPress();
  };

  /**
   * Function to remove data during update if number of data has reduced than the previous render
   * @param {number} index The data index from which data has to be removed.
   * @param {number} stretch The index upto which data has to be removed
   */


  DragNodeLabels.prototype.removeData = function removeData(index, stretch) {
    var dataset = this,
        components = dataset.components,
        dataStore = components.data;
    components.removeDataArr = dataStore.splice(index, stretch);
  };

  /**
   * function to Remove data plots if the number of current data plots/categories
   * is more than the existing ones.
   * @param  {Object} datasetJSON JSON for dataset configurations
   */


  DragNodeLabels.prototype.trimData = function trimData(datasetJSON) {
    if (!this.config.JSONData) {
      return;
    }
    var dataSet = this,
        prevData = dataSet.config.JSONData,
        prevDataLength = prevData && prevData.length,
        currDataLength = datasetJSON.label && datasetJSON.label.length || 0,
        dataDiff = prevDataLength - currDataLength;

    // Removing data plots if the number of current data plots/categories
    // is more than the existing ones.
    if (dataDiff > 0) {
      dataSet.removeData(currDataLength, dataDiff);
    }
  };

  return DragNodeLabels;
}(_dragnode2['default']);

exports['default'] = DragNodeLabels;

/***/ }),

/***/ 366:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(367);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _column = __webpack_require__(15);

var _column2 = _interopRequireDefault(_column);

var _column3 = __webpack_require__(8);

var _column4 = _interopRequireDefault(_column3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var LogMSColumn2d = function (_MSLog) {
  _inherits(LogMSColumn2d, _MSLog);

  function LogMSColumn2d() {
    _classCallCheck(this, LogMSColumn2d);

    return _possibleConstructorReturn(this, _MSLog.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  LogMSColumn2d.getName = function getName() {
    return 'LogMSColumn2d';
  };

  /**
   * Sets the name of the component
   * @return {string} name
   */


  LogMSColumn2d.prototype.getName = function getName() {
    return 'LogMSColumn2d';
  };

  LogMSColumn2d.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSLog.prototype.__setDefaultConfig && _MSLog.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Multi-series Log Column Chart';
    config.defaultDatasetType = 'column';
    config.enablemousetracking = true;
  };

  LogMSColumn2d.prototype.getDSGroupdef = function getDSGroupdef() {
    return _column2['default'];
  };

  LogMSColumn2d.prototype.getDSdef = function getDSdef() {
    return _column4['default'];
  };

  return LogMSColumn2d;
}(_fusioncharts2['default']);

exports['default'] = LogMSColumn2d;

/***/ }),

/***/ 367:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(16);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _logAxis = __webpack_require__(788);

var _logAxis2 = _interopRequireDefault(_logAxis);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var chartPaletteStr = {
  chart2D: {
    bgColor: 'bgColor',
    bgAlpha: 'bgAlpha',
    bgAngle: 'bgAngle',
    bgRatio: 'bgRatio',
    canvasBgColor: 'canvasBgColor',
    canvasBaseColor: 'canvasBaseColor',
    divLineColor: 'divLineColor',
    legendBgColor: 'legendBgColor',
    legendBorderColor: 'legendBorderColor',
    toolTipbgColor: 'toolTipbgColor',
    toolTipBorderColor: 'toolTipBorderColor',
    baseFontColor: 'baseFontColor',
    anchorBgColor: 'anchorBgColor'
  },
  chart3D: {
    bgColor: 'bgColor3D',
    bgAlpha: 'bgAlpha3D',
    bgAngle: 'bgAngle3D',
    bgRatio: 'bgRatio3D',
    canvasBgColor: 'canvasBgColor3D',
    canvasBaseColor: 'canvasBaseColor3D',
    divLineColor: 'divLineColor3D',
    divLineAlpha: 'divLineAlpha3D',
    legendBgColor: 'legendBgColor3D',
    legendBorderColor: 'legendBorderColor3D',
    toolTipbgColor: 'toolTipbgColor3D',
    toolTipBorderColor: 'toolTipBorderColor3D',
    baseFontColor: 'baseFontColor3D',
    anchorBgColor: 'anchorBgColor3D'
  }
};

var MsLog = function (_MSCartesian) {
  _inherits(MsLog, _MSCartesian);

  function MsLog() {
    _classCallCheck(this, MsLog);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.registerFactory('axis', _logAxis2['default'], ['canvas']);
    return _this;
  }
  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */


  MsLog.getName = function getName() {
    return 'MsLog';
  };

  MsLog.prototype._feedAxesRawData = function _feedAxesRawData() {
    var iapi = this,
        colorM = iapi.getFromEnv('color-manager'),
        dataObj = iapi.getFromEnv('dataSource'),
        chartAttrs = iapi.getFromEnv('chart-attrib'),
        xAxisConf,
        yAxisConf,
        is3D = iapi.config.is3D,
        palleteString = is3D ? chartPaletteStr.chart3D : chartPaletteStr.chart2D,
        invertYAxis = !!(0, _lib.pluckNumber)(chartAttrs.invertyaxis, 0);

    xAxisConf = {
      isVertical: false,
      isReverse: false,
      isOpposit: false,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.xaxisnamepadding,
      axisValuePadding: chartAttrs.labelpadding,
      axisNameFont: chartAttrs.xaxisnamefont,
      axisNameFontSize: chartAttrs.xaxisnamefontsize,
      axisNameFontColor: chartAttrs.xaxisnamefontcolor,
      axisNameFontBold: chartAttrs.xaxisnamefontbold,
      axisNameFontItalic: chartAttrs.xaxisnamefontitalic,
      axisNameBgColor: chartAttrs.xaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.xaxisnamebordercolor,
      axisNameAlpha: chartAttrs.xaxisnamealpha,
      axisNameFontAlpha: chartAttrs.xaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.xaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.xaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.xaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.xaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.xaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.xaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.xaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.xaxisnameborderdashgap,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      divLineColor: (0, _lib.pluck)(chartAttrs.vdivlinecolor, chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.vdivlinealpha, chartAttrs.divlinealpha, is3D ? colorM.getColor('divLineAlpha3D') : colorM.getColor('divLineAlpha')),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.vdivlinethickness, chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.vdivlinedashed, chartAttrs.vdivlineisdashed, chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashlen, chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashgap, chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatevgridcolor, 0),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatevgridcolor, colorM.getColor('altVGridColor')),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatevgridalpha, colorM.getColor('altVGridAlpha')),
      numDivLines: chartAttrs.numvdivlines,
      maxLabelHeight: chartAttrs.maxlabelheight,
      labelFont: chartAttrs.labelfont,
      labelFontSize: chartAttrs.labelfontsize,
      labelFontColor: chartAttrs.labelfontcolor,
      labelFontAlpha: chartAttrs.labelalpha,
      labelFontBold: chartAttrs.labelfontbold,
      labelFontItalic: chartAttrs.labelfontitalic,
      axisName: chartAttrs.xaxisname,
      axisMinValue: chartAttrs.xaxisminvalue,
      axisMaxValue: chartAttrs.xaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptivexmin,
      adjustDiv: chartAttrs.adjustvdiv,
      labelDisplay: chartAttrs.labeldisplay,
      showLabels: chartAttrs.showlabels,
      rotateLabels: chartAttrs.rotatelabels,
      slantLabel: (0, _lib.pluckNumber)(chartAttrs.slantlabels, chartAttrs.slantlabel),
      labelStep: (0, _lib.pluckNumber)(chartAttrs.labelstep, chartAttrs.xaxisvaluesstep),
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showxaxisvalues, chartAttrs.showxaxisvalue),
      showLimits: chartAttrs.showvlimits,
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showvdivlinevalues, chartAttrs.showvdivlinevalues),
      showZeroPlane: chartAttrs.showvzeroplane,
      zeroPlaneColor: chartAttrs.vzeroplanecolor,
      zeroPlaneThickness: chartAttrs.vzeroplanethickness,
      zeroPlaneAlpha: chartAttrs.vzeroplanealpha,
      showZeroPlaneValue: chartAttrs.showvzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showxaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.xaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.xaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.xaxislinecolor, chartAttrs.axislinecolor, '#000000')
    };
    yAxisConf = {
      isVertical: true,
      isReverse: !invertYAxis,
      isOpposit: false,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.yaxisnamepadding,
      axisValuePadding: chartAttrs.yaxisvaluespadding,
      axisNameFont: chartAttrs.yaxisnamefont,
      axisNameFontSize: chartAttrs.yaxisnamefontsize,
      axisNameFontColor: chartAttrs.yaxisnamefontcolor,
      axisNameFontBold: chartAttrs.yaxisnamefontbold,
      axisNameFontItalic: chartAttrs.yaxisnamefontitalic,
      axisNameBgColor: chartAttrs.yaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.yaxisnamebordercolor,
      axisNameAlpha: chartAttrs.yaxisnamealpha,
      axisNameFontAlpha: chartAttrs.yaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.yaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.yaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.yaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.yaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.yaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.yaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.yaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.yaxisnameborderdashgap,
      axisNameWidth: chartAttrs.yaxisnamewidth,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      rotateAxisName: (0, _lib.pluckNumber)(chartAttrs.rotateyaxisname, 1),
      axisName: chartAttrs.yaxisname,
      divLineColor: (0, _lib.pluck)(chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.divlinealpha, colorM.getColor('divLineAlpha')),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.divlinethickness, 2),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatehgridcolor, 1),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatehgridcolor, colorM.getColor('altHGridColor')),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatehgridalpha, colorM.getColor('altHGridAlpha')),
      numDivLines: chartAttrs.numdivlines,
      axisMinValue: chartAttrs.yaxisminvalue,
      axisMaxValue: chartAttrs.yaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptiveymin,
      adjustDiv: chartAttrs.adjustdiv,
      labelStep: chartAttrs.yaxisvaluesstep,
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue),
      showLimits: (0, _lib.pluckNumber)(chartAttrs.showyaxislimits, chartAttrs.showlimits, iapi.showLimits),
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showdivlinevalues, chartAttrs.showdivlinevalue),
      showZeroPlane: chartAttrs.showzeroplane,
      zeroPlaneColor: chartAttrs.zeroplanecolor,
      zeroPlaneThickness: chartAttrs.zeroplanethickness,
      zeroPlaneAlpha: chartAttrs.zeroplanealpha,
      showZeroPlaneValue: chartAttrs.showzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showyaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.yaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.yaxislinealpha, chartAttrs.axislinealpha, 100),
      base: chartAttrs.base,
      logBase: chartAttrs.logbase,
      axisLineColor: (0, _lib.pluck)(chartAttrs.yaxislinecolor, chartAttrs.axislinecolor, '#000000'),
      showMinorDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showminordivlinevalues, 0),
      numMinorDivLines: chartAttrs.numminordivlines
    };
    if (yAxisConf.base === '1') {
      yAxisConf.base = 10;
      yAxisConf.logBase = 10;
    }
    yAxisConf.minorDivlinecolor = (0, _lib.pluck)(chartAttrs.minordivlinecolor, yAxisConf.divLineColor);
    yAxisConf.minorDivLineThickness = (0, _lib.pluck)(chartAttrs.minordivlinethickness, 1);
    yAxisConf.minorDivLineAlpha = (0, _lib.pluck)(chartAttrs.minordivlinealpha, yAxisConf.divLineAlpha / 2);
    xAxisConf.vtrendlines = dataObj.vtrendlines;
    yAxisConf.trendlines = dataObj.trendlines;

    return {
      yAxisConf: [yAxisConf],
      xAxisConf: [xAxisConf]
    };
  };

  return MsLog;
}(_fusioncharts2['default']);

exports['default'] = MsLog;

/***/ }),

/***/ 368:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.errorLine': function initialDatasetErrorLine() {
    return {
      'path.appearing': function pathAppearing() {
        return [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          startEnd: {
            start: 0.5,
            end: 1
          },
          slot: 'plot'
        }];
      },
      '*': null
    };
  }
};

/***/ }),

/***/ 369:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(17);

var _msspline = __webpack_require__(45);

var _msspline2 = _interopRequireDefault(_msspline);

var _fusioncharts2 = __webpack_require__(52);

var _fusioncharts3 = _interopRequireDefault(_fusioncharts2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var Spline = function (_SSCartesian) {
  _inherits(Spline, _SSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  Spline.getName = function getName() {
    return 'Spline';
  };

  function Spline() {
    _classCallCheck(this, Spline);

    var _this = _possibleConstructorReturn(this, _SSCartesian.call(this));

    _this.defaultPlotShadow = 1;
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  Spline.prototype.getName = function getName() {
    return 'Spline';
  };
  /**
   * parse defualt configuration of the chart
   */


  Spline.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _SSCartesian.prototype.__setDefaultConfig && _SSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Spline Chart';
    config.singleseries = true;
    config.defaultDatasetType = 'msspline';
    config.minimizetendency = 0;
    config.zeroplanethickness = 1;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
    _fusioncharts._setDefaultConfig.call(this);
  };

  Spline.prototype.getDSdef = function getDSdef() {
    return _msspline2['default'];
  };

  return Spline;
}(_fusioncharts3['default']);

exports['default'] = Spline;

/***/ }),

/***/ 371:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(17);

var _msspline = __webpack_require__(45);

var _msspline2 = _interopRequireDefault(_msspline);

var _fusioncharts2 = __webpack_require__(16);

var _fusioncharts3 = _interopRequireDefault(_fusioncharts2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var MSSpline = function (_MSCartesian) {
  _inherits(MSSpline, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSSpline.getName = function getName() {
    return 'MSSpline';
  };

  function MSSpline() {
    _classCallCheck(this, MSSpline);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.defaultPlotShadow = 1;
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  MSSpline.prototype.getName = function getName() {
    return 'MSSpline';
  };
  /**
   * parse defualt configuration of the chart
   */


  MSSpline.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Multi-series Spline  Chart';
    config.defaultDatasetType = 'msspline';
    config.minimizetendency = 0;
    config.zeroplanethickness = 1;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
    _fusioncharts._setDefaultConfig.call(this);
  };

  MSSpline.prototype.getDSdef = function getDSdef() {
    return _msspline2['default'];
  };

  MSSpline.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  return MSSpline;
}(_fusioncharts3['default']);

exports['default'] = MSSpline;

/***/ }),

/***/ 372:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(52);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _waterfall2d = __webpack_require__(826);

var _waterfall2d2 = _interopRequireDefault(_waterfall2d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var WaterFall2D = function (_SSCartesian) {
  _inherits(WaterFall2D, _SSCartesian);

  function WaterFall2D() {
    _classCallCheck(this, WaterFall2D);

    return _possibleConstructorReturn(this, _SSCartesian.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  WaterFall2D.getName = function getName() {
    return 'WaterFall2D';
  };

  /**
   * Sets the name of the component
   * @return {string} name
   */


  WaterFall2D.prototype.getName = function getName() {
    return 'WaterFall2D';
  };

  WaterFall2D.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _SSCartesian.prototype.__setDefaultConfig && _SSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Waterfall Chart';
    config.singleseries = true;
    config.hasLegend = false;
    config.defaultDatasetType = 'Waterfall2D';
    config.enablemousetracking = true;
  };

  WaterFall2D.prototype.getDSdef = function getDSdef() {
    return _waterfall2d2['default'];
  };

  return WaterFall2D;
}(_fusioncharts2['default']);

exports['default'] = WaterFall2D;

/***/ }),

/***/ 373:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(842)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(235)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ 374:
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(77);
var dPs = __webpack_require__(845);
var enumBugKeys = __webpack_require__(307);
var IE_PROTO = __webpack_require__(205)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(253)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(309).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ 375:
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ 376:
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(78);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),

/***/ 377:
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ 378:
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(77);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ 379:
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(112);
var ITERATOR = __webpack_require__(24)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ 380:
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(234);
var ITERATOR = __webpack_require__(24)('iterator');
var Iterators = __webpack_require__(112);
module.exports = __webpack_require__(48).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ 381:
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(119)('meta');
var isObject = __webpack_require__(40);
var has = __webpack_require__(63);
var setDesc = __webpack_require__(60).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(62)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ 382:
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(40);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ 383:
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(24)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ 776:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _fusioncharts = __webpack_require__(360);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _fusioncharts3 = __webpack_require__(362);

var _fusioncharts4 = _interopRequireDefault(_fusioncharts3);

var _fusioncharts5 = __webpack_require__(779);

var _fusioncharts6 = _interopRequireDefault(_fusioncharts5);

var _fusioncharts7 = __webpack_require__(364);

var _fusioncharts8 = _interopRequireDefault(_fusioncharts7);

var _fusioncharts9 = __webpack_require__(366);

var _fusioncharts10 = _interopRequireDefault(_fusioncharts9);

var _fusioncharts11 = __webpack_require__(798);

var _fusioncharts12 = _interopRequireDefault(_fusioncharts11);

var _fusioncharts13 = __webpack_require__(799);

var _fusioncharts14 = _interopRequireDefault(_fusioncharts13);

var _fusioncharts15 = __webpack_require__(800);

var _fusioncharts16 = _interopRequireDefault(_fusioncharts15);

var _fusioncharts17 = __webpack_require__(801);

var _fusioncharts18 = _interopRequireDefault(_fusioncharts17);

var _fusioncharts19 = __webpack_require__(802);

var _fusioncharts20 = _interopRequireDefault(_fusioncharts19);

var _fusioncharts21 = __webpack_require__(803);

var _fusioncharts22 = _interopRequireDefault(_fusioncharts21);

var _fusioncharts23 = __webpack_require__(805);

var _fusioncharts24 = _interopRequireDefault(_fusioncharts23);

var _fusioncharts25 = __webpack_require__(808);

var _fusioncharts26 = _interopRequireDefault(_fusioncharts25);

var _fusioncharts27 = __webpack_require__(812);

var _fusioncharts28 = _interopRequireDefault(_fusioncharts27);

var _fusioncharts29 = __webpack_require__(815);

var _fusioncharts30 = _interopRequireDefault(_fusioncharts29);

var _fusioncharts31 = __webpack_require__(369);

var _fusioncharts32 = _interopRequireDefault(_fusioncharts31);

var _fusioncharts33 = __webpack_require__(817);

var _fusioncharts34 = _interopRequireDefault(_fusioncharts33);

var _fusioncharts35 = __webpack_require__(371);

var _fusioncharts36 = _interopRequireDefault(_fusioncharts35);

var _fusioncharts37 = __webpack_require__(819);

var _fusioncharts38 = _interopRequireDefault(_fusioncharts37);

var _fusioncharts39 = __webpack_require__(820);

var _fusioncharts40 = _interopRequireDefault(_fusioncharts39);

var _fusioncharts41 = __webpack_require__(821);

var _fusioncharts42 = _interopRequireDefault(_fusioncharts41);

var _fusioncharts43 = __webpack_require__(825);

var _fusioncharts44 = _interopRequireDefault(_fusioncharts43);

var _fusioncharts45 = __webpack_require__(372);

var _fusioncharts46 = _interopRequireDefault(_fusioncharts45);

var _fusioncharts47 = __webpack_require__(830);

var _fusioncharts48 = _interopRequireDefault(_fusioncharts47);

var _fusioncharts49 = __webpack_require__(837);

var _fusioncharts50 = _interopRequireDefault(_fusioncharts49);

var _fusioncharts51 = __webpack_require__(870);

var _fusioncharts52 = _interopRequireDefault(_fusioncharts51);

var _fusioncharts53 = __webpack_require__(878);

var _fusioncharts54 = _interopRequireDefault(_fusioncharts53);

var _fusioncharts55 = __webpack_require__(888);

var _fusioncharts56 = _interopRequireDefault(_fusioncharts55);

var _fusioncharts57 = __webpack_require__(18);

var _fusioncharts58 = _interopRequireDefault(_fusioncharts57);

var _crosslineAdapter = __webpack_require__(342);

var _crosslineAdapter2 = _interopRequireDefault(_crosslineAdapter);

var _multicanvasCrosslineManager = __webpack_require__(343);

var _multicanvasCrosslineManager2 = _interopRequireDefault(_multicanvasCrosslineManager);

var _mouseTracker_crossline = __webpack_require__(344);

var _mouseTracker_crossline2 = _interopRequireDefault(_mouseTracker_crossline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
_fusioncharts58['default'].addDep(_fusioncharts2['default']);
_fusioncharts58['default'].addDep(_fusioncharts4['default']);
_fusioncharts58['default'].addDep(_fusioncharts6['default']);
_fusioncharts58['default'].addDep(_fusioncharts8['default']);
_fusioncharts58['default'].addDep(_fusioncharts10['default']);
_fusioncharts58['default'].addDep(_fusioncharts12['default']);
_fusioncharts58['default'].addDep(_fusioncharts14['default']);
_fusioncharts58['default'].addDep(_fusioncharts16['default']);
_fusioncharts58['default'].addDep(_fusioncharts18['default']);
_fusioncharts58['default'].addDep(_fusioncharts20['default']);
_fusioncharts58['default'].addDep(_fusioncharts22['default']);
_fusioncharts58['default'].addDep(_fusioncharts24['default']);
_fusioncharts58['default'].addDep(_fusioncharts26['default']);
_fusioncharts58['default'].addDep(_fusioncharts28['default']);
_fusioncharts58['default'].addDep(_fusioncharts30['default']);
_fusioncharts58['default'].addDep(_fusioncharts32['default']);
_fusioncharts58['default'].addDep(_fusioncharts34['default']);
_fusioncharts58['default'].addDep(_fusioncharts36['default']);
_fusioncharts58['default'].addDep(_fusioncharts38['default']);
_fusioncharts58['default'].addDep(_fusioncharts40['default']);
_fusioncharts58['default'].addDep(_fusioncharts42['default']);
_fusioncharts58['default'].addDep(_fusioncharts44['default']);
_fusioncharts58['default'].addDep(_fusioncharts46['default']);
_fusioncharts58['default'].addDep(_fusioncharts48['default']);
_fusioncharts58['default'].addDep(_fusioncharts50['default']);
_fusioncharts58['default'].addDep(_fusioncharts52['default']);
_fusioncharts58['default'].addDep(_fusioncharts54['default']);
_fusioncharts58['default'].addDep(_fusioncharts56['default']);
_fusioncharts58['default'].addDep(_crosslineAdapter2['default']);
_fusioncharts58['default'].addDep(_multicanvasCrosslineManager2['default']);
_fusioncharts58['default'].addDep(_mouseTracker_crossline2['default']);
_fusioncharts58['default'].addFile('fusioncharts.powercharts.js');

exports['default'] = _fusioncharts58['default'];

/***/ }),

/***/ 777:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _columnMultiseries = __webpack_require__(15);

var _columnMultiseries2 = _interopRequireDefault(_columnMultiseries);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


/**
 * Group for drag column, area and line charts.
 */
var DragColumnMultiseriesGroup = function (_ColumnMultiSeriesgro) {
  _inherits(DragColumnMultiseriesGroup, _ColumnMultiSeriesgro);

  function DragColumnMultiseriesGroup() {
    _classCallCheck(this, DragColumnMultiseriesGroup);

    return _possibleConstructorReturn(this, _ColumnMultiSeriesgro.apply(this, arguments));
  }

  /**
  * Function to get the jsonData from the datasets
  * @return {Object} data from the dataset
  */
  DragColumnMultiseriesGroup.prototype.getJSONData = function getJSONData() {
    var manager = this,
        rawDatasets = manager.getFromEnv('dataSource').dataset,
        datasets = manager.getChildren('dataset'),
        jsonData = [],
        dataset,
        datasetObj,
        rawDataset,
        i,
        len = datasets.length;
    for (i = 0; i < len; i++) {
      dataset = datasets[i];
      rawDataset = (0, _lib.extend2)({}, rawDatasets[i]);
      // Here the actual data is deleted and modified data is fetched from each datasets
      delete rawDataset.data;
      datasetObj = dataset.getJSONData();
      jsonData.push((0, _lib.extend2)(rawDataset, datasetObj));
    }
    return jsonData;
  };

  return DragColumnMultiseriesGroup;
}(_columnMultiseries2['default']);

exports['default'] = DragColumnMultiseriesGroup;

/***/ }),

/***/ 778:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _areaAnimation = __webpack_require__(318);

var _areaAnimation2 = _interopRequireDefault(_areaAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.dataset.dragArea': _areaAnimation2['default']['initial.dataset.area']
};

/***/ }),

/***/ 779:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _dragline = __webpack_require__(780);

var _dragline2 = _interopRequireDefault(_dragline);

var _fusioncharts = __webpack_require__(362);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


/**
 * API class of dragcolumn inheriting from area class
 */
var DragLine = function (_DragArea) {
  _inherits(DragLine, _DragArea);

  function DragLine() {
    _classCallCheck(this, DragLine);

    return _possibleConstructorReturn(this, _DragArea.apply(this, arguments));
  }

  /**
   * Sets the name of the component
   * @return {string} name
   */
  DragLine.prototype.getName = function getName() {
    return 'DragLine';
  };
  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */


  DragLine.getName = function getName() {
    return 'DragLine';
  };

  /**
   * Function to parse chart specific configurations. It first calls the __setDefaultConfig of areabase class.
   */


  DragLine.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _DragArea.prototype.__setDefaultConfig && _DragArea.prototype.__setDefaultConfig.call(this);
    var chart = this,
        config = chart.config;
    config.isDrag = true;
    config.zeroplanethickness = 1;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
  };
  /**
   * Function to return the dataset liked with the current API
   * @return {Object} The DragLineDataset class
   */


  DragLine.prototype.getDSdef = function getDSdef() {
    return _dragline2['default'];
  };

  return DragLine;
}(_fusioncharts2['default']);

exports['default'] = DragLine;

/***/ }),

/***/ 780:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _dragarea = __webpack_require__(363);

var _lib = __webpack_require__(5);

var _dragcolumn = __webpack_require__(232);

var _dependencyManager = __webpack_require__(6);

var _draglineAnimation = __webpack_require__(781);

var _draglineAnimation2 = _interopRequireDefault(_draglineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */

(0, _dependencyManager.addDep)({
  name: 'dragLineAnimation',
  type: 'animationRule',
  extension: _draglineAnimation2['default']
});
/**
 * dataset class of dragcolumn inheriting from column class
 */

var DragLineDataset = function (_LineDataset) {
  _inherits(DragLineDataset, _LineDataset);

  function DragLineDataset() {
    _classCallCheck(this, DragLineDataset);

    return _possibleConstructorReturn(this, _LineDataset.apply(this, arguments));
  }

  /**
   * Using fireplotevent of dragarea.
   */
  DragLineDataset.prototype._firePlotEvent = function _firePlotEvent() {
    _dragarea.__firePlotEvent.apply(this, arguments);
  };

  /**
   * Function to update image while dragging.
   * @param {Object} dataObj The object by which the dataset is to be updated.
   */


  DragLineDataset.prototype.updateImage = function updateImage(dataObj) {
    _dragarea._updateImage.call(this, dataObj);
  };
  /**
   * Calling the configureAttributes of drag area.
   */


  DragLineDataset.prototype.configureAttributes = function configureAttributes() {
    _dragarea.configurer.apply(this, arguments);
  };
  /**
   * method to configure a particular data plot object
   * @param {number} i index of the data object to be configured
   * @param {Object} setData particular plot information in of i'th index in input json
   */


  DragLineDataset.prototype._plotConfigure = function _plotConfigure(i, setData) {
    var conf = this.config,
        dataStore = this.components.data,
        dataObj = void 0,
        config = void 0;
    _LineDataset.prototype._plotConfigure.call(this, i, setData);
    dataObj = dataStore[i];
    config = dataObj.config;
    config.allowDrag = (0, _lib.pluckNumber)(setData.allowdrag, conf.allowDrag);
    config.allowNegDrag = (0, _lib.pluckNumber)(setData.allownegativedrag, conf.allowNegDrag);
  };
  /**
   * Sets the type of the component
   * @return {string} type
   */


  DragLineDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  DragLineDataset.prototype.getName = function getName() {
    return 'dragLine';
  };
  /**
   * Function to restore the values of the dataset to its original
   */


  DragLineDataset.prototype.restore = function restore() {
    _dragcolumn._restore.call(this);
  };

  /**
   * Fucntion to get the updated values of data when they are dragged.
   * @return {Object} The corresponding data Array of the dataset containing the values of all the sets.
   */


  DragLineDataset.prototype.getJSONData = function getJSONData() {
    return _dragcolumn._getJSONData.call(this);
  };

  return DragLineDataset;
}(_line2['default']);

exports['default'] = DragLineDataset;

/***/ }),

/***/ 781:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lineAnimation = __webpack_require__(25);

var _lineAnimation2 = _interopRequireDefault(_lineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.dataset.dragLine': _lineAnimation2['default']['initial.dataset.line']
};

/***/ }),

/***/ 782:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.dragNode': function initialDatasetDragNode() {
    return {
      'node.appearing': function nodeAppearing() {
        return [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          slot: 'axis'
        }];
      }
    };
  }
};

/***/ }),

/***/ 783:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _dragnode = __webpack_require__(233);

var _dragnode2 = _interopRequireDefault(_dragnode);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _connectorAnimation = __webpack_require__(784);

var _connectorAnimation2 = _interopRequireDefault(_connectorAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var EVENTARGS = _lib.preDefStr.EVENTARGS,
    L = 'L',
    M = 'M',
    configStr = _lib.preDefStr.configStr,
    _getlinePath = function _getlinePath(connector) {
  var config = connector.config,
      fromPointObj = config.fromPointObj,
      toPointObj = config.toPointObj,
      fromX = config.fromX,
      fromY = config.fromY,
      toX = config.toX,
      toY = config.toY,
      path = [M, fromX, fromY],
      pointConfig;

  if (config.arrowAtStart) {
    pointConfig = fromPointObj.config;
    if (pointConfig.shapeType === _lib.SHAPE_RECT) {
      path = path.concat(DragNodeConnector._drawArrow(fromX, fromY, toX, toY, pointConfig.shapeArg.width, pointConfig.shapeArg.height));
    } else {
      path = path.concat(DragNodeConnector._drawArrow(fromX, fromY, toX, toY, pointConfig.shapeArg.radius));
    }
  }

  // Calculating path for connector Arrow
  if (config.arrowAtEnd) {
    pointConfig = toPointObj.config;
    if (pointConfig.shapeType === _lib.SHAPE_RECT) {
      path = path.concat(DragNodeConnector._drawArrow(toX, toY, fromX, fromY, pointConfig.shapeArg.width, pointConfig.shapeArg.height));
    } else {
      path = path.concat(DragNodeConnector._drawArrow(toX, toY, fromX, fromY, pointConfig.shapeArg.radius));
    }
  }
  path.push(L, toX, toY);
  return path;
},

/**
 * Helper function to create a RedRaphael group.
 * @param  {string} groupName                Name of the group to be created.
 * @param  {Element} parentContainer         The parent container in which the group will be appended.
 * @param {Object} dataset The concerned dataset
 * @return {Element}                         The group that was created.
 */
createGroup = function createGroup(groupName, parentContainer, dataset) {
  var animationManager = dataset.getFromEnv('animationManager');
  return animationManager.setAnimation({
    el: 'group',
    attr: { name: groupName },
    container: parentContainer,
    component: dataset,
    dom: 'group'
  });
};

(0, _dependencyManager.addDep)({
  name: 'connectorAnimation',
  type: 'animationRule',
  extension: _connectorAnimation2['default']
});
/**
 * dataset class of dragcolumn inheriting from column class
 */

var DragNodeConnector = function (_DragNodeDataset) {
  _inherits(DragNodeConnector, _DragNodeDataset);

  function DragNodeConnector() {
    _classCallCheck(this, DragNodeConnector);

    return _possibleConstructorReturn(this, _DragNodeDataset.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  DragNodeConnector.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  DragNodeConnector.prototype.getName = function getName() {
    return 'dragNodeConnector';
  };
  /**
    * Function for parsing all the attributes and value given by the user at chart and dataset level.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} if no datasetJSON is found
    */


  DragNodeConnector.prototype.configure = function configure(datasetJSON) {
    if (datasetJSON) {
      this.trimData(datasetJSON);
      this.config.JSONData = datasetJSON;
    } else if (!datasetJSON && !this.config.JSONData) {
      return false;
    }

    var connectors = this,

    // chartObj = connectors.chart,
    // rawData = connectors.jsonData,
    chartAttr = connectors.getFromEnv('chart-attrib'),
        conf = connectors.config,

    // dataStore = connectors.components.data || (connectors.components.data = []),
    // dataStoreLen,
    connectorsObj = connectors.config.JSONData,
        connectorsArr = connectorsObj.connector,
        length = connectorsArr && connectorsArr.length,
        index,

    // seriesConnector,
    HUNDRED = _lib.HUNDREDSTRING;

    conf.connectorsTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(connectorsObj.connectortooltext, chartAttr.connectortooltext)));

    // Extract attributes of this node.
    conf.stdThickness = (0, _lib.pluckNumber)(connectorsObj.stdthickness, 1);
    conf.conColor = (0, _lib.getFirstColor)((0, _lib.pluck)(connectorsObj.color, 'FF5904'));
    conf.conAlpha = (0, _lib.pluck)(connectorsObj.alpha, HUNDRED);
    conf.conDashGap = (0, _lib.pluckNumber)(connectorsObj.dashgap, 5);
    conf.conDashLen = (0, _lib.pluckNumber)(connectorsObj.dashlen, 5);
    conf.conDashed = Boolean((0, _lib.pluckNumber)(connectorsObj.dashed, 0));
    conf.arrowAtStart = Boolean((0, _lib.pluckNumber)(connectorsObj.arrowatstart, 1));
    conf.arrowAtEnd = Boolean((0, _lib.pluckNumber)(connectorsObj.arrowatend, 1));
    conf.conStrength = (0, _lib.pluckNumber)(connectorsObj.strength, 1);
    conf.toolTipSepChar = (0, _lib.pluck)(chartAttr.tooltipsepchar, ' - ');
    // seriesConnector = connectors.connector;
    conf.showTooltip = (0, _lib.pluckNumber)(chartAttr.showtooltip, 1);
    conf.viewMode = (0, _lib.pluckNumber)(chartAttr.viewmode, 1);

    // dataStoreLen = dataStore.length;

    // if (dataStoreLen > length) {
    //     dataStore.splice(length, dataStoreLen - length);
    // }
    conf._refreshData = true;
    for (index = 0; index < length; index += 1) {
      this._setConfigure(index, connectorsArr[index]);
    }
    conf._refreshData = true;
  };

  /**
   * Function for parsing all the attributes and value given by the user at set level.
   * @param {number} index The data index for which the configuration is to be parsed.
   * @param {Object} connectorObj It has the information of the data given by the user at the set level
   */


  DragNodeConnector.prototype._setConfigure = function _setConfigure(index, connectorObj) {
    // connector label.
    var connector = this,
        connectorStore = connector.components.data || (connector.components.data = []),
        connObj = connectorStore[index] || (connectorStore[index] = connectorStore[index] = {}),
        conf = connector.config,

    // chartObj = connector.chart,
    connectorLabel = (0, _lib.parseUnsafeString)((0, _lib.pluck)(connectorObj.label, connectorObj.name)),
        setConAlpha = (0, _lib.pluck)(connectorObj.alpha, conf.conAlpha),
        smartLabel = connector.getFromEnv('smartLabel'),
        tooltipSepChar = conf.toolTipSepChar,
        defToolTextMacro = '$fromLabel' + tooltipSepChar + '$toLabel',
        setConColor = {
      FCcolor: {
        color: (0, _lib.getFirstColor)((0, _lib.pluck)(connectorObj.color, conf.conColor)),
        alpha: setConAlpha
      }
    },
        toolText,
        config,
        labelTextObj,
        connectorsTooltext = conf.connectorsTooltext,
        connectorToolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(connectorObj.tooltext, connectorsTooltext))),
        boolCondition = Boolean((0, _lib.pluckNumber)(connectorObj.dashed, conf.conDashed));

    smartLabel.useEllipsesOnOverflow(connector.getFromEnv('chartConfig').useEllipsesWhenOverflow);
    labelTextObj = smartLabel.getOriSize(connectorLabel);
    config = connObj.config = connObj.config || (connObj.config = {});
    !connObj.graphics && (connObj.graphics = {});
    // create the tooltext
    if (!conf.showTooltip) {
      toolText = false;
    } else {
      // determine the tooltext then
      toolText = (0, _lib.pluck)(connectorToolText, connectorLabel ? '$label' : defToolTextMacro);
    }
    config = connObj.config = {
      _options: connectorObj,
      id: (0, _lib.pluck)(connectorObj.id, index).toString(),
      from: (0, _lib.pluck)(connectorObj.from, _lib.BLANK),
      to: (0, _lib.pluck)(connectorObj.to, _lib.BLANK),
      label: connectorLabel,
      toolText: toolText,
      customToolText: connectorToolText,
      color: setConColor,
      index: index,
      dashStyle: boolCondition ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(connectorObj.dashlen, conf.conDashLen), (0, _lib.pluckNumber)(connectorObj.dashgap, conf.conDashGap)) : _lib.DASH_DEF,
      dashed: connectorObj.dashed,
      dashlen: connectorObj.dashlen,
      dashgap: connectorObj.dashgap,
      arrowAtStart: Boolean((0, _lib.pluckNumber)(connectorObj.arrowatstart, conf.arrowAtStart)),
      arrowAtEnd: Boolean((0, _lib.pluckNumber)(connectorObj.arrowatend, conf.arrowAtEnd)),
      conStrength: (0, _lib.pluckNumber)(connectorObj.strength, conf.conStrength),
      link: connectorObj.link,
      stdThickness: conf.stdThickness,
      labelWidth: labelTextObj.widht,
      labelHeight: labelTextObj.height
    };
    config.datasetIndex = connector.index;
    config.add = connectorObj.add;
    config.update = connectorObj.update;
    if (conf._refreshData) {
      delete connObj.removed;
    }
  };

  /**
   * Function to create container at the dataset level
   */


  DragNodeConnector.prototype.createContainer = function createContainer() {
    var dataset = this,
        parentContainer = dataset.getLinkedParent().getChildContainer();

    !dataset.getContainer('connectorGroup') && dataset.addContainer('connectorGroup', createGroup('connectorGroup', parentContainer.connectorGroup, dataset));

    !dataset.getContainer('connectorDataLabelGroup') && dataset.addContainer('connectorDataLabelGroup', createGroup('connectorDataLabelGroup', parentContainer.connectorGroup, dataset));
  };

  /**
   * Function ot draw the entire dataset
   */


  DragNodeConnector.prototype.draw = function draw() {
    var connectors = this,

    // chart = connectors.chart,
    manager = connectors.getLinkedParent(),
        conf = connectors.config,

    // chartObj = connectors.chart,
    // chartComp = chartObj.components,
    // chartGraphics = chart.graphics,
    // nodes = manager.nodes,
    connectorStore = connectors.components.data,
        connector,
        fromId,
        toId,

    // paper = connectors.getFromEnv('paper'),
    // jobList = chart.getJobList(),
    // datasetGroup = chartGraphics.datasetGroup,
    fromPointObj,
        toPointObj,
        style = connectors.getFromEnv('dataLabelStyle'),

    // graphics,
    i,
        length = connectorStore.length,
        removeDataArr = connectors.components.removeDataArr || [],
        removeDataArrLen = removeDataArr.length,

    // connectorsGroup,
    config;

    // if (!connectorsGroup) {
    //     connectorsGroup = connectors.graphics.connectorGroup =
    //         connectors.graphics.connectorGroup || paper.group('connectorGroup').insertBefore(datasetGroup);
    // }

    connectors.createContainer();
    // connectorsGroup = connectors.getContainer('connectorGroup');

    // if (conf.showTooltip) {
    //   connectorsGroup.trackTooltip(true);
    // }
    conf.cleared = false;
    connectors.getContainer('connectorDataLabelGroup').css(style);
    for (i = 0; i < length; i++) {
      connector = connectorStore[i];
      config = connector.config;
      // graphics = connector.graphics || (connector.graphics = {});
      fromId = config.from;
      toId = config.to;
      fromPointObj = manager.getNode(fromId);
      toPointObj = manager.getNode(toId);
      if (fromPointObj && toPointObj && config.deleted !== true) {
        connectors.drawConnector(connector, fromPointObj, toPointObj, i);
      }
    }
    // For first time render label is drawn in a separate thread
    // connectors.drawn !== true && jobList.labelDrawID.push(schedular.addJob(function () {
    // connectors.drawLabel();
    // }, lib.priorityList.label));
    connectors.config.drawn = true;

    for (i = 0; i < removeDataArrLen; i++) {
      connectors._removeDataVisuals(removeDataArr.shift());
    }
  };

  /**
   * Parsing and calculation of attributes takes place
   *
   * @param {any} connector connector
   * @param {any} fromPointObj from node
   * @param {any} toPointObj to node
   * @memberof DragNodeConnector
   */


  DragNodeConnector.prototype.parsePlotAttributes = function parsePlotAttributes(connector, fromPointObj, toPointObj) {
    var dataset = this,
        fromX,
        toX,
        fromY,
        toY,
        strokeWidth,
        NumberFormatter = dataset.getFromEnv('number-formatter'),
        pathArr,
        startConnectors,
        endConnectors,
        config = connector.config,
        fromConf,
        toConf,
        eventArgs = config.eventArgs || (config.eventArgs = {}),
        color,
        id;

    config.fromPointObj = fromPointObj;
    config.toPointObj = toPointObj;
    fromConf = fromPointObj.config;
    toConf = toPointObj.config;
    config.fromX = fromX = fromConf._xPos;
    config.fromY = fromY = fromConf._yPos;
    config.toX = toX = toConf._xPos;
    config.toY = toY = toConf._yPos;
    config._labelX = (fromX + toX) / 2;
    config._labelY = (fromY + toY) / 2;
    config.strokeWidth = strokeWidth = config.conStrength * config.stdThickness;
    color = config.color;
    config.textBgColor = color && color.FCcolor && color.FCcolor.color;
    eventArgs.label = config.label;
    eventArgs.arrowAtStart = config.arrowAtStart;
    eventArgs.arrowAtEnd = config.arrowAtEnd;
    eventArgs.link = config.link;
    eventArgs.id = config.id;
    eventArgs.fromNodeId = fromConf.id;
    eventArgs.toNodeId = toConf.id;
    config.toolText = (0, _lib.parseTooltext)(config.toolText, [3, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92], {
      label: config.label,
      fromXValue: NumberFormatter.dataLabels(fromPointObj.config.x),
      fromYValue: NumberFormatter.dataLabels(fromPointObj.config.y),
      fromXDataValue: fromPointObj.config.x,
      fromYDataValue: fromPointObj.config.y,
      fromLabel: (0, _lib.pluck)(fromPointObj.config.displayValue, fromPointObj.config.id),
      toXValue: NumberFormatter.dataLabels(toPointObj.config.x),
      toYValue: NumberFormatter.dataLabels(toPointObj.config.y),
      toXDataValue: toPointObj.config.x,
      toYDataValue: toPointObj.config.y,
      toLabel: (0, _lib.pluck)(toPointObj.config.displayValue, toPointObj.config.id)
    });

    fromConf = fromPointObj.config;
    toConf = toPointObj.config;

    startConnectors = fromConf.startConnectors;
    endConnectors = toConf.endConnectors;

    id = connector.config.id + '-' + fromConf.id + '-' + toConf.id;

    startConnectors[id] = connector;
    endConnectors[id] = connector;

    pathArr = _getlinePath(connector);
    config.props = {
      element: {
        attr: {
          path: pathArr,
          'stroke-width': strokeWidth,
          ishot: true,
          'stroke-dasharray': config.dashStyle,
          cursor: config.link ? _lib.POINTER : _lib.BLANKSTRING,
          stroke: (0, _lib.toRaphaelColor)(color)
        }
      }
    };
  };
  /**
   * Parse attributes and calculates position during post space management
   *
   * @memberof DragNodeConnector
   */


  DragNodeConnector.prototype.allocatePosition = function allocatePosition() {
    var connectors = this,
        i,
        connector,
        config,
        fromId,
        toId,
        fromPointObj,
        toPointObj,
        manager = connectors.getLinkedParent(),
        connectorStore = connectors.components.data,
        len = connectorStore.length;

    for (i = 0; i < len; i++) {
      connector = connectorStore[i];
      config = connector.config;
      // graphics = connector.graphics || (connector.graphics = {});
      fromId = config.from;
      toId = config.to;
      fromPointObj = manager.getNode(fromId);
      toPointObj = manager.getNode(toId);
      if (fromPointObj && toPointObj && config.deleted !== true) {
        connectors.parsePlotAttributes(connector, fromPointObj, toPointObj, i);
      }
    }
  };
  /**
   * Function to draw individual connectors
   * @param {Object} connector Object having information about the connector that is to be drawn
   * @param {Object} fromPointObj Object having the information about the node from which the connector is to be drawn
   * @param {Object} toPointObj Object having the information about the node to which the connector is to be drawn
   */


  DragNodeConnector.prototype.drawConnector = function drawConnector(connector) {
    var dataset = this,
        toolTipController = dataset.getFromEnv('toolTipController'),
        animationManager = dataset.getFromEnv('animationManager'),
        graphics = connector.graphics,
        element,
        elementCheck,
        connectorsGroup = dataset.getContainer('connectorGroup'),
        config = connector.config,
        tooltext = config.toolText,
        eventArgs = config.eventArgs || (config.eventArgs = {}),
        conf = dataset.config,
        pool = dataset.components.pool || {};

    element = elementCheck = graphics.graphic;
    if (!graphics.graphic) {
      if (pool.graphic && pool.graphic.path && pool.graphic.path.length) {
        elementCheck = graphics.graphic = pool.graphic.path.shift();
      }
    }
    // draw the line
    element = animationManager.setAnimation({
      el: elementCheck || 'path',
      container: connectorsGroup,
      attr: config.props.element.attr,
      dom: 'path',
      component: dataset
    });
    if (!elementCheck) {
      graphics.graphic = element;
      element.mousedown(dataset.mouseDown).mousemove(dataset.mousemove).mouseup(dataset.mouseup).hover(dataset.hoverIn, dataset.hoverOut);
    }
    element.show().data(EVENTARGS, eventArgs).data('viewMode', conf.viewMode).data(configStr, config).data('dataset', dataset);
    conf.showTooltip ? toolTipController.enableToolTip(element, tooltext) : toolTipController.disableToolTip(element);
    // If this is not the first render then label is drawn instantly otherwise it is drawn in
    // another thread for performance optimization
    dataset.drawLabel(connector);
  };

  /**
   * Function to draw individual labels of the connector
   * @param {Object} connector Object having information about the connector whose label is to be drawn
   */


  DragNodeConnector.prototype.drawLabel = function drawLabel(connector) {
    var dataset = this,
        toolTipController = dataset.getFromEnv('toolTipController'),

    // groupManager = dataset.groupManager,
    // nodes = groupManager.nodes,
    conf = dataset.config,
        animationManager = dataset.getFromEnv('animationManager'),

    // chart = dataset.chart,
    // animationObj = chart.get('config', 'animationObj'),
    connectorsGroup = dataset.getContainer('connectorDataLabelGroup'),

    // dummyAnimObj = animationObj.animObj,
    // dummyAnimElem = animationObj.dummyObj,
    // animType = animationObj.animType,
    // animationDuration = animationObj.duration,
    config,
        label,
        tooltext,
        labelAttrs,
        style = dataset.getFromEnv('dataLabelStyle'),
        labelElement,
        labelElementCheck,
        graphics,
        connectorObj,
        i,
        labelX,
        labelY,
        textBgColor,
        dataStore = dataset.components.data,
        pool = dataset.components.pool || {},
        len = dataStore.length,

    // fromPointObj,
    // toPointObj,
    // fromId,
    // toId,
    drawIndividualLabel = function drawIndividualLabel(connector) {
      config = connector.config;
      tooltext = config.toolText;
      graphics = connector.graphics;
      label = config.label;
      labelX = config._labelX;
      labelY = config._labelY;
      // fromId = config.from;
      // toId = config.to;
      // fromPointObj = nodes[fromId];
      // toPointObj = nodes[toId];
      textBgColor = config.textBgColor;

      if (label) {
        labelElementCheck = graphics.text = graphics.text || pool.element && pool.element.text && pool.element.text.shift();
        labelAttrs = {
          text: label,
          fill: style.color,
          ishot: true,
          direction: _lib.BLANKSTRING,
          cursor: config.link ? _lib.POINTER : _lib.BLANKSTRING,
          'text-bound': [(0, _lib.pluck)(style.backgroundColor, textBgColor), (0, _lib.pluck)(style.borderColor, textBgColor), 1, '2'],
          x: labelX,
          y: labelY
        };

        // Drawing the connector Label
        labelElement = animationManager.setAnimation({
          el: labelElementCheck || 'text',
          attr: labelAttrs,
          container: connectorsGroup,
          dom: 'text',
          component: dataset
        });
        labelElement.show();
        if (!labelElementCheck) {
          graphics.text = labelElement;
          labelElement.mousedown(dataset.mouseDown).mousemove(dataset.mousemove).mouseup(dataset.mouseup).hover(dataset.hoverIn, dataset.hoverOut);
        }
        labelElement.data(EVENTARGS, config.eventArgs).data('viewMode', conf.viewMode).data(configStr, config).data('dataset', dataset);
        conf.showTooltip ? toolTipController.enableToolTip(labelElement, tooltext) : toolTipController.disableToolTip(labelElement);
      } else {
        graphics.text && graphics.text.hide();
      }
    };

    if (connector) {
      drawIndividualLabel(connector);
    } else {
      for (i = 0; i < len; i++) {
        connectorObj = dataStore[i];
        drawIndividualLabel(connectorObj);
      }
    }
  };

  /**
   * Callback function when mouse is pressed down over the connector
   */


  DragNodeConnector.prototype.mouseDown = function mouseDown() {
    var ele = this,

    // config = ele.data(configStr),
    dataset = ele.data('dataset'),
        manager = dataset.getLinkedParent();
    // chart = dataset.chart,
    // conf = dataset.config,
    // options = config || {};

    manager.clearLongPress();

    // Whether to fire the click event ot not
    ele.data('fire_click_event', 1);
    manager.triggerConnectorUI(ele);
  };

  /**
   * Callback function when mouse is moved over a connector
   */


  DragNodeConnector.prototype.mousemove = function mousemove() {
    var ele = this,
        dataset = ele.data('dataset'),
        manager = dataset.getLinkedParent();
    // Whether to fire the click event ot not
    ele.data('fire_click_event', 0);
    manager.clearLongPress();
  };

  /**
   * Callback function mouse press is released from over a connector
   */


  DragNodeConnector.prototype.mouseup = function mouseup() {
    var ele = this,
        dataset = ele.data('dataset'),
        manager = dataset.getLinkedParent();

    manager.clearLongPress();
    // plotEventHandler.call(ele, chart, data, 'ConnectorClick');
  };

  // hoverIn(data) {
  //   var ele = this,
  //     dataset = ele.data('dataset'),
  //     chart = dataset.chart;
  //   plotEventHandler.call(ele, chart, data, 'ConnectorRollover');
  // }

  // hoverOut(data) {
  //   var ele = this,
  //     dataset = ele.data('dataset'),
  //     chart = dataset.chart;
  //   plotEventHandler.call(ele, chart, data, 'ConnectorRollout');
  // }

  /**
   * Function to draw arrow heads for the connectors
   * @param {number} X1 The required dimenions for drawing the arrow head
   * @param {number} Y1 The required dimenions for drawing the arrow head
   * @param {number} X2 The required dimenions for drawing the arrow head
   * @param {number} Y2 The required dimenions for drawing the arrow head
   * @param {number} R The required dimenions for drawing the arrow head
   * @param {number} H The required dimenions for drawing the arrow head
   * @return {Array} contains the path coordinates
   */


  DragNodeConnector._drawArrow = function _drawArrow(X1, Y1, X2, Y2, R, H) {
    var tanganent = (Y1 - Y2) / (X1 - X2),
        angle = Math.atan(tanganent),
        PX,
        PY,
        RHlf,
        HHlf,
        arr = [];

    // make all angle as positive
    if (angle < 0) {
      angle = 2 * Math.PI + angle;
    }
    if (Y2 > Y1) {
      // PI >angle > 0
      if (X2 >= X1 && angle > Math.PI || X2 < X1 && angle > Math.PI) {
        angle = angle - Math.PI;
      }
    } else {
      /// PI <= angle < 360 || angle == 0
      // angle may not be 360 in that case it will be 0 as atan work
      if (X2 >= X1 && angle < Math.PI && angle !== 0 || X2 < X1 && angle < Math.PI) {
        angle = angle + Math.PI;
      }
    }

    if (typeof H === 'undefined') {
      // arrow start point
      PX = X1 + R * Math.cos(angle);
      PY = Y1 + R * Math.sin(angle);
    } else {
      // rectangle
      RHlf = Math.abs(R) / 2;
      HHlf = Math.abs(H) / 2;

      // asume it will intersect a vertical side
      PX = X1 + (RHlf = X1 < X2 ? RHlf : -RHlf);
      PY = Y1 + RHlf * Math.tan(angle);
      // validate PY
      // if not validate then it will cross the horizontal axis
      if (Math.abs(Y1 - PY) > Math.abs(HHlf)) {
        PY = Y1 + (HHlf = Y1 < Y2 ? HHlf : -HHlf);
        PX = X1 + HHlf / Math.tan(angle);
      }
    }

    arr.push(L, PX, PY,
    // arrowone half
    PX + 10 * Math.cos(angle + 0.79), PY + 10 * Math.sin(angle + 0.79),
    // arrowone half
    M, PX + 10 * Math.cos(angle - 0.79), PY + 10 * Math.sin(angle - 0.79),
    // return to th eedege
    L, PX, PY);

    return arr;
  };

  /**
   * Function to remove data during update if number of data has reduced than the previous render
   * @param {number} index The data index from which data has to be removed.
   * @param {number} stretch The index upto which data has to be removed
   */


  DragNodeConnector.prototype.removeData = function removeData(index, stretch) {
    var dataset = this,
        components = dataset.components,
        dataStore = components.data;

    if (index < 0) {
      index = 0;
    }
    components.removeDataArr = dataStore.splice(index, stretch);
  };

  /**
   * function to Remove data plots if the number of current data plots/categories
   * is more than the existing ones.
   * @param  {Object} datasetJSON JSON for dataset configurations
   */


  DragNodeConnector.prototype.trimData = function trimData(datasetJSON) {
    if (!this.config.JSONData) {
      return;
    }
    var dataSet = this,
        prevData = dataSet.config.JSONData,
        prevDataLength = prevData.connector && prevData.connector.length,
        currDataLength = datasetJSON.connector && datasetJSON.connector.length || 0,
        dataDiff = prevDataLength - currDataLength;

    // Removing data plots if the number of current data plots/categories
    // is more than the existing ones.
    if (dataDiff > 0) {
      dataSet.removeData(currDataLength, dataDiff);
    }
  };

  return DragNodeConnector;
}(_dragnode2['default']);

exports['default'] = DragNodeConnector;

/***/ }),

/***/ 784:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.dragNodeConnector': function initialDatasetDragNodeConnector() {
    return {
      'path.appearing': function pathAppearing() {
        return [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          slot: 'plot'
        }];
      },
      'text.appearing': function textAppearing() {
        return [{
          initialAttr: {
            opacity: 0,
            'text-bound': 'none'
          },
          finalAttr: {
            opacity: 1
          },
          slot: 'final'
        }];
      },
      '*': null
    };
  }
};

/***/ }),

/***/ 785:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.dragNodeLabels': function initialDatasetDragNodeLabels() {
    return {
      'group.appearing': function groupAppearing() {
        return [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          slot: 'plot'
        }];
      }
    };
  }
};

/***/ }),

/***/ 786:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(11);

var _assign2 = _interopRequireDefault(_assign);

var _componentInterface = __webpack_require__(7);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _dom = __webpack_require__(250);

var _dom2 = _interopRequireDefault(_dom);

var _dragablelabels = __webpack_require__(365);

var _dragablelabels2 = _interopRequireDefault(_dragablelabels);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var CLEAR_TIME_1000 = 1000,
    shapesInfo = {
  circle: 'circ',
  rectangle: 'rect',
  polygon: 'poly'
},
    INPUT = _lib.preDefStr.INPUT,
    BLANKSPACE = _lib.preDefStr.BLANKSPACE,
    BLANK = _lib.preDefStr.BLANK,
    NORMALSTRING = _lib.preDefStr.NORMALSTRING,
    COLOR_FFFFFF = 'ffffff',
    PX = _lib.preDefStr.PX,
    COLOR_000000 = '000000',
    OPTIONSTR = '<option>',
    OPTIONCLOSESTR = '</option>',
    LABEL = _lib.preDefStr.LABEL,
    DATASET = _lib.preDefStr.DATASET,
    COMMA = _lib.preDefStr.COMMA,
    defined = function defined(obj) {
  return obj !== undefined && obj !== null;
},
    _showNodeUpdateUI = function () {
  var manageShapeFields = function manageShapeFields() {
    var ui = this.getGraphicalElement('cacheUpdateUI'),
        fields = ui.fields,
        ele = fields.shape,
        shapeFields = ['rectWidth', 'rectHeight', 'circPolyRadius', 'polySides'],
        i = shapeFields.length,
        key;

    while (i--) {
      key = shapeFields[i];
      if (/rect|poly|circ/ig.test(key)) {
        ui.labels[key].hide();
        ui.fields[key].hide();
      }
      if (new RegExp((0, _lib.pluck)(ele.val(), 'rect'), 'ig').test(key)) {
        ui.labels[key].show();
        ui.fields[key].show();
      }
    }
  },
      showGivenColor = function showGivenColor() {
    var ui = this.getGraphicalElement('cacheUpdateUI'),
        fields = ui.fields,
        color = _lib.graphics.getValidColor(fields.color.val());

    color && fields.colorOut.css({
      background: _lib.graphics.parseColor(color)
    });
  },
      manageImageFields = function manageImageFields(animate) {
    var manager = this,
        ui = manager.getGraphicalElement('cacheUpdateUI'),
        fields = ui.fields,
        ele = fields.image,
        chartHeight = manager.getFromEnv('chartConfig').height,
        padding = 5,
        isChecked = ele.val(),
        animation = animate ? 300 : 0,
        imgKey = ['imgWidth', 'imgHeight', 'imgAlign', 'imgUrl'],
        dialogHeight,
        i,
        key;

    dialogHeight = isChecked ? 250 : 215;

    ui.ok.hide();
    ui.cancel.hide();
    ui.removeItem.hide();
    ui.error.hide();
    i = imgKey.length;
    while (!isChecked && i--) {
      key = imgKey[i];
      ui.labels[key].hide();
      ui.fields[key].hide();
    }

    _dom2['default'].animate(ui.dialog.element, {
      top: (chartHeight - dialogHeight) / 2,
      height: dialogHeight
    }, animation, 'linear', function () {
      i = imgKey.length;
      while (i-- && isChecked) {
        key = imgKey[i];
        ui.labels[key].show();
        ui.fields[key].show();
      }
      ui.ok.attr({
        y: dialogHeight - 23 - padding
      }).show();
      ui.cancel.attr({
        y: dialogHeight - 23 - padding
      }).show();
      ui.removeItem.attr({
        y: dialogHeight - 23 - padding
      });
      ui.error.attr({
        y: dialogHeight - 23 - padding + 4
      }).show();
      if (ui.edit) {
        ui.removeItem.show();
      } else {
        ui.removeItem.hide();
      }
    });
  };

  return function (config, edit) {
    var manager = this,

    // graphics = manager.graphics,
    ui = manager.getGraphicalElement('cacheUpdateUI'),

    // nodes = manager.nodes,
    // conf = chart.config,
    animation = manager.getFromEnv('chartConfig').animation,
        inCanvasStyle = manager.getFromEnv('style').inCanvasStyle || {},
        paper = manager.getFromEnv('paper'),
        borderStyle = '1px solid #cccccc',
        inputStyle = {
      width: 80 + PX,
      border: borderStyle,
      fontSize: 10 + PX,
      lineHeight: 15 + PX,
      padding: 2 + PX,
      fontFamily: inCanvasStyle.fontFamily
    },
        labelStyle = {
      textAlign: 'right'
    },
        fields = ui && ui.fields,
        labels = ui && ui.labels,
        dialog,

    // node,
    // index,
    onSubmit = function onSubmit() {
      var fields = ui && ui.fields,
          edit = ui.edit,

      // chart = manager.chart,
      // components = chart.components,
      xMin,
          yMin,

      // datasets,
      // sLn,
      idFound,
          id,
          submitObj,
          shapeType;

      xMin = manager.getFromEnv('xAxis').getLimit().min;
      yMin = manager.getFromEnv('yAxis').getLimit().min;
      // datasets = manager.datasets;
      // sLn = datasets.length;

      if (fields) {
        switch (fields.shape.val()) {
          case 'circ':
            shapeType = _lib.preDefStr.CIRCLE;
            break;
          case 'poly':
            shapeType = _lib.preDefStr.POLYGON;
            break;
          default:
            shapeType = _lib.preDefStr.RECTANGLE;
            break;
        }

        submitObj = {
          x: (0, _lib.getFirstValue)(fields.x.val(), xMin),
          y: (0, _lib.getFirstValue)(fields.y.val(), yMin),
          id: id = fields.id.val(),
          datasetId: fields.dataset.val(),
          name: fields.label.val(),
          tooltext: fields.tooltip.val(),
          color: fields.color.val(),
          alpha: fields.alpha.val(),
          labelalign: fields.labelalign.val(),
          allowdrag: fields.draggable.val(),
          shape: shapeType,
          width: fields.rectWidth.val(),
          height: fields.rectHeight.val(),
          radius: fields.circPolyRadius.val(),
          numsides: fields.polySides.val(),
          imagenode: fields.image.val(),
          imagewidth: fields.imgWidth.val(),
          imageheight: fields.imgHeight.val(),
          imagealign: fields.imgAlign.val(),
          imageurl: fields.imgUrl.val(),
          link: fields.link.val()
        };

        // Check if node already exists
        if (manager.getNode(submitObj.id)) {
          idFound = true;
        }

        // If node already exists then we do not add a node and show an error
        if (!idFound || edit !== undefined) {
          // node = nodes[submitObj.id] || {};
          id = submitObj.datasetId;
          // Dont add nodes when dataset id is not given
          if (id !== _lib.BLANKSTRING || edit) {
            id = Number(id);
            // index = node.config && node.config.index;
            edit ? manager.updateNode(submitObj) : manager.addNode(submitObj);
            ui.hide();
            ui.visible = false;
          }
          return;
        } else {
          ui.error.attr({
            text: 'ID already exist.'
          });
          fields.label.focus();
        }
      }
      // Remobe disabled from attr
      ui.enableFields();
    },
        onCancel = function onCancel() {
      // Hide the UI
      ui.hide();
      ui.visible = false;
      // Remobe disabled from attr
      ui.enableFields();
      // Hide error msg
      ui.error.attr({
        text: BLANK
      });
      ui.visible = false;
    },
        onDelete = function onDelete() {
      manager.deleteNode(ui.fields.id.val());
      ui.hide();
      ui.visible = false;
    };

    if (!ui) {
      ui = manager.addGraphicalElement('cacheUpdateUI', this.createHtmlDialog(350, 215, onSubmit, onCancel, onDelete));
      // add fields.
      dialog = ui.dialog;
      labels = ui.labels = {};
      fields = ui.fields = {};
    }
    ui.config = config;
    ui.edit = edit;
    if (!ui.error) {
      ui.error = paper.html('span', {
        color: 'ff0000',
        x: 30,
        y: 228
      }, undefined, dialog);
    }
    if (!ui.enableFields) {
      ui.enableFields = function () {
        var key;
        for (key in config) {
          if (config[key] && config[key].disabled && fields[key]) {
            fields[key].element.removeAttribute('disabled');
          }
        }
      };
    }
    if (!ui.clearFields) {
      ui.clearFields = function () {
        var key,
            fields = ui.fields;
        for (key in fields) {
          if (!fields[key].element.disabled) {
            fields[key].element.value = _lib.BLANKSTRING;
          }
        }
      };
    }

    (0, _lib.fcEach)(this.nodeUpdateUIDefinition, function (def) {
      var field,
          key = def.key,
          attrs = {},
          confObj = config[key] || {},
          innerHTML,
          value;

      !labels[key] && (labels[key] = paper.html(LABEL, {
        x: def.x,
        y: def.y,
        width: def.labelWidth || 45,
        text: def.text
      }, labelStyle, dialog));

      // No need to proceed of this label has no input box
      // associated with itself.
      if (def.noInput) {
        return;
      }

      field = fields[key];

      if (!field) {
        inputStyle.border = def.type == 'checkbox' ? BLANK : borderStyle;
        field = fields[key] = paper.html(def.inputType || 'input', {
          x: def.labelWidth && def.labelWidth + 5 || 50,
          y: -2 + (def.inputPaddingTop || 0),
          width: def.inputWidth || 50,
          name: key || _lib.BLANKSTRING
        }, inputStyle);

        if (def.inputType !== 'select') {
          field.attr({
            type: def.type || 'text'
          }).on('keyup', ui.handleKeyPress);
        }
        field.add(labels[key]);
      }

      if (defined(innerHTML = (0, _lib.getFirstValue)(confObj.innerHTML, def.innerHTML))) {
        attrs.innerHTML = innerHTML;
      }
      if (confObj.disabled) {
        attrs.disabled = 'disabled';
      } else {
        field.element && (field.element.disabled = false);
      }
      field.attr(attrs);
      if (defined(value = (0, _lib.getFirstValue)(confObj.value, def.value))) {
        field.val(value);
      }

      key == 'shape' && field.on('change', function () {
        manageShapeFields.call(manager);
      });
      key == 'image' && field.on('click', function () {
        manageImageFields.call(manager, true);
      });
      key == 'color' && field.on('keyup', function () {
        showGivenColor.call(manager);
      });
    });

    showGivenColor.call(this);
    manageImageFields.call(this);
    manageShapeFields.call(this);
    if (animation) {
      ui.fadeIn('fast');
    } else {
      ui.show();
    }
    ui.visible = true;
    ui.fields[edit ? LABEL : 'id'].focus();
  };
}();

/**
 * Class for dragnodes's group
 */

var DragNodeGroup = function (_ComponentInterface) {
  _inherits(DragNodeGroup, _ComponentInterface);

  /**
   * constructor function this class
   */
  function DragNodeGroup() {
    _classCallCheck(this, DragNodeGroup);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    var manager = _this;
    manager.setState('visible', true);
    manager.connectorUpdateUIDefinition = [{
      key: 'fromid',
      text: 'Connect From',
      inputType: 'select',
      x: 10,
      y: 15,
      labelWidth: 80,
      inputWidth: 100
    }, {
      key: 'toid',
      text: 'Connect To',
      inputType: 'select',
      x: 10,
      y: 40,
      labelWidth: 80,
      inputWidth: 100
    }, {
      key: 'arratstart',
      text: 'Arrow At Start',
      x: 200,
      y: 15,
      type: 'checkbox',
      inputPaddingTop: 3,
      labelWidth: 80,
      inputWidth: 15
    }, {
      key: 'arratend',
      text: 'Arrow At End',
      x: 200,
      y: 40,
      type: 'checkbox',
      inputPaddingTop: 3,
      labelWidth: 80,
      inputWidth: 15
    }, {
      key: LABEL,
      text: 'Label',
      x: 10,
      y: 75,
      labelWidth: 40,
      inputWidth: 120
    }, {
      key: 'id',
      text: 'Node ID',
      x: 190,
      y: 75,
      inputWidth: 55
    }, {
      key: 'color',
      text: 'Color',
      x: 10,
      y: 100,
      labelWidth: 40,
      inputWidth: 35
    }, {
      key: 'alpha',
      text: 'Alpha',
      x: 110,
      y: 100,
      inputWidth: 25,
      labelWidth: 35
    }, {
      key: 'strength',
      text: 'Strength',
      x: 190,
      y: 100,
      inputWidth: 55,
      val: '0.1'
    }, {
      key: 'url',
      text: 'Link',
      x: 10,
      y: 125,
      labelWidth: 40,
      inputWidth: 120
    }, {
      key: 'tooltext',
      text: 'Tooltip',
      x: 190,
      y: 125,
      labelWidth: 40,
      inputWidth: 60
    }, {
      key: 'dashed',
      text: 'Dashed',
      x: 10,
      y: 150,
      type: 'checkbox',
      inputPaddingTop: 3,
      inputWidth: 15,
      labelWidth: 40
    }, {
      key: 'dashgap',
      text: 'Dash Gap',
      x: 85,
      y: 150,
      labelWidth: 60,
      inputWidth: 25
    }, {
      key: 'dashlen',
      text: 'Dash Length',
      x: 190,
      y: 150,
      labelWidth: 70,
      inputWidth: 30
    }];
    manager.nodeUpdateUIDefinition = [{
      key: 'id',
      text: 'Id',
      inputWidth: 60,
      x: 10,
      y: 15
    }, {
      key: DATASET,
      text: DATASET,
      inputType: 'select',
      inputWidth: 110,
      innerHTML: undefined,
      x: 170,
      y: 15
    }, {
      key: 'x',
      text: 'Value',
      x: 10,
      y: 40,
      inputWidth: 21
    }, {
      key: 'y',
      text: COMMA,
      x: 88,
      y: 40,
      inputWidth: 21,
      labelWidth: 5
    }, {
      text: '(x, y)',
      x: 125,
      y: 40,
      labelWidth: 33,
      noInput: true
    }, {
      key: 'tooltip',
      text: 'Tooltip',
      inputWidth: 105,
      x: 170,
      y: 40
    }, {
      key: LABEL,
      text: 'Label',
      inputWidth: 92,
      x: 10,
      y: 65
    }, {
      key: 'labelalign',
      text: 'Align',
      labelWidth: 70,
      inputWidth: 110,
      inputType: 'select',
      innerHTML: '<option></option><option value="top">Top</option><option value="middle">Middle</option>' + '<option value="bottom">Bottom</option>',
      x: 145,
      y: 63
    }, {
      key: 'color',
      text: 'Color',
      x: 10,
      y: 90,
      inputWidth: 60
    }, {
      key: 'colorOut',
      innerHTML: '&nbsp;',
      x: 85,
      y: 90,
      inputWidth: 15,
      inputType: 'span'
    }, {
      key: 'alpha',
      text: 'Alpha',
      x: 170,
      y: 90,
      inputWidth: 20
    }, {
      key: 'draggable',
      text: 'Allow Drag',
      value: true,
      inputWidth: 20,
      x: 250,
      y: 90,
      labelWidth: 58,
      inputPaddingTop: 3,
      type: 'checkbox'
    }, {
      key: 'shape',
      text: 'Shape',
      inputType: 'select',
      inputWidth: 97,
      innerHTML: '<option value="rect">Rectangle</option><option value="circ">Circle</option><option ' + 'value="poly">Polygon</option>',
      x: 10,
      y: 115
    }, {
      key: 'rectHeight',
      text: 'Height',
      x: 170,
      y: 115,
      inputWidth: 20
    }, {
      key: 'rectWidth',
      text: 'Width',
      x: 255,
      y: 115,
      inputWidth: 20
    }, {
      key: 'circPolyRadius',
      text: 'Radius',
      x: 170,
      y: 115,
      inputWidth: 20
    }, {
      key: 'polySides',
      text: 'Sides',
      x: 255,
      y: 115,
      inputWidth: 20
    }, {
      key: 'link',
      text: 'Link',
      x: 10,
      y: 140,
      inputWidth: 92
    }, {
      key: 'image',
      text: 'Image',
      type: 'checkbox',
      inputPaddingTop: 4,
      inputWidth: 20,
      x: 10,
      y: 170
    }, {
      key: 'imgUrl',
      text: 'URL',
      inputWidth: 105,
      x: 170,
      y: 170
    }, {
      key: 'imgWidth',
      text: 'Width',
      inputWidth: 20,
      x: 10,
      y: 195
    }, {
      key: 'imgHeight',
      text: 'Height',
      inputWidth: 20,
      x: 82,
      y: 195
    }, {
      key: 'imgAlign',
      text: 'Align',
      inputType: 'select',
      inputWidth: 75,
      innerHTML: '<option value="top">Top</option><option value="middle">Middle</option><option ' + 'value="bottom">Bottom</option>',
      x: 170,
      y: 195
    }];
    manager.labelUpdateUIDefinition = [{
      key: LABEL,
      text: 'Label*',
      x: 10,
      y: 15,
      inputWidth: 235
    }, {
      key: 'size',
      text: 'Size',
      x: 10,
      y: 40
    }, {
      key: 'padding',
      text: 'Padding',
      x: 10,
      y: 65
    }, {
      key: 'x',
      text: 'Position',
      x: 120,
      y: 65,
      labelWidth: 70,
      inputWidth: 25
    }, {
      key: 'y',
      text: COMMA,
      x: 225,
      y: 65,
      labelWidth: 10,
      inputWidth: 25
    }, {
      key: 'xy',
      text: '(x, y)',
      x: 260,
      y: 65,
      noInput: true
    }, {
      key: 'allowdrag',
      text: 'Allow Drag',
      x: 120,
      y: 40,
      inputType: 'checkbox',
      inputPaddingTop: 3,
      inputWidth: 15,
      labelWidth: 70,
      val: 1
    }, {
      key: 'color',
      text: 'Color',
      x: 10,
      y: 90
    }, {
      key: 'alpha',
      text: 'Alpha',
      x: 145,
      y: 90,
      inputWidth: 30,
      val: _lib.preDefStr.HUNDREDSTRING
    }, {
      key: 'bordercolor',
      text: 'Border Color',
      x: 10,
      y: 125,
      labelWidth: 100
    }, {
      key: 'bgcolor',
      text: 'Background Color',
      x: 10,
      y: 150,
      labelWidth: 100
    }];
    return _this;
  }
  /**
   * Sets the type of the component
   * @return {string} type
   */


  DragNodeGroup.prototype.getType = function getType() {
    return 'group';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  DragNodeGroup.prototype.getName = function getName() {
    return 'dragNodeGroup';
  };
  /**
   * Funtion to create the UI box for adding new labels
   * @param {Object} options Any predefined options to be added to the UI box
   */


  DragNodeGroup.prototype.showLabelUpdateUI = function showLabelUpdateUI() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var manager = this,
        paper = manager.getFromEnv('paper'),

    // conf = manager.getFromEnv('chartConfig'),
    inCanvasStyle = manager.getFromEnv('style').inCanvasStyle || {},
        ui = manager.getGraphicalElement('cacheLabelUpdateUI'),
        inputStyle = {
      border: '1px solid #cccccc',
      fontSize: 10 + PX,
      lineHeight: 15 + PX,
      fontFamily: inCanvasStyle.fontFamily,
      padding: 2 + PX
    },
        labelStyle = {
      textAlign: 'right'
    },
        fields = ui && ui.fields,
        labels = ui && ui.labels,
        field,
        value,
        dialog;

    if (!ui) {
      ui = manager.addGraphicalElement('cacheLabelUpdateUI', manager.createHtmlDialog(315, 205, function () {
        var fields = ui && ui.fields,
            submitObj;
        if (fields) {
          // Prepare obbject for submission.
          submitObj = {
            text: fields.label.val(),
            x: fields.x.val(),
            y: fields.y.val(),
            color: fields.color.val(),
            alpha: fields.alpha.val(),
            bgcolor: fields.bgcolor.val(),
            bordercolor: fields.bordercolor.val(),
            fontsize: fields.size.val(),
            allowdrag: fields.allowdrag.val(),
            padding: fields.padding.val()
          };

          if (submitObj.text) {
            manager.addLabel && manager.addLabel(submitObj);
            ui.hide();
          } else {
            ui.error.attr({
              text: 'Label cannot be blank.'
            });
            fields.label.focus();
          }
        }
      }, function () {
        ui.error.attr({
          text: _lib.BLANKSTRING
        });
        ui.hide();
      }));
      dialog = ui.dialog;
      labels = ui.labels = {};
      fields = ui.fields = {};
    }

    (0, _lib.fcEach)(manager.labelUpdateUIDefinition, function (def) {
      var key = def.key;

      if (!labels[key]) {
        labels[key] = paper.html(LABEL, {
          x: def.x,
          y: def.y,
          width: def.labelWidth || 45,
          text: def.text
        }, labelStyle, dialog);
      }

      // No need to proceed of this label has no input box
      // associated with itself.
      if (def.noInput) {
        return;
      }

      if (!(field = fields[key])) {
        field = fields[key] = paper.html(INPUT, {
          y: -2 + (def.inputPaddingTop || 0),
          x: def.labelWidth && def.labelWidth + 5 || 50,
          width: def.inputWidth || 50,
          type: def.inputType || 'text',
          name: key || _lib.BLANKSTRING
        }, inputStyle, labels[key]).on('keyup', ui.handleKeyPress);
      }

      if ((value = (0, _lib.pluck)(options[key], def.val)) !== undefined) {
        field.val(value);
      }
    });

    if (!ui.error) {
      ui.error = paper.html('span', {
        color: 'ff0000',
        x: 10,
        y: 180
      }, undefined, dialog);
    }

    // Show the dialog box
    // if (chart.animation) {
    //   ui.fadeIn('fast');
    // } else {
    ui.show();
    // }
    // Focus on label textbox
    ui.fields.label.focus();
  };

  /**
   * Function to restore all the data of dragnode to its initial visual
   */


  DragNodeGroup.prototype.restoreData = function restoreData() {
    var manager = this,

    // manager = chart.components['datasetGroup_' + chart.defaultDatasetType],
    datasets = manager.getChildren('dataset'),
        chart = manager.getFromEnv('chart'),
        legend = manager.getFromEnv('legend'),
        showlegend = (0, _lib.pluckNumber)(chart.config.showlegend, 0),
        connectors = manager.getChildren('connector'),
        i,
        dataset,
        dataStore,
        dataObj,
        graphics,
        labelObj,
        len,
        labelSet = manager.getChildren('labels'),
        removeElements = function removeElements(dataStore) {
      var j, ele;
      for (j = 0; j < dataStore && dataStore.length; j++) {
        dataObj = dataStore[j];
        delete dataObj.removed;
        if (dataObj.config.add) {
          graphics = dataStore[j].graphics;
          for (ele in graphics) {
            graphics[ele].remove();
          }
          dataStore.splice(j, 1);
          j--;
        }
      }
    },
        restoreDatasets = function restoreDatasets(k, datasets) {
      dataset = datasets[k];
      dataStore = dataset.components.data;
      removeElements(dataStore);
      dataset.drawn = false;
      dataset.configure();
    };
    for (i = 0, len = datasets && datasets.length; i < len; i++) {
      restoreDatasets(i, datasets);
    }
    for (i = 0, len = connectors && connectors.length; i < len; i++) {
      restoreDatasets(i, connectors);
    }
    if (labelSet && labelSet.length) {
      labelObj = labelSet[0];
      dataStore = labelObj.components.data;
      dataStore && removeElements(dataStore);
      labelObj.configure();
    }
    manager.setPosition();
    manager.asyncDraw();
    showlegend && legend.asyncDraw();
    chart.fireChartInstanceEvent('dataRestored');
  };

  /**
   * Function to add a draggable-label via UI
   * @param {Object} labelObj Conatins the information about the label that is to be added
   */


  DragNodeGroup.prototype.addLabel = function addLabel(labelObj) {
    var manager = this,
        labelDS = manager.getChildren('labels'),
        dataStore,
        sourceEvent = 'labeladded',
        eventArgs,
        len;
    labelObj.add = true;

    // Creating an instance of the label class if not already present
    if (labelDS) {
      labelDS = labelDS[0];
    } else {
      (0, _lib.componentFactory)(manager, _dragablelabels2['default'], 'labels', 1, [{}]);
      labelDS = manager.getChildren('labels')[0];
    }
    dataStore = labelDS.components.data || (labelDS.components.data = []);
    len = dataStore.length;
    labelDS._setConfigure(len, labelObj);
    // }

    eventArgs = {
      text: labelObj.text,
      x: labelObj.x,
      y: labelObj.y,
      allowdrag: labelObj.allowdrag,
      sourceType: 'labelnode',
      link: labelObj.link
    };
    labelDS.syncDraw();
    // global.raiseEvent(sourceEvent, eventArgs, chart.chartInstance);
    manager.getFromEnv('chart').fireChartInstanceEvent(sourceEvent, eventArgs);
  };

  /**
   * Funtion to create the options for the dialog box used for adding new nodes
   */


  DragNodeGroup.prototype.showNodeAddUI = function showNodeAddUI() {
    var manager = this,

    // chart = manager.chart,
    datasets = manager.getChildren('dataset'),
        datasetDropDownStr = _lib.BLANKSTRING,
        str1 = '<option value="',
        str2 = '">',
        str3 = '</option>',
        conf,
        dataset,
        type,
        i;
    for (i = 0; i < datasets.length; i++) {
      dataset = datasets[i] || {};
      conf = dataset.config;
      type = dataset.getName();
      if (type === 'dragNode') {
        datasetDropDownStr += str1 + dataset.config.datasetIndex + str2 + (conf.name !== BLANK && conf.name !== undefined && conf.name + _lib.COMMASTRING + BLANKSPACE || BLANK) + dataset.config.datasetIndex + str3;
      }
    }
    manager.showNodeUpdateUI({
      dataset: {
        innerHTML: datasetDropDownStr
      }
    });
  };

  /**
   * Funtion to create the options for the dialog box used for adding new connectors
   */


  DragNodeGroup.prototype.showConnectorAddUI = function showConnectorAddUI() {
    var manager = this,

    // chart = manager.chart,
    nodes = manager.getNode(),
        nodeStr = _lib.BLANKSTRING,
        str1 = '<option value="',
        str2 = '">',
        str3 = '</option>',
        id,
        i,
        config,
        node;
    for (i in nodes) {
      node = nodes[i];
      config = node.config;
      id = config.id;
      nodeStr += str1 + id + str2 + id + str3;
    }
    manager.showConnectorUpdateUI({
      fromid: {
        innerHTML: nodeStr
      },
      toid: {
        innerHTML: nodeStr
      }
    });
  };

  /**
   * Function to create the UI box for adding/updating the connectors
   * @param {Object} config Has the information about the concerned connector
   * @param {boolean} edit Flag for determining if a new connector has to be added or existing connector has to be
   * updated
   */


  DragNodeGroup.prototype.showConnectorUpdateUI = function showConnectorUpdateUI(config, edit) {
    var manager = this,
        renderer = manager.getFromEnv('paper'),

    // conf = chart.config,
    chartConfig = manager.getFromEnv('chartConfig'),
        inCanvasStyle = manager.getFromEnv('style').inCanvasStyle || {},
        ui = manager.getGraphicalElement('cacheConnectorUpdateUI'),
        inputStyle = {
      border: '1px solid #cccccc',
      fontSize: 10 + PX,
      lineHeight: 15 + PX,
      fontFamily: inCanvasStyle.fontFamily,
      padding: 2 + PX
    },
        labelStyle = {
      textAlign: 'right'
    },
        fields = ui && ui.fields,
        labels = ui && ui.labels,
        innerHTML,
        field,
        value,
        onDelete = function onDelete() {
      var fields = ui && ui.fields,
          config = {
        from: fields.fromid.val(),
        to: fields.toid.val(),
        id: fields.id.val()
      };

      manager.deleteConnector(config);
      ui.hide();
    },
        dialog;

    if (!ui) {
      ui = manager.addGraphicalElement('cacheConnectorUpdateUI', manager.createHtmlDialog(315, 215, function () {
        var fields = ui && ui.fields,
            submitObj;
        if (fields) {
          submitObj = {
            from: fields.fromid.val(),
            to: fields.toid.val(),
            id: fields.id.val(),
            label: fields.label.val(),
            color: fields.color.val(),
            alpha: fields.alpha.val(),
            link: fields.url.val(),
            tooltext: fields.tooltext.val(),
            strength: fields.strength.val(),
            arrowatstart: fields.arratstart.val(),
            arrowatend: fields.arratend.val(),
            dashed: fields.dashed.val(),
            dashlen: fields.dashlen.val(),
            dashgap: fields.dashgap.val()
          };

          // Validate
          if (submitObj.from) {
            if (submitObj.to) {
              if (submitObj.from != submitObj.to) {
                edit ? manager.editConnector(submitObj) : manager.addConnector(submitObj);
                ui.enableFields();
                ui.hide();
                ui.clearFields();
              } else {
                ui.error.attr({
                  text: 'Connector cannot start and end at the same node!'
                });
                fields.fromid.focus();
              }
            } else {
              ui.error.attr({
                text: 'Please select a valid connector end.'
              });
              fields.toid.focus();
            }
          } else {
            ui.error.attr({
              text: 'Please select a valid connector start.'
            });
            fields.fromid.focus();
          }
        }
      },
      // Cancel function
      function () {
        ui.error.attr({
          text: _lib.BLANKSTRING
        });
        ui.enableFields();
        ui.hide();
      },
      // Delete function
      onDelete));
      dialog = ui.dialog;
      labels = ui.labels = {};
      fields = ui.fields = {};
    } else {
      ui.attr({
        width: chartConfig.width,
        height: chartConfig.height
      });
      ui.veil.attr({
        width: chartConfig.width,
        height: chartConfig.height
      });
      ui.dialog.attr({
        x: (chartConfig.width - 315) / 2,
        y: (chartConfig.height - 215) / 2,
        width: 315,
        height: 215
      });
    }
    ui.config = config;
    if (!ui.enableFields) {
      ui.enableFields = function () {
        var key;
        for (key in config) {
          if (config[key] && config[key].disabled && fields[key]) {
            fields[key].element.removeAttribute('disabled');
          }
        }
      };
    }
    if (!ui.clearFields) {
      ui.clearFields = function () {
        var key,
            fields = ui.fields;
        for (key in fields) {
          if (!fields[key].element.disabled) {
            fields[key].element.value = _lib.BLANKSTRING;
          }
        }
      };
    }

    (0, _lib.fcEach)(manager.connectorUpdateUIDefinition, function (def) {
      var key = def.key,
          attr = config[key] || {};

      if (!labels[key]) {
        labels[key] = renderer.html(LABEL, {
          x: def.x,
          y: def.y,
          width: def.labelWidth || 45,
          text: def.text
        }, labelStyle, dialog);
      }

      // No need to proceed of this label has no input box
      // associated with itself.
      if (def.noInput) {
        return;
      }

      if (!(field = fields[key])) {
        field = fields[key] = renderer.html(def.inputType || INPUT, {
          y: -2 + (def.inputPaddingTop || 0),
          x: def.labelWidth && def.labelWidth + 5 || 50,
          width: def.inputWidth || 50,
          name: key || _lib.BLANKSTRING
        }, inputStyle);

        if (def.inputType !== 'select') {
          field.attr({
            type: def.type || 'text'
          }).on('keyup', ui.handleKeyPress);
        }
        field.add(labels[key]);
      }

      if (innerHTML = (0, _lib.pluck)(attr.innerHTML, def.innerHTML)) {
        field.attr({
          innerHTML: innerHTML
        });
      }
      if ((value = (0, _lib.pluck)(attr.val, def.val)) !== undefined) {
        field.val(value);
      }
      if (attr.disabled) {
        field.attr({
          disabled: 'disabled'
        });
      }
    });

    // dash checking and ui modification
    // call to set default fro the first time
    ui.checkDash = function () {
      var checked = fields.dashed && fields.dashed.val(),
          showHideFn = checked ? 'show' : 'hide';
      labels.dashgap && labels.dashgap[showHideFn]();
      fields.dashgap && fields.dashgap[showHideFn]();
      labels.dashlen && labels.dashlen[showHideFn]();
      fields.dashlen && fields.dashlen[showHideFn]();
    };
    ui.checkDash();
    fields.dashed.on('click', ui.checkDash);

    if (!ui.error) {
      ui.error = renderer.html('span', {
        color: 'ff0000',
        x: 10,
        y: 170
      }, undefined, dialog);
    }

    ui.removeItem[edit ? 'show' : 'hide']();
    // Show the dialog box
    if (chartConfig.animation) {
      ui.fadeIn('fast');
    } else {
      ui.show();
    }
  };

  /**
   * Function to create the UI box for adding/updating the nodes
   * @return {Function} The actual function for updating/adding the nodes
   */


  DragNodeGroup.prototype.showNodeUpdateUI = function showNodeUpdateUI() {
    return _showNodeUpdateUI.apply(this, arguments);
  };

  /**
   * Function for adding new nodes
   * @param {Object} dataObj Contains information about the node that is to be added
   */


  DragNodeGroup.prototype.addNode = function addNode(dataObj) {
    var manager = this,
        datasets = manager.getChildren('dataset'),
        datasetId = dataObj.datasetId,
        len = datasets.length,
        dataset,
        index,
        idFound,
        id,
        i,
        eventArgs,
        sourceEvent = 'nodeAdded',
        dataStore;

    for (i = 0; i < len; i++) {
      dataset = datasets[i] || {};
      id = dataset.config.datasetIndex;
      if (id !== undefined) {
        id = id.toString();
      }
      if (id === datasetId) {
        idFound = true;
        break;
      }
    }
    if (dataset && idFound) {
      dataStore = dataset.components.data;
      dataObj.add = true;
      // This is the index of the new data
      index = dataStore.length;
      eventArgs = {
        index: index, // to be deprecated
        dataIndex: index,
        link: dataObj.link,
        y: dataObj.y,
        x: dataObj.x,
        shape: dataObj.shape,
        width: dataObj.width,
        height: dataObj.height,
        radius: dataObj.radius,
        sides: dataObj.sides,
        label: dataObj.name,
        toolText: dataObj.tooltext,
        id: dataObj.id,
        datasetIndex: dataset.config.datasetIndex,
        datasetName: dataset.config.seriesname,
        sourceType: 'dataplot'
      };

      dataset._setConfigure(index, dataObj);
      dataset.setState('dirty', true);
      dataset.syncDraw();
      // manager._redrawDragNode(eventArgs, sourceEvent);
      /**
       * In `DragNode` charts, data points are represented as nodes whose
       * properties like location(x,y), shape, dimensions and color can be added dynamically to
       * the chart. Chart can contain any number of datasets and an index number is assigned to
       * each dataset based upon order of dataset creation. This event is raised when a node is
       * added by clicking on the menu button located at the left side bottom of the chart by
       * default but can the menu button location can be changed.
       *
       * This event is only applicable to DragNode chart.
       *
       * @event FusionCharts#nodeAdded
       * @group chart-powercharts:dragnode
       *
       * @param {number} datasetIndex - Index of the dataset to which the newly added
       * node belongs to.
       * @param {string} datasetName - Name of the dataset to which the node was added. Name of
       * the dataset can be defined by the attribute `seriesName` for `dataset` tag in the chart
       * data.
       * @param {number} dataIndex - Index of the newly added node.
       *
       * @param {number} height - Height of the shape represented by the newly added node.
       * @param {string} id - ID of the newly added node which can be set using `id` attribute
       * for `set` tag.
       *
       * @param {string} label - Text displayed inside the shape of the newly added node.
       * @param {string} link - URL associated with the newly added node.
       * @param {number} radius - Radius of the circumcirle for the shape of the
       * newly added node.
       * @param {string} shape - Shape of the newly added node.
       * @param {number} sides - Depending on the shape of the node it is the
       * number of sides of the polygon. If it is a circle it will have 0 sides.
       * @param {string} toolText - Text that is displayed over the shape of the
       * newly added node.
       * @param {number} width - Width of the shape of the newly added node.
       * @param {number} x - X Co-ordinate of the newly added node in reference with
       * the canvas / axis.
       * @param {number} y - Y Co-ordinate of the newly added node in reference with
       * the canvas / axis.
       */
      manager.getFromEnv('chart').fireChartInstanceEvent(sourceEvent, eventArgs);
    }
  };

  /**
   * Function for updating existing nodes
   * @param {Object} updateObj Contains information about the node that is to be updated
   */


  DragNodeGroup.prototype.updateNode = function updateNode(updateObj) {
    var groupManager = this,
        datasets = groupManager.getChildren('dataset'),
        len = datasets.length,
        dataLen,
        idFound,
        dataset,
        dataObj,
        i,
        dataStore,
        eventArgs,
        sourceEvent = 'nodeupdated',
        j;
    updateObj.update = true;
    for (i = 0; i < len; i++) {
      dataset = datasets[i];
      dataStore = dataset.components.data || [];
      dataLen = dataStore.length;
      for (j = 0; j < dataLen; j++) {
        dataObj = dataStore[j];
        if (dataObj.config.id === updateObj.id) {
          idFound = true;
          break;
        }
      }
    }

    if (dataset && idFound) {
      eventArgs = {
        index: j, // to be deprecated
        dataIndex: j,
        link: updateObj.link,
        y: updateObj.y,
        x: updateObj.x,
        shape: updateObj.shape,
        width: updateObj.width,
        height: updateObj.height,
        radius: updateObj.radius,
        sides: updateObj.sides,
        label: updateObj.name,
        toolText: updateObj.tooltext,
        id: updateObj.id,
        datasetIndex: dataset.config.datasetIndex,
        datasetName: dataset.config.seriesname,
        sourceType: 'dataplot'
      };
      dataset._setConfigure(j, updateObj);
      dataset.setState('dirty', true);
      dataset.syncDraw();
      // groupManager._redrawDragNode(eventArgs, sourceEvent);
      // global.raiseEvent(sourceEvent, eventArgs, chart.chartInstance);
      groupManager.getFromEnv('chart').fireChartInstanceEvent(sourceEvent, eventArgs);
    }
  };

  /**
   * Function for deleting a node
   * @param {Stirng} id The id of the node that is to be deleted
   */


  DragNodeGroup.prototype.deleteNode = function deleteNode(id) {
    var manager = this,
        node = manager.getNode(id),

    // node = nodes[id],
    dataset,
        dataStore,
        startConnectors,
        endConnectors,
        i,
        graphics,
        connector,
        dataObj,
        prop,
        len,
        eventArgs,
        config,
        idFound,
        sourceEvent = 'nodedeleted',
        removeElements = function removeElements(graphics) {
      for (var i in graphics) {
        graphics[i].remove();
      }
    };
    if (node) {
      dataset = node.dataset;
      dataStore = dataset.components.data;
      startConnectors = node.config.startConnectors;
      endConnectors = node.config.endConnectors;
      len = dataStore.length;
      for (i = 0; i < len; i++) {
        dataObj = dataStore[i];
        if (dataObj.config.id === id) {
          idFound = true;
          break;
        }
      }

      if (idFound === true) {
        graphics = dataObj.graphics;
        removeElements(graphics);
        for (prop in startConnectors) {
          connector = startConnectors[prop] || {};
          graphics = connector.graphics;
          removeElements(graphics);
          delete connector.graphics;
          connector.removed = true;
        }
        for (prop in endConnectors) {
          connector = endConnectors[prop] || {};
          graphics = connector.graphics;
          removeElements(graphics);
          delete connector.graphics;
          connector.removed = true;
        }
        // delete nodes[id];
        dataObj.removed = true;
        config = dataObj.config || {};
        eventArgs = {
          index: i,
          dataIndex: i,
          link: config.link,
          y: config.y,
          x: config.x,
          shape: config.shape,
          width: config.width,
          height: config.height,
          radius: config.radius,
          sides: config.sides,
          label: config.displayValue,
          toolText: config.toolText,
          id: config.id,
          datasetIndex: dataset.config.datasetIndex,
          datasetName: dataset.config.seriesname,
          sourceType: 'dataplot'
        };
        // lib.raiseEvent('chartUpdated', extend2({
        //   sourceEvent: sourceEvent
        // }, eventArgs), chart.chartInstance, [chart.chartInstance.id]);
        // global.raiseEvent(sourceEvent, eventArgs, chart.chartInstance);
        manager.getFromEnv('chart').fireChartInstanceEvent(sourceEvent, eventArgs);
      }
    }
  };

  /**
   * Function for adding new connectors
   * @param {Object} connectorObj Contains information about the connector that is to be added
   */


  DragNodeGroup.prototype.addConnector = function addConnector(connectorObj) {
    var manager = this,

    // groupManager = chart.components['datasetGroup_' + chart.defaultDatasetType],
    connectors = manager.getChildren('connector')[0],

    // connectors = connectorSets[0].connectors,
    data = connectors.components.data,
        sourceEvent = 'connectoradded',
        eventArgs,
        length = data.length;
    connectorObj.add = true;
    connectors._setConfigure(length, connectorObj);
    eventArgs = {
      arrowAtEnd: Boolean(connectorObj.arrowAtEnd),
      arrowAtStart: Boolean(connectorObj.arrowAtStart),
      fromNodeId: connectorObj.from,
      id: connectorObj.id,
      label: connectorObj.label,
      link: connectorObj.connectorLink,
      sourceType: 'connector',
      toNodeId: connectorObj.to
    };
    connectors.syncDraw();
    // manager._redrawDragNode(eventArgs, sourceEvent);
    // global.raiseEvent(sourceEvent, eventArgs, chart.chartInstance);
    manager.getFromEnv('chart').fireChartInstanceEvent(sourceEvent, eventArgs);
  };

  /**
   * Function for updating existing connectors
   * @param {Object} connectorObj Contains information about the connector that is to be updated
   */


  DragNodeGroup.prototype.editConnector = function editConnector(connectorObj) {
    var manager = this,

    // groupManager = chart.components['datasetGroup_' + chart.defaultDatasetType],
    from = connectorObj.from,
        to = connectorObj.to,
        connectorSets = manager.getChildren('connector'),
        i,
        conLen,
        data,
        dataObj,
        fromId,
        toId,
        j,
        idFound,
        connectors,
        config,
        eventArgs,
        sourceEvent = 'connectorupdated',
        len = connectorSets.length;
    for (i = 0; i < len; i++) {
      connectors = connectorSets[i];
      data = connectors && connectors.components.data || [];
      conLen = data.length;
      for (j = 0; j < conLen; j++) {
        dataObj = data[j];
        config = dataObj.config;
        fromId = config.from;
        toId = config.to;
        if (fromId === from && toId === to) {
          idFound = true;
          break;
        }
      }
    }
    connectorObj.update = true;
    if (idFound) {
      connectors._setConfigure(j, connectorObj);
      eventArgs = {
        arrowAtEnd: Boolean(connectorObj.arrowatend),
        arrowAtStart: Boolean(connectorObj.arrowatstart),
        fromNodeId: connectorObj.from,
        id: connectorObj.id,
        label: connectorObj.label,
        link: connectorObj.link,
        sourceType: 'connector',
        toNodeId: connectorObj.to
      };
      connectors.syncDraw();
      // manager._redrawDragNode(eventArgs, sourceEvent);
      // global.raiseEvent(sourceEvent, eventArgs, chart.chartInstance);
      manager.getFromEnv('chart').fireChartInstanceEvent(sourceEvent, eventArgs);
    }
  };

  /**
   * Function for deleting a connector
   * @param {Object} config Contains information about the connector that is to be deleted
   */


  DragNodeGroup.prototype.deleteConnector = function deleteConnector(config) {
    var manager = this,

    // groupManager = chart.components['datasetGroup_' + chart.defaultDatasetType],
    from = config.from,
        to = config.to,
        connectorSets = manager.getChildren('connector'),
        i,
        j,
        dataObj,
        dataStore,
        dataLen,
        connFound = false,
        connectors,
        eventArgs,
        connConfig,
        len = connectorSets.length,
        sourceEvent = 'connectordeleted',
        removeElements = function removeElements(graphics) {
      var prop;
      for (prop in graphics) {
        graphics[prop].remove();
      }
    };

    for (i = 0; i < len; i++) {
      connectors = connectorSets[i];
      dataStore = connectors.components.data;
      dataLen = dataStore.length;
      for (j = 0; j < dataLen; j++) {
        dataObj = dataStore[j];
        if (dataObj.config.from === from && dataObj.config.to === to) {
          connFound = true;
          break;
        }
      }
    }
    if (connFound) {
      connConfig = dataObj.config || {};
      eventArgs = {
        arrowAtEnd: connConfig.arrowAtEnd,
        arrowAtStart: connConfig.arrowAtStart,
        fromNodeId: connConfig.from,
        id: connConfig.id,
        label: connConfig.label,
        link: connConfig.connectorLink,
        sourceType: 'connector',
        toNodeId: connConfig.to
      };
      removeElements(dataObj.graphics);
      delete dataObj.graphics;
      // Mark data object as removed
      dataObj.removed = true;
      // lib.raiseEvent('chartUpdated', extend2({
      //   sourceEvent: sourceEvent
      // }, eventArgs), chart.chartInstance, [chart.chartInstance.id]);
      // global.raiseEvent(sourceEvent, eventArgs, chart.chartInstance);
      manager.getFromEnv('chart').fireChartInstanceEvent(sourceEvent, eventArgs);
    }
  };

  /**
   * Generic function for creating a html UI box
   * @param {number} dialogWidth The width of the dialog box
   * @param {number} dialogHeight The height of the dialog box
   * @param {Function} onsubmit Callback functions
   * @param {Function} oncancel Callback functions
   * @param {Function} onremove Callback functions
   * @param {Object} cacheUI If the dialog box or its components are created then they are sent via this object so that
   * they are not re-created.
   * @return {HTMLElement} The final created html UI box
   */


  DragNodeGroup.prototype.createHtmlDialog = function createHtmlDialog(dialogWidth, dialogHeight, onsubmit, oncancel, onremove, cacheUI) {
    var manager = this,
        paper = manager.getFromEnv('paper'),
        conf = manager.getFromEnv('chartConfig'),
        container = manager.getFromEnv('chart-container'),
        inCanvasStyle = manager.getFromEnv('style').inCanvasStyle || {},
        chartWidth = conf.width,
        chartHeight = conf.height,
        padding = 5,
        dialogAttrs,
        okAttrs,
        cancelAttrs,
        removeAttrs,

    // transposeAnimDuration = chart.get(configStr, animationObjStr).transposeAnimDuration,
    transposeAnimDuration = 0,
        buttonStyle = {
      color: (0, _lib.hashify)(inCanvasStyle.color),
      textAlign: 'center',
      paddingTop: 1 + PX,
      border: '1px solid #cccccc',
      borderRadius: 4 + PX,
      cursor: _lib.preDefStr.POINTER,
      '_cursor': 'hand',
      backgroundColor: _lib.HASHSTRING + COLOR_FFFFFF,
      zIndex: 21,
      '-webkit-border-radius': 4 + PX
    },
        ui = cacheUI;
    if (!ui) {
      ui = paper.html('div', {
        fill: 'transparent',
        width: chartWidth,
        height: chartHeight
      }, {
        fontSize: 10 + PX,
        lineHeight: 15 + PX,
        fontFamily: inCanvasStyle.fontFamily
      }, container);
    } else {
      if (transposeAnimDuration) {
        ui.animate({
          width: chartWidth,
          height: chartHeight
        }, transposeAnimDuration, NORMALSTRING);
      } else {
        ui.attr({
          width: chartWidth,
          height: chartHeight
        });
      }
    }
    if (!ui.veil) {
      ui.veil = paper.html('div', {
        fill: COLOR_000000,
        width: chartWidth,
        height: chartHeight,
        opacity: 0.3
      }, undefined, ui);
    } else {
      if (transposeAnimDuration) {
        ui.veil.animate({
          width: chartWidth,
          height: chartHeight
        }, transposeAnimDuration, NORMALSTRING);
      } else {
        ui.veil.attr({
          width: chartWidth,
          height: chartHeight
        });
      }
    }
    dialogAttrs = {
      x: (chartWidth - dialogWidth) / 2,
      y: (chartHeight - dialogHeight) / 2,
      fill: 'efefef',
      strokeWidth: 1,
      stroke: COLOR_000000,
      width: dialogWidth,
      height: dialogHeight
    };
    if (!ui.dialog) {
      ui.dialog = paper.html('div', dialogAttrs, {
        borderRadius: 5 + PX,
        boxShadow: '1px 1px 3px #000000',
        '-webkit-border-radius': 5 + PX,
        '-webkit-box-shadow': '1px 1px 3px #000000',
        filter: 'progid:DXImageTransform.Microsoft.Shadow(Strength=4, Direction=135, Color="#000000")'
      }, ui);
    } else {
      if (transposeAnimDuration) {
        ui.dialog.animate({
          x: dialogAttrs.x,
          y: dialogAttrs.y,
          width: dialogAttrs.width,
          height: dialogAttrs.height
        }, transposeAnimDuration, NORMALSTRING);
      } else {
        ui.dialog.attr(dialogAttrs);
      }
    }

    okAttrs = {
      x: dialogWidth - 70 - padding,
      y: dialogHeight - 23 - padding,
      width: 65,
      height: 17,
      text: 'Submit',
      tabIndex: 1
    };
    if (!ui.ok) {
      ui.ok = paper.html('div', okAttrs, buttonStyle, ui.dialog).on('click', onsubmit);
    } else {
      if (transposeAnimDuration) {
        ui.ok.animate({
          x: okAttrs.x,
          y: okAttrs.y,
          width: okAttrs.width,
          height: okAttrs.height
        }, transposeAnimDuration, NORMALSTRING);
      } else {
        ui.ok.attr(okAttrs);
      }
    }

    cancelAttrs = {
      x: dialogWidth - 140 - padding,
      y: dialogHeight - 23 - padding,
      width: 65,
      height: 17,
      text: 'Cancel',
      tabIndex: 2
    };
    if (!ui.cancel) {
      ui.cancel = paper.html('div', cancelAttrs, buttonStyle, ui.dialog).on('click', oncancel);
    } else {
      if (transposeAnimDuration) {
        ui.cancel.animate({
          x: cancelAttrs.x,
          y: cancelAttrs.y,
          width: cancelAttrs.width,
          height: cancelAttrs.height
        }, transposeAnimDuration, NORMALSTRING);
      } else {
        ui.cancel.attr(cancelAttrs);
      }
    }

    removeAttrs = {
      x: dialogWidth - 210 - padding,
      y: dialogHeight - 23 - padding,
      width: 65,
      height: 17,
      text: 'Delete',
      tabIndex: 3
    };
    if (!ui.removeItem) {
      ui.removeItem = paper.html('div', removeAttrs, buttonStyle, ui.dialog).on('click', onremove);
    } else {
      if (transposeAnimDuration) {
        ui.removeItem.animate({
          x: removeAttrs.x,
          y: removeAttrs.y,
          width: removeAttrs.width,
          height: removeAttrs.height
        }, transposeAnimDuration, NORMALSTRING);
      } else {
        ui.removeItem.attr(removeAttrs);
      }
    }

    if (!ui.handleKeyPress) {
      // Add an event that would handle enter and esc on input
      // elements
      ui.handleKeyPress = function (e) {
        if (e.keyCode === 13) {
          ui.ok.trigger(_lib.hasTouch ? 'touchStart' : 'click', e);
        } else if (e.keyCode === 27) {
          ui.cancel.trigger(_lib.hasTouch ? 'touchStart' : 'click', e);
        }
      };
    }

    // Keep initially hidden.
    // ui.hide();
    return ui;
  };

  /**
   * Function to get a specific node after querying all the datasets
   * @param {string} nodeId The node's id whose corresponding data object is required
   * @return {Object} The specific node or all the nodes from all the datasets
   */


  DragNodeGroup.prototype.getNode = function getNode(nodeId) {
    var manager = this,
        node,
        nodes = {},
        datasets = manager.getChildren('dataset');

    for (var i = 0, len = datasets.length; i < len; i++) {
      if (nodeId) {
        if (node = datasets[i].getNode(nodeId)) {
          return node;
        }
      } else {
        (0, _assign2['default'])(nodes, datasets[i].getNode());
      }
    }
    return !nodeId && nodes;
  };

  /**
   * Create child containers
   */


  DragNodeGroup.prototype.createContainer = function createContainer() {
    var manager = this,
        animationManager = manager.getFromEnv('animationManager'),
        keys = ['connectorGroup', 'defaultVcanvasGroup', 'vcanvasLabelGroup', 'cloneGroup'],
        parent = manager.getLinkedParent(),
        parentChildContainers = parent.getChildContainer();

    keys.forEach(function (key) {
      !manager.getChildContainer(key) && manager.addChildContainer(key, animationManager.setAnimation({
        el: 'group',
        attr: { name: 'manager-' + key },
        component: manager,
        container: parentChildContainers[key] || parentChildContainers.defaultVcanvasGroup
      }));
    });

    !manager.getContainer('waitContainer') && manager.addContainer('waitContainer', animationManager.setAnimation({
      el: 'group',
      attr: { name: 'manager-waitContainer' },
      container: parentChildContainers.defaultVcanvasGroup,
      component: manager
    }));
  };
  /**
   * function call sync draw of its children
   */


  DragNodeGroup.prototype.draw = function draw() {
    this.createContainer();
  };

  /**
   * function to get data limits from its child datasets
   * return minimun and maximum value among the datasets limit
   * @return {Object} [min, max]
   */


  DragNodeGroup.prototype.getDataLimits = function getDataLimits() {
    var manager = this,
        datasets = manager.getChildren('dataset'),
        i,
        yMin = +Infinity,
        yMax = -Infinity,
        xMax = -Infinity,
        xMin = +Infinity,
        conf;
    for (i = 0; i < datasets.length; i++) {
      conf = datasets[i].config;
      yMax = Math.max(yMax, conf.yMax);
      yMin = Math.min(yMin, conf.yMin);
      xMax = Math.max(xMax, conf.xMax);
      xMin = Math.min(xMin, conf.xMin);
    }

    return {
      max: yMax,
      min: yMin,
      xMax: xMax,
      xMin: xMin
    };
  };
  /**
   * it return the status of dataset visiblity
   * @return {boolean} returns the visiblity status of dataset
   */


  DragNodeGroup.prototype.isVisible = function isVisible() {
    return !this.isNotVisible;
  };

  /**
   * Over writing the childChanged function of the parent, basically a dummy function.
   * @return {Object} instance of DragNodeGroup class
   */


  DragNodeGroup.prototype.childChanged = function childChanged() {
    return this;
  };

  /**
   * Function to hide the circular ring element
   */


  DragNodeGroup.prototype.hideWaitElem = function hideWaitElem() {
    this.getGraphicalElement('waitElement') && this.getGraphicalElement('waitElement').hide();
  };

  /**
   * Function to clear the setTimeout of that is set when a long press is triggered on the nodes, connectors and labels
   */


  DragNodeGroup.prototype.clearLongPress = function clearLongPress() {
    var manager = this;
    clearTimeout(manager.config._longpressactive);
    delete manager.config._longpressactive;
  };

  /**
   * Function to set the timer after which the UI for deleting labels will open
   * @param {SVGElement} ele The element over which the click is done
   * @param {Object} labelObj Conatins the information about the label that is clicked
   */


  DragNodeGroup.prototype.triggerLabelUI = function triggerLabelUI(ele, labelObj) {
    var manager = this;
    manager.config._longpressactive = setTimeout(function () {
      ele.data('fire_click_event', 0);
      if (!ele.data('viewMode')) {
        manager.showLabelDeleteUI(labelObj);
      }
    }, CLEAR_TIME_1000);
  };

  /**
   * Function to manage the UI box for editing connectors
   * @param {SVGElemet} ele The element on which the mousedown event is triggered
   */


  DragNodeGroup.prototype.triggerConnectorUI = function triggerConnectorUI(ele) {
    var manager = this,
        dataset = ele.data('dataset'),
        conf = dataset.config,
        config = ele.data(_lib.preDefStr.configStr),
        options = config || {};
    manager.config._longpressactive = setTimeout(function () {
      // Whether to fire the click event ot not
      ele.data('fire_click_event', 0);

      if (!ele.data('viewMode')) {
        // add a selection method for start and end
        manager.showConnectorUpdateUI({
          fromid: {
            val: options.from,
            innerHTML: OPTIONSTR + options.from + OPTIONCLOSESTR,
            disabled: true
          },
          toid: {
            val: options.to,
            innerHTML: OPTIONSTR + options.to + OPTIONCLOSESTR,
            disabled: true
          },
          datasetIndex: dataset.config.datasetIndex,
          index: config.index,
          arratstart: {
            val: Boolean((0, _lib.pluckNumber)(options.arrowatstart, 1))
          },
          arratend: {
            val: Boolean((0, _lib.pluckNumber)(options.arrowatend, 1))
          },
          dashed: {
            val: (0, _lib.pluckNumber)(options.dashed)
          },
          dashgap: {
            val: options.dashgap
          },
          dashlen: {
            val: options.dashlen
          },
          label: {
            val: options.label
          },
          tooltext: {
            val: options.tooltext
          },
          id: {
            val: conf.id,
            disabled: true
          },
          strength: {
            val: options.conStrength
          },
          alpha: {
            val: options.alpha
          },
          color: {
            val: options.color.FCcolor.color
          }
        }, true);
      }
    }, CLEAR_TIME_1000);
  };

  /**
   * Function to delete a label
   * @param {number} index The index of the label that is to be deleted
   */


  DragNodeGroup.prototype.deleteLabel = function deleteLabel(index) {
    var manager = this,
        labels = manager.getChildren('labels')[0],
        dataStore = labels.components.data,
        labelObj = dataStore[index],
        labelElement,
        eventArgs,
        sourceEvent = 'labeldeleted';

    labelElement = labelObj.graphics.element;

    if (labelElement) {
      eventArgs = labelElement.data('eventArgs');
      labelElement.remove();
      delete labelObj.graphics;
    }
    // lib.raiseEvent('chartUpdated', extend2({
    //   sourceEvent: sourceEvent
    // }, eventArgs), chart.chartInstance, [chart.chartInstance.id]);
    manager.getFromEnv('chart').fireChartInstanceEvent(sourceEvent, eventArgs);
    // global.raiseEvent(sourceEvent, eventArgs, chart.chartInstance);
    labelObj.removed = true;
  };

  /**
   * Function to show thw UI for deleting an existing label
   * @param {Object} label Conatains information about the label that is to be deleted
   */


  DragNodeGroup.prototype.showLabelDeleteUI = function showLabelDeleteUI(label) {
    var manager = this,

    // chart = manager.chart,
    // animationObj = chart.get(configStr, animationObjStr),
    // animation = animationObj.duration,
    paper = manager.getFromEnv('paper'),
        ui = manager.getGraphicalElement('cacheLabelDeleteUI');
    if (!ui) {
      ui = manager.addGraphicalElement('cacheLabelDeleteUI', manager.createHtmlDialog(250, 100, undefined, function () {
        ui.hide();
      }, function () {
        manager.deleteLabel(label.config.index);
        ui.hide();
      }));

      // create a location where to show the text message
      ui.message = paper.html('span', {
        x: 10,
        y: 10,
        width: 230,
        height: 80
      }).add(ui.dialog);
      // since submit button is not needed, hide it and move the
      // delete button to its place.
      ui.ok.hide();
      ui.removeItem.translate(175).show();
    }

    // Update the message with proper text.
    ui.message.attr({
      text: 'Would you really like to delete the label: \"' + label.config.text + '\"?'
    });

    // Show the dialog box
    // if (animation) {
    //   ui.fadeIn('fast');
    // } else {
    ui.show();
    // }
  };

  /**
   * Function to draw the circular ring and trigger the timer for opening the html box for editing the node
   * @param {Object} dataObj Conatins information about the node that is clicked
   * @param {number} datasetIndex The index of the dataset to which the node belongs
   */


  DragNodeGroup.prototype.drawWaitingRing = function drawWaitingRing(dataObj, datasetIndex) {
    var manager = this,
        managerConfig = manager.config,
        animationManager = manager.getFromEnv('animationManager'),
        waitGroup = manager.getContainer('waitContainer'),
        config = dataObj.config,
        conf = manager.getChildren('dataset')[datasetIndex],

    // chart = manager.getFromEnv('chart'),
    waitElement = manager.getGraphicalElement('waitElement');

    manager.clearLongPress();
    waitElement = animationManager.setAnimation({
      el: waitElement || 'ringpath',
      attr: {
        ringpath: [config._xPos, config._yPos, 8, 11, 0, 0],
        fill: (0, _lib.toRaphaelColor)({
          alpha: '100,100',
          angle: 120,
          color: 'CCCCCC,FFFFFF',
          ratio: '30,50'
        }),
        'stroke-width': 0
      },
      container: waitGroup,
      component: manager
    });
    if (!manager.getGraphicalElement('waitElement')) {
      manager.addGraphicalElement('waitElement', waitElement);
    }
    // layerX += 11;
    // layerY -= 21;
    waitElement.show().animate({
      ringpath: [config._xPos, config._yPos, 8, 11, 0, 6.28]
    }, CLEAR_TIME_1000);

    managerConfig._longpressactive = setTimeout(function () {
      var seriesName = conf.name !== BLANK && conf.name !== undefined ? conf.name + _lib.COMMASTRING + _lib.preDefStr.BLANKSPACE : BLANK,
          seriesId = conf.id;
      waitElement && waitElement.hide();
      // Whether to fire the click event ot not
      // ele.data('fire_click_event', 0);
      manager.showNodeUpdateUI({
        x: {
          value: config.x
        },
        y: {
          value: config.y
        },
        draggable: {
          value: (0, _lib.getFirstValue)(config.allowdrag, 1)
        },
        color: {
          value: config.color
        },
        alpha: {
          value: config.alpha
        },
        label: {
          value: (0, _lib.getFirstValue)(config.label, config.name)
        },
        tooltip: {
          value: config.toolText
        },
        shape: {
          value: shapesInfo[config.shape]
        },
        rectWidth: {
          value: config.width
        },
        rectHeight: {
          value: config.height
        },
        circPolyRadius: {
          value: config.radius
        },
        polySides: {
          value: config.numsides
        },
        image: {
          value: config.imageNode
        },
        imgWidth: {
          value: config.imageWidth
        },
        imgHeight: {
          value: config.imageHeight
        },
        imgAlign: {
          value: config.imageAlign
        },
        imgUrl: {
          value: config.imageURL
        },
        id: {
          value: config.id,
          disabled: true
        },
        link: {
          value: config.link
        },
        dataset: {
          innerHTML: '<option value="' + seriesId + '">' + seriesName + seriesId + '</option>',
          disabled: true
        },
        datasetIndex: datasetIndex
      }, true);
    }, CLEAR_TIME_1000);
  };

  /**
   * Function to draw connectors during dragging of the nodes
   * @param {Object} connectorsObj Contains information about connector object that is to be re-drawn
   * @param {number} datasetIndex The index of the dataset to which the connector belongs
   */


  DragNodeGroup.prototype.drawNodeConnectors = function drawNodeConnectors(connectorsObj, datasetIndex) {
    var manager = this,
        connectors = manager.getChildren('connector'),
        i,
        connectorSet,
        connector,
        fromObj,
        toObj;
    if (!connectorsObj) {
      return;
    }
    for (i in connectorsObj) {
      connector = connectorsObj[i];
      if (connector) {
        // datasetIndex = connector.config.datasetIndex;
        fromObj = connector.config.fromPointObj;
        toObj = connector.config.toPointObj;
        connectorSet = connectors[datasetIndex];

        if (connectorSet) {
          connectorSet && connectorSet.parsePlotAttributes(connector, fromObj, toObj);
          connectorSet && connectorSet.drawConnector(connector, fromObj, toObj);
        }
      }
    }
  };

  /**
   * Function to clear all the connectors if chart is updated.
   */


  DragNodeGroup.prototype._clearConnectors = function _clearConnectors() {
    var manager = this,
        nodes = manager.getNode(),
        id,
        startConnectors,
        endConnectors,
        graphics,
        j,
        node;
    // Deleting all connectors from nodes object
    for (id in nodes) {
      node = nodes[id];
      if (node) {
        startConnectors = node.config.startConnectors || {};
        endConnectors = node.config.endConnectors || {};
        for (j in startConnectors) {
          graphics = {
            graphics: startConnectors[j].graphics || {}
          };
          _lib.componentDispose.call(graphics);
        }
        for (j in endConnectors) {
          graphics = {
            graphics: endConnectors[j].graphics || {}
          };
          _lib.componentDispose.call(graphics);
        }
      }
    }
    // // Clearing nodes object
    // manager.nodes = {};
  };

  /**
   * Function to get the jsonData from the datasets
   * @return {Object} data from the dataset
   */


  DragNodeGroup.prototype.getJSONData = function getJSONData() {
    var manager = this,
        children = manager.getChildren(),
        nodeSets = children.dataset,
        connectorSets = children.connector,
        labelSets = children.labels,
        jsonData = {},
        i,
        len,
        dataset;
    jsonData.dataset = [];
    jsonData.connectors = [];
    jsonData.labels = [];

    for (i = 0, len = nodeSets && nodeSets.length; i < len; i++) {
      dataset = nodeSets[i];
      if (!jsonData.dataset[i]) {
        jsonData.dataset[i] = (0, _lib.extend2)({}, dataset.JSONData);
      }
      jsonData.dataset[i].data = dataset.getJSONData();
    }
    for (i = 0, len = connectorSets && connectorSets.length; i < len; i++) {
      dataset = connectorSets[i];
      if (!jsonData.connectors[i]) {
        jsonData.connectors[i] = (0, _lib.extend2)({}, dataset.JSONData);
      }
      jsonData.connectors[i].connector = dataset.getJSONData();
    }
    for (i = 0, len = labelSets && labelSets.length; i < len; i++) {
      dataset = labelSets[i];
      if (!jsonData.labels[i]) {
        jsonData.labels[i] = {
          label: []
        };
      }
      jsonData.labels[i].label = dataset.getJSONData();
    }
    return jsonData;
  };

  return DragNodeGroup;
}(_componentInterface2['default']);

exports['default'] = DragNodeGroup;

/***/ }),

/***/ 787:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var jsonData = chart.getFromEnv('dataSource'),
      datasetsJSON = jsonData.dataset,
      connectorsJSON = jsonData.connectors,
      labels = jsonData.labels,
      children = chart.getChildren(),
      canvas = children.canvas[0],
      vCanvas = void 0,
      datasetParent = vCanvas = canvas.getChildren('vCanvas')[0],
      DsGroupClass = void 0,
      setType = [],
      groupManager = void 0;
  labels && (labels = [labels]);
  if (!datasetsJSON && !connectorsJSON && !labels) {
    chart.setChartMessage();
    return;
  }
  DsGroupClass = chart.getDSGroupdef();
  (0, _lib.componentFactory)(vCanvas, DsGroupClass, 'datasetGroup_dragNode');
  groupManager = vCanvas.getChildren('datasetGroup_dragNode');
  groupManager && (datasetParent = groupManager[0]);
  if (datasetsJSON && datasetsJSON.length) {
    (0, _lib.componentFactory)(datasetParent, chart.getDSdef('dragnode'), 'dataset', datasetsJSON.length, datasetsJSON);
  } else {
    setType.push('dataset');
  }
  if (connectorsJSON && connectorsJSON.length) {
    (0, _lib.componentFactory)(datasetParent, chart.getDSdef('connector'), 'connector', connectorsJSON.length, connectorsJSON);
  } else {
    setType.push('connector');
  }
  if (labels && labels.length) {
    (0, _lib.componentFactory)(datasetParent, chart.getDSdef('dragableLabels'), 'labels', labels.length, labels);
  } else {
    setType.push('labels');
  }
  setType.length && removeSets(datasetParent, setType);
};

var _lib = __webpack_require__(5);

var removeSets = function removeSets(parent, set) {
  var children = parent.getChildren(),
      childArr = void 0,
      j = void 0,
      i = void 0;
  if (set && set.length) {
    for (i = set.length - 1; i > -1; i--) {
      childArr = children[set[i]];
      for (j = childArr && childArr.length - 1; j > -1; childArr[j].remove(), j--) {}
    }
  }
};
/**
 * function to  create dataset, groupmaneger.
 * assign dataset to group manager.
 **/

/***/ }),

/***/ 788:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var canvas = chart.getChildren('canvas')[0],
      axisRefVisualCartesian = canvas.getChildren('axisRefVisualCartesian')[0],
      zoomObj = {
    zoomable: true,
    pannable: true
  },
      config = chart._feedAxesRawData(),
      yAxis = void 0,
      xAxis = void 0,
      redraw = function redraw() {
    return axisRefVisualCartesian.asyncDraw();
  };

  (0, _lib.componentFactory)(chart, _log2['default'], 'yAxis', 1, config.yAxisConf);
  (0, _lib.componentFactory)(chart, _category2['default'], 'xAxis', 1, config.xAxisConf);

  yAxis = chart.getChildren('yAxis')[0];
  xAxis = chart.getChildren('xAxis')[0];
  yAxis.setLinkedItem('canvas', canvas);
  xAxis.setLinkedItem('canvas', canvas);
  axisRefVisualCartesian.setLinkedItem(yAxis.getId(), yAxis);
  axisRefVisualCartesian.setLinkedItem(xAxis.getId(), xAxis);

  axisRefVisualCartesian.addExtEventListener('visiblerangeset', redraw, xAxis);
  axisRefVisualCartesian.addExtEventListener('visiblerangeset', redraw, yAxis);

  canvas.attachAxis(xAxis, false, chart.zoomX ? zoomObj : {});
  canvas.attachAxis(yAxis, true, chart.zoomY ? zoomObj : {});

  chart._setCategories();
};

var _lib = __webpack_require__(5);

var _log = __webpack_require__(789);

var _log2 = _interopRequireDefault(_log);

var _category = __webpack_require__(88);

var _category2 = _interopRequireDefault(_category);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 789:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _cartesian = __webpack_require__(200);

var _cartesian2 = _interopRequireDefault(_cartesian);

var _log = __webpack_require__(790);

var _log2 = _interopRequireDefault(_log);

var _diff = __webpack_require__(87);

var _diff2 = _interopRequireDefault(_diff);

var _pair = __webpack_require__(797);

var _pair2 = _interopRequireDefault(_pair);

var _lib = __webpack_require__(5);

var _assign = __webpack_require__(54);

var _assign2 = _interopRequireDefault(_assign);

var _commonApi = __webpack_require__(55);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var validate = function validate(param) {
  if (param === null || param === _lib.UNDEF || param === '' || isNaN(param)) {
    // Variable is not specified - so return false.
    return false;
  } else {
    // Variable is specified - so return true.
    return true;
  }
},
    queryOptions = { wrtVisible: true },
    POSITION_START = _lib.preDefStr.POSITION_START,
    POSITION_TOP = _lib.preDefStr.POSITION_TOP,
    POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
    POSITION_END = _lib.preDefStr.POSITION_END,
    LABEL_ID = '_label';

var LogAxis = function (_CartesianAxis) {
  _inherits(LogAxis, _CartesianAxis);

  function LogAxis() {
    _classCallCheck(this, LogAxis);

    var _this = _possibleConstructorReturn(this, _CartesianAxis.call(this));

    _this.config.scale = new _log2['default']();
    _this.config.labelMap = [];
    return _this;
  }

  /**
   * Sets the default configuration of the axis
   */


  LogAxis.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _CartesianAxis.prototype.__setDefaultConfig && _CartesianAxis.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    config.base = 10;
    config.showMinorDivLineValues = 1;
    config.numMinorDivLines = _lib.UNDEF;
  };

  /**
   * Sets the name of the component
   * @return {string} name
   */


  LogAxis.prototype.getName = function getName() {
    return 'log';
  };

  /**
   * Prepare the axis attributes for use by the chart drawing. It applies some log specific
   * values to the axis' configuration.
   * @param  {Object}  rawAttr The raw attributes to be set
   */


  LogAxis.prototype.configureAttributes = function configureAttributes(rawAttr) {
    var axis = this,
        axisConfig = axis.config,
        numberFormatter = axis.getFromEnv('number-formatter'),
        colorM = axis.getFromEnv('color-manager'),
        axisAttr;

    _CartesianAxis.prototype.configureAttributes.call(this, rawAttr);
    axisAttr = axisConfig.rawAttr;

    axisConfig.minorDivlinecolor = (0, _lib.convertColor)((0, _lib.pluck)(axisAttr.minorDivlinecolor, colorM.getColor('divLineColor')), (0, _lib.pluckNumber)(axisAttr.minorDivLineAlpha, colorM.getColor('divLineAlpha') / 2));
    axisConfig.axisMinValue = numberFormatter.getCleanValue(axisAttr.axisMinValue);
    axisConfig.axisMaxValue = numberFormatter.getCleanValue(axisAttr.axisMaxValue);
    axisConfig.minorTicks = [];

    if (axisConfig.axisMinValue <= 0) {
      axisConfig.axisMinValue = _lib.UNDEF;
    }

    if (axisConfig.axisMaxValue <= 0) {
      axisConfig.axisMaxValue = _lib.UNDEF;
    }
    axis.getScale().setBase(axisConfig.base);
    axisConfig.minorDivLineThickness = (0, _lib.pluckNumber)(axisAttr.minorDivLineThickness, 1);
    axisConfig.band.isDraw = 0;
  };

  LogAxis.prototype.generateTicks = function generateTicks() {
    var ticks = this.getScale().ticks();
    this.config._allTicks = ticks.slice();
    return ticks;
  };

  /**
   * Generates minor ticks between every majot tick visible in the current visible range
   */


  LogAxis.prototype.generateMinorTicks = function generateMinorTicks() {
    var axis = this,
        _axis$getScale$getDom = axis.getScale().getDomain(),
        min = _axis$getScale$getDom[0],
        max = _axis$getScale$getDom[1],
        axisConfig = axis.config,
        base = axisConfig.base,
        tickPairs = (0, _pair2['default'])(axisConfig.ticks),
        i = void 0,
        minorTicks = [],
        baseWithRespectTo10 = Math.log(base) / Math.log(10),
        numMinorDivLines = Number(axisConfig.numMinorDivLines) || baseWithRespectTo10 % 1 ? 4 : 8,
        d = base > 1 ? -1 : 1,
        maxLogY = void 0,
        subInterval = void 0,
        slabInterval = void 0,
        divLineValue = void 0;

    // for base greater than one
    if (base > 1) {
      maxLogY = Math.ceil(Math.log(max) / Math.log(base));
    } else if (base > 0 && base < 1) {
      maxLogY = Math.floor(Math.log(max) / Math.log(base));
    }

    tickPairs.forEach(function () {
      // Multiplication factor
      // For base <1, powers go in negative -0.1 is 10^-1, 0.001 is 10 ^ -3 and so on.
      // Numeric interval between two succesive major divLines (variable)
      slabInterval = Math.pow(base, maxLogY) - Math.pow(base, maxLogY + d);
      // Numeric interval between two succesive minor divLines (variable) in between 2
      // successive major divLines
      subInterval = slabInterval / (numMinorDivLines + 1);

      for (i = 1; i <= numMinorDivLines; ++i) {
        // Get the numeric value for minor div line
        // By adding the sub-interval to power of base (of major div line)
        divLineValue = Math.pow(base, maxLogY + d) + subInterval * i;

        if (min <= divLineValue && max >= divLineValue) {
          minorTicks.push(divLineValue);
        }
      }

      // Update counter corresponding to next major divLine w.r.t. base value
      base > 1 ? maxLogY-- : maxLogY++;
    });

    return minorTicks;
  };

  LogAxis.prototype._setAxisRange = function _setAxisRange(_ref) {
    var min = _ref.min,
        max = _ref.max;

    var scale = this.getScale().setDomain([min, max]).nice(),
        axisConfig = this.config,
        axisRange = axisConfig.axisRange;

    axisConfig.ticks = this.generateTicks();

    var _scale$getDomain = scale.getDomain();

    min = _scale$getDomain[0];
    max = _scale$getDomain[1];

    axisRange.max = max;
    axisRange.min = min;

    this.setVisibleConfig(min, max);
  };

  LogAxis.prototype.setDataLimit = function setDataLimit(max, min) {
    var axis = this,
        axisConfig = axis.config,
        AxisMaxValue = axisConfig.axisMaxValue,
        AxisMinValue = axisConfig.axisMinValue,
        trendMin,
        trendMax;

    if (validate(AxisMinValue) && Number(AxisMinValue) <= min) {
      min = AxisMinValue;
    }
    if (validate(AxisMaxValue) && Number(AxisMaxValue) >= max) {
      max = AxisMaxValue;
    }

    if (min === 0) {
      min = 1;
    }
    if (max === 0) {
      max = axisConfig.base;
    }

    var _axis$_getTrendLineLi = axis._getTrendLineLimits();

    trendMin = _axis$_getTrendLineLi[0];
    trendMax = _axis$_getTrendLineLi[1];

    var _extent = (0, _lib.extent)([trendMin, trendMax, min, max], function (a) {
      return Number(a);
    });

    min = _extent[0];
    max = _extent[1];


    this._setAxisRange({ min: min, max: max });
  };

  LogAxis.prototype._parseLabel = function _parseLabel() {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        axisRange = axisConfig.axisRange,
        isOpposit = axisConfig.isOpposit,
        increment,
        labels = axisConfig.labels,
        style = labels.style,
        i,
        isVertical = axisConfig.isVertical,
        max = axisRange.max,
        min = axisRange.min,
        canvasBottom = chartConfig.canvasBottom,
        canvasLeft = chartConfig.canvasLeft,
        canvasRight = chartConfig.canvasRight,
        canvasTop = chartConfig.canvasTop,
        axisPadding = axisConfig.labelPadding,
        numberFormatter = axis.getFromEnv('number-formatter'),
        axisValueMaxH = axisConfig.labelMaxH,
        axisValueMaxW = axisConfig.labelMaxW,
        axisStartPosition = axisConfig.axisStartPosition,
        text,
        getLimit,
        labelRotation,
        labelLineHeight,
        numberFormatterFn,
        addCategoryPadding,
        axisAttrObj,
        allTicks = [],
        ticksLen,
        ticksVal,
        ticksInPx,
        prevPos,
        majorTicks = axisConfig.ticks,
        minorTicks = axisConfig.minorTicks,
        checkForLimit;

    if (style.lineHeight) {
      labelLineHeight = style.lineHeight;
      if (labelLineHeight.indexOf('px') !== -1) {
        labelLineHeight = labelLineHeight.replace('px', '');
        labelLineHeight = parseFloat(labelLineHeight);
      }
    }
    // checking if labels are to be drawn user can decide or can be decided by axis placeAxis function
    if (axisConfig.labels.isDraw) {
      checkForLimit = axis.getZoom() !== 1;

      // initialize the increment by taking account the label step
      axisConfig.labels.step ? increment = axisRange.tickInterval * axisConfig.labels.step : increment = axisRange.tickInterval;
      labelRotation = axisConfig.labels.rotation;
      // intelligently calculate the loop max and loop min from the visual active dataset
      // get the visible configuration means the value between the dataset is visible
      getLimit = this.getVisibleConfig();

      // Common style attribute for both axis
      axisAttrObj = {
        fill: style.color,
        'font-size': style.fontSize
      };

      allTicks = majorTicks.concat(minorTicks);
      allTicks.sort(function (a, b) {
        return a - b;
      }).reverse();

      ticksLen = allTicks.length;
      for (i = 0; i < ticksLen; i++) {
        ticksVal = allTicks[i];
        ticksInPx = axis.getPixel(ticksVal, queryOptions);
        // if minor div and minor value is set to display none
        if (minorTicks.indexOf(ticksVal) >= 0 && !axisConfig.showMinorDivLineValues) {
          continue;
        }
        // check for overlap
        if (prevPos) {
          if (ticksInPx > prevPos - axisConfig.labelMaxH && ticksInPx < prevPos + axisConfig.labelMaxH) {
            continue;
          }
        }
        // if value is not between the visual limit increment it and continue
        if (checkForLimit && (ticksVal < getLimit.minValue || ticksVal > getLimit.maxValue)) {
          continue;
        }
        // if values are not limit value and label drawing is off other
        // than limit increment it and continue
        if (!axisConfig.labels.drawNormalVal && !(axisConfig.labels.drawLimitVal && (ticksVal === min || ticksVal === max))) {
          continue;
        }
        if (!axisConfig.labels.drawNormalVal && !(ticksVal === min || ticksVal === max)) {
          continue;
        }
        // if value are limit value but limit value are not mean to be drawn
        if (!axisConfig.labels.drawLimitVal && (ticksVal === min || ticksVal === max)) {
          continue;
        }
        // if value is zero and show zero plane is off
        if (axisConfig.showZeroPlaneValue === 0 && axisConfig.showZeroPlane === 0 && ticksVal === 0) {
          continue;
        }
        // For overlapping of 0 and other value give priority to zero value
        if (axisConfig.showZeroPlane === 1 && axisConfig.showZeroPlaneValue === 1 && (ticksVal < 0 && ticksVal + increment > 0 || ticksVal > 0 && ticksVal - increment < 0)) {
          if (isVertical) {
            if (ticksInPx + axisValueMaxH >= axis.getPixel(0, queryOptions) && axis.getPixel(0, queryOptions) >= ticksInPx - axisValueMaxH) {
              continue;
            }
          } else {
            if (ticksInPx + axisValueMaxW >= axis.getPixel(0, queryOptions) && axis.getPixel(0, queryOptions) >= ticksInPx - axisValueMaxW) {
              continue;
            }
          }
        }

        // make the attribute ready to use
        // y-axis
        if (isVertical) {
          if (axisConfig.numberFormatterFn) {
            numberFormatterFn = numberFormatter[axisConfig.numberFormatterFn];
          } else if (axisConfig.isPercent) {
            numberFormatterFn = numberFormatter.percentValue;
          } else {
            numberFormatterFn = numberFormatter.yAxis;
          }
          text = '' + numberFormatterFn.call(numberFormatter, ticksVal);
          // @temp
          addCategoryPadding = axisConfig.hasCategory ? axisConfig.categories.category[i].labelPadding || 0 : 0;
          axisAttrObj['text-anchor'] = isOpposit ? POSITION_START : POSITION_END;
          axisAttrObj.text = text;
          axisAttrObj.x = isOpposit ? (axisStartPosition || canvasRight) + axisPadding : (axisStartPosition || canvasLeft) - axisPadding;
          axisAttrObj.y = addCategoryPadding ? ticksInPx + addCategoryPadding : ticksInPx;
          prevPos = axisAttrObj.y;
          // x-axis
        } else {
          if (axisConfig.numberFormatterFn) {
            numberFormatterFn = numberFormatter[axisConfig.numberFormatterFn];
          } else if (axisConfig.isPercent) {
            numberFormatterFn = numberFormatter.percentValue;
          } else {
            numberFormatterFn = numberFormatter.xAxis;
          }
          text = '' + numberFormatterFn.call(numberFormatter, ticksVal);
          // @temp
          addCategoryPadding = axisConfig.hasCategory ? Number(axisConfig.categories.category[i].labelPadding) || 0 : 0;
          axisAttrObj.text = text;
          axisAttrObj.x = ticksInPx;
          axisAttrObj.y = isOpposit ? (axisStartPosition || canvasTop) - axisPadding : (axisStartPosition || canvasBottom) + axisPadding;
          if (addCategoryPadding) {
            axisAttrObj.y += addCategoryPadding;
          }
          if (labelRotation) {
            axisAttrObj['text-anchor'] = isOpposit ? POSITION_START : POSITION_END;
            axisAttrObj['vertical-align'] = 'center';
          } else {
            axisAttrObj['vertical-align'] = isOpposit ? POSITION_BOTTOM : POSITION_TOP;
          }
          prevPos = axisAttrObj.x;
        }

        // If labels shift is applicable (Specially for 3D) then apply the changes
        if (labels.shiftX) {
          axisAttrObj.x += labels.shiftX;
        }
        if (labels.shiftY) {
          axisAttrObj.y += labels.shiftY;
        }
        axisAttrObj.transform = (0, _lib.getSuggestiveRotation)(labelRotation, axisAttrObj.x, axisAttrObj.y);
        // check if extra label element is present don't draw it just use it by changing the attributes
        axis.components.labels[i].config.props.label.attr = (0, _assign2['default'])(axis.components.labels[i].config.props.label.attr, axisAttrObj);
        axis.components.labels[i].config.props.label.css = text.css;
      }
    }
  };

  LogAxis.prototype._drawLabel = function _drawLabel() {
    var axis = this,
        axisConfig = axis.config,
        animationManager = axis.getFromEnv('animationManager'),
        axisRange = axisConfig.axisRange,
        increment,
        labels = axisConfig.labels,
        style = labels.style,
        i,
        isVertical = axisConfig.isVertical,
        max = axisRange.max,
        min = axisRange.min,
        axisContainer = axisConfig.axisContainer,
        axisValueMaxH = axisConfig.labelMaxH,
        axisValueMaxW = axisConfig.labelMaxW,
        id,
        mapArr = [],
        removeElementsArr,
        removeElem,
        textElement,
        getLimit,
        css = {
      fontFamily: style.fontFamily,
      fontSize: style.fontSize,
      fontWeight: style.fontWeight,
      fontStyle: style.fontStyle,
      lineHeight: style.lineHeight
    },
        allTicks = [],
        ticksLen,
        ticksVal,
        ticksInPx,
        prevPos,
        majorTicks = axisConfig.ticks,
        minorTicks = axisConfig.minorTicks,
        checkForLimit,
        removeElements = function removeElements(arrOfId) {
      for (i = 0; i < arrOfId.length; ++i) {
        removeElem = axis.getGraphicalElement(arrOfId[i]);
        if (removeElem) {
          axis._spliceGraphicalElement(animationManager.setAnimation({
            el: removeElem,
            container: axisContainer,
            data: {
              value: +arrOfId[i].split('_')[0]
            },
            callback: function callback() {
              this.remove();
            },
            component: axis,
            label: 'text'
          }));
        }
      }
    };

    // checking if labels are to be drawn user can decide or can be decided by axis placeAxis function
    if (axisConfig.labels.isDraw) {
      checkForLimit = axis.getZoom() !== 1;

      // initialize the increment by taking account the label step
      axisConfig.labels.step ? increment = axisRange.tickInterval * axisConfig.labels.step : increment = axisRange.tickInterval;
      getLimit = this.getVisibleConfig();

      axisContainer.css(css);

      allTicks = majorTicks.concat(minorTicks);
      allTicks.sort(function (a, b) {
        return a - b;
      }).reverse();

      ticksLen = allTicks.length;
      for (i = 0; i < ticksLen; i++) {
        ticksVal = allTicks[i];
        ticksInPx = axis.getPixel(ticksVal, queryOptions);
        // if minor div and minor value is set to display none
        if (minorTicks.indexOf(ticksVal) >= 0 && !axisConfig.showMinorDivLineValues) {
          continue;
        }
        // check for overlap
        if (prevPos) {
          if (ticksInPx > prevPos - axisConfig.labelMaxH && ticksInPx < prevPos + axisConfig.labelMaxH) {
            continue;
          }
        }
        // if value is not between the visual limit increment it and continue
        if (checkForLimit && (ticksVal < getLimit.minValue || ticksVal > getLimit.maxValue)) {
          continue;
        }
        // if values are not limit value and label drawing is off other
        // than limit increment it and continue
        if (!axisConfig.labels.drawNormalVal && !(axisConfig.labels.drawLimitVal && (ticksVal === min || ticksVal === max))) {
          continue;
        }
        if (!axisConfig.labels.drawNormalVal && !(ticksVal === min || ticksVal === max)) {
          continue;
        }
        // if value are limit value but limit value are not mean to be drawn
        if (!axisConfig.labels.drawLimitVal && (ticksVal === min || ticksVal === max)) {
          continue;
        }
        // if value is zero and show zero plane is off
        if (axisConfig.showZeroPlaneValue === 0 && axisConfig.showZeroPlane === 0 && ticksVal === 0) {
          continue;
        }
        // For overlapping of 0 and other value give priority to zero value
        if (axisConfig.showZeroPlane === 1 && axisConfig.showZeroPlaneValue === 1 && (ticksVal < 0 && ticksVal + increment > 0 || ticksVal > 0 && ticksVal - increment < 0)) {
          if (isVertical) {
            if (ticksInPx + axisValueMaxH >= axis.getPixel(0, queryOptions) && axis.getPixel(0, queryOptions) >= ticksInPx - axisValueMaxH) {
              continue;
            }
          } else {
            if (ticksInPx + axisValueMaxW >= axis.getPixel(0, queryOptions) && axis.getPixel(0, queryOptions) >= ticksInPx - axisValueMaxW) {
              continue;
            }
          }
        }

        id = ticksVal + LABEL_ID;
        textElement = axis.getGraphicalElement(id);
        mapArr.push(id);
        textElement = this.addGraphicalElement(id, animationManager.setAnimation({
          container: axisContainer,
          el: textElement || 'text',
          attr: axis.components.labels[i].config.props.label.attr,
          data: {
            value: ticksVal
          },
          component: this,
          dom: 'text',
          css: axis.components.labels[i].config.props.label.css
        }));
      }
      removeElementsArr = (0, _diff2['default'])(axisConfig.labelMap, mapArr);
    } else {
      removeElementsArr = axisConfig.labelMap;
    }
    axisConfig.labelMap = mapArr;
    removeElements(removeElementsArr);
  };

  LogAxis.prototype._getVMaxLabelDimention = function _getVMaxLabelDimention() {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        smartLabel = axis.getFromEnv('smartLabel'),
        numberFormatter = axis.getFromEnv('number-formatter'),

    // axisRange = axisConfig.axisRange,
    labelStyle = axisConfig.labels.style,
        maxTextSize = 0,
        divArr = axisConfig.ticks.concat(axisConfig.minorTicks),
        divArrLen = divArr.length,
        maxText,
        i,
        text,
        dimention,
        numberFormatterFn,
        curDiv;

    smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
    smartLabel.setStyle({
      fontSize: labelStyle.fontSize,
      fontFamily: labelStyle.fontFamily,
      lineHeight: labelStyle.lineHeight,
      fontWeight: labelStyle.fontWeight
    });
    if (!axis.components) {
      axis.components = {};
      axis.components.labels = [];
    }

    if (axisConfig.isPercent) {
      numberFormatterFn = numberFormatter.percentValue;
    } else {
      numberFormatterFn = numberFormatter.xAxis;
    }

    for (i = 0; i < divArrLen; i++) {
      curDiv = divArr[i];
      text = '' + numberFormatterFn.call(numberFormatter, curDiv);

      dimention = smartLabel.getOriSize(text);
      axis.components.labels[i] = {
        config: {
          props: {
            label: {
              attr: {
                width: dimention.width,
                height: dimention.height
              }
            }
          }
        }
      };
      if (text.length > maxTextSize) {
        maxText = text;
        maxTextSize = text.length;
      }
    }
    return smartLabel.getOriSize(maxText);
  };

  LogAxis.prototype._getHMaxLabelDimention = function _getHMaxLabelDimention() {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        smartLabel = axis.getFromEnv('smartLabel'),
        numberFormatter = axis.getFromEnv('number-formatter'),

    // axisRange = axisConfig.axisRange,
    labelStyle = axisConfig.labels.style,
        maxTextSize = 0,
        divArr = axisConfig.ticks.concat(axisConfig.minorTicks),
        divArrLen = divArr.length,
        maxText,
        i,
        text,
        dimention,
        numberFormatterFn,
        curDiv;

    smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
    smartLabel.setStyle({
      fontSize: labelStyle.fontSize,
      fontFamily: labelStyle.fontFamily,
      lineHeight: labelStyle.lineHeight,
      fontWeight: labelStyle.fontWeight
    });

    if (!axis.components) {
      axis.components = {};
      axis.components.labels = [];
    }
    if (axisConfig.isPercent) {
      numberFormatterFn = numberFormatter.percentValue;
    } else {
      numberFormatterFn = numberFormatter.xAxis;
    }

    for (i = 0; i < divArrLen; i++) {
      curDiv = divArr[i];
      text = '' + numberFormatterFn.call(numberFormatter, curDiv);

      dimention = smartLabel.getOriSize(text);
      axis.components.labels[i] = {
        config: {
          props: {
            label: {
              attr: {
                width: dimention.width,
                height: dimention.height
              }
            }
          }
        }
      };
      if (text.length > maxTextSize) {
        maxText = text;
        maxTextSize = text.length;
      }
    }
    return smartLabel.getOriSize(maxText);
  };

  LogAxis.prototype.getCleanValue = function getCleanValue(num) {
    var axis = this,
        value = null;
    num = Math.abs(num);
    if (num > 0) {
      value = axis.getFromEnv('number-formatter').getCleanValue(num);
    }
    return value;
  };

  return LogAxis;
}(_cartesian2['default']);

LogAxis.prototype._getTrendLineLimits = _commonApi._getTrendLineLimits;

exports['default'] = LogAxis;

/***/ }),

/***/ 790:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _log = __webpack_require__(791);

var _log2 = _interopRequireDefault(_log);

var _log3 = __webpack_require__(794);

var _log4 = _interopRequireDefault(_log3);

var _constant = __webpack_require__(197);

var _constant2 = _interopRequireDefault(_constant);

var _continuous = __webpack_require__(130);

var _continuous2 = _interopRequireDefault(_continuous);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var deinterpolate = function deinterpolate(min, max) {
  return (max = Math.log(max / min)) ? function (ratio) {
    return Math.log(ratio / min) / max;
  } : (0, _constant2['default'])(max);
},
    reinterpolate = function reinterpolate(min, max) {
  return min < 0 ? function (ratio) {
    return -Math.pow(-max, ratio) * Math.pow(-min, 1 - ratio);
  } : function (ratio) {
    return Math.pow(max, ratio) * Math.pow(min, 1 - ratio);
  };
},
    pow10 = function pow10(x) {
  if (isFinite(x)) {
    return +('1e' + x);
  } else if (x < 0) {
    return 0;
  } else {
    return x;
  }
},
    powp = function powp(base) {
  if (base === 10) {
    return pow10;
  } else if (base === Math.E) {
    return Math.exp;
  } else {
    return function (x) {
      return Math.pow(base, x);
    };
  }
},
    logp = function logp(base) {
  if (base === Math.E) {
    return Math.log;
  } else if (base === 10) {
    return _log4['default'];
  } else if (base === 2) {
    return _log2['default'];
  } else {
    return function (x) {
      return Math.log(x) / Math.log(base);
    };
  }
},
    reflect = function reflect(f) {
  return function (x) {
    return -f(-x);
  };
};

var ScaleLog = function (_ScaleContinuous) {
  _inherits(ScaleLog, _ScaleContinuous);

  function ScaleLog() {
    var _this;

    _classCallCheck(this, ScaleLog);

    (_this = _possibleConstructorReturn(this, _ScaleContinuous.call(this, deinterpolate, reinterpolate)), _this).setDomain([1, 10]);
    _this.base = 10;
    _this.logs = logp(_this.base);
    _this.pows = powp(_this.base);
    return _this;
  }

  ScaleLog.prototype._rescaleLog = function _rescaleLog() {
    this.logs = logp(this.base);
    this.pows = powp(this.base);

    if (this.getDomain()[0] < 0) {
      this.logs = reflect(this.logs);
      this.pows = reflect(this.pows);
    }

    return this;
  };

  ScaleLog.prototype.setBase = function setBase() {
    var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

    this.base = Number(base);
    return this._rescaleLog();
  };

  ScaleLog.prototype.getBase = function getBase() {
    return this.base;
  };

  ScaleLog.prototype.setDomain = function setDomain() {
    var domain = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [1, 10];

    _ScaleContinuous.prototype.setDomain.call(this, domain);
    return this._rescaleLog();
  };

  ScaleLog.prototype.nice = function nice() {
    var _getDomain = this.getDomain(),
        val1 = _getDomain[0],
        val2 = _getDomain[1],
        base = this.base,
        minLog,
        maxLog;

    // If the minValue and the maxValue are same then there is a rendering problem
    // To avoid the rendering problem set the minValue to little higher value


    if (val1 === val2) {
      val1 -= val1 / 100;
    }

    minLog = Math.log(val1) / Math.log(base);
    maxLog = Math.log(val2) / Math.log(base);
    if (minLog % 1 || maxLog % 1) {
      if (val1 <= val2) {
        val1 = this.pows(Math.floor(minLog));
        val2 = this.pows(Math.ceil(maxLog));
      } else {
        val1 = this.pows(Math.ceil(minLog));
        val2 = this.pows(Math.floor(maxLog));
      }
      this.setDomain([val1, val2]);
    }
    return this;
  };

  ScaleLog.prototype.ticks = function ticks() {
    var _getDomain2 = this.getDomain(),
        min = _getDomain2[0],
        max = _getDomain2[1],
        maxLogY,
        isReverse = 1,
        minLogY,
        iniValue,
        checkValue,
        counter = 0,
        divLines = [],
        divLineValue,
        r,
        i,
        base = this.base;

    if (min <= 0 || max <= 0) {
      return divLines;
    }

    if (min > max) {
      var _getDomain3 = this.getDomain();

      max = _getDomain3[0];
      min = _getDomain3[1];

      isReverse = 0;
    }

    // for base greater than one
    if (base > 1) {
      maxLogY = Math.ceil(Math.log(max) / Math.log(base));
      minLogY = Math.floor(Math.log(min) / Math.log(base));
      iniValue = maxLogY;
      checkValue = minLogY;
    } else if (base > 0 && base < 1) {
      maxLogY = Math.floor(Math.log(max) / Math.log(base));
      minLogY = Math.ceil(Math.log(min) / Math.log(base));
      iniValue = minLogY;
      checkValue = maxLogY;
    }

    r = maxLogY;
    for (i = iniValue; i >= checkValue; --i) {
      // Select the major divLines
      // Conditions for major div lines:
      // 1. If y-axis is inverted and div value is not the very first one
      //    (the lowest one coinciding with x-axis)
      // OR
      // 2. If y-axis is not inverted and div value is not the very last one
      //    (the lowest one coinciding with x-axis)
      // if ((invertYAxis && r != maxLogY) || !(invertYAxis || i == checkValue)) {
      // Get the numerical value of div line by getting power of base.
      divLineValue = this.pows(r);
      // Create the div line object
      // conditional to avoid plot of major divLines and their axis labels beyond plot area

      if (min <= divLineValue && max >= divLineValue) {
        divLines[counter++] = divLineValue;
      }
      // Update counter corresponding to next major divLine w.r.t. base value
      if (base > 1) {
        r--;
      } else {
        r++;
      }
    }
    return isReverse ? divLines.reverse() : divLines;
  };

  ScaleLog.prototype.copy = function copy() {
    return (0, _continuous.copyScale)(this, new ScaleLog().setBase(this.base));
  };

  return ScaleLog;
}(_continuous2['default']);

exports['default'] = ScaleLog;

/***/ }),

/***/ 791:
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(792), __esModule: true };

/***/ }),

/***/ 792:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(793);
module.exports = __webpack_require__(19).Math.log2;


/***/ }),

/***/ 793:
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(26);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),

/***/ 794:
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(795), __esModule: true };

/***/ }),

/***/ 795:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(796);
module.exports = __webpack_require__(19).Math.log10;


/***/ }),

/***/ 796:
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(26);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),

/***/ 797:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
function pair(a, b) {
  return [a, b];
}

function toPairs(arr, reducer) {
  if (reducer === null || typeof reducer === 'undefined') reducer = pair;

  var i = 0,
      n = arr.length - 1,
      p = arr[0],
      pairs = new Array(n < 0 ? 0 : n);

  while (i < n) {
    pairs[i] = reducer(p, p = arr[++i]);
  }

  return pairs;
}

exports['default'] = toPairs;

/***/ }),

/***/ 798:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(366);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _cartesian = __webpack_require__(21);

var _cartesian2 = _interopRequireDefault(_cartesian);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var LogStackedColumn2d = function (_LogMSColumn2d) {
  _inherits(LogStackedColumn2d, _LogMSColumn2d);

  function LogStackedColumn2d() {
    _classCallCheck(this, LogStackedColumn2d);

    return _possibleConstructorReturn(this, _LogMSColumn2d.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  LogStackedColumn2d.getName = function getName() {
    return 'LogStackedColumn2d';
  };

  /**
   * Sets the name of the component
   * @return {string} name
   */


  LogStackedColumn2d.prototype.getName = function getName() {
    return 'LogStackedColumn2d';
  };

  LogStackedColumn2d.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _LogMSColumn2d.prototype.__setDefaultConfig && _LogMSColumn2d.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Stacked Log Column Chart';
    config.isstacked = true;
  };

  LogStackedColumn2d.prototype.getDSGroupdef = function getDSGroupdef() {
    return _cartesian2['default'];
  };

  return LogStackedColumn2d;
}(_fusioncharts2['default']);

exports['default'] = LogStackedColumn2d;

/***/ }),

/***/ 799:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(367);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _fusioncharts3 = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var LINE = 'line';

var LogMSLine = function (_MSLog) {
  _inherits(LogMSLine, _MSLog);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  LogMSLine.getName = function getName() {
    return 'LogMSLine';
  };

  function LogMSLine() {
    _classCallCheck(this, LogMSLine);

    var _this = _possibleConstructorReturn(this, _MSLog.call(this));

    _this.defaultPlotShadow = 1;
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  LogMSLine.prototype.getName = function getName() {
    return 'LogMSLine';
  };

  LogMSLine.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSLog.prototype.__setDefaultConfig && _MSLog.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Multi-series Line Chart';
    config.defaultDatasetType = LINE;
    config.zeroplanethickness = 1;
    config.enablemousetracking = true;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
    _fusioncharts3._setDefaultConfig.call(this);
  };

  LogMSLine.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  LogMSLine.prototype.getDSdef = function getDSdef() {
    return _line2['default'];
  };

  return LogMSLine;
}(_fusioncharts2['default']);

exports['default'] = LogMSLine;

/***/ }),

/***/ 800:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(16);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _column3 = __webpack_require__(15);

var _column4 = _interopRequireDefault(_column3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var COLUMN = 'column';

var InverseMSColumn2d = function (_MSCartesian) {
  _inherits(InverseMSColumn2d, _MSCartesian);

  function InverseMSColumn2d() {
    _classCallCheck(this, InverseMSColumn2d);

    return _possibleConstructorReturn(this, _MSCartesian.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  InverseMSColumn2d.getName = function getName() {
    return 'InverseMSColumn2d';
  };

  /**
   * Sets the name of the component
   * @return {string} name
   */


  InverseMSColumn2d.prototype.getName = function getName() {
    return 'InverseMSColumn2d';
  };
  /**
   * parse defualt configuration of the chart
   */


  InverseMSColumn2d.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Inverted Y-Axis Multi-series Column Chart';
    config.defaultDatasetType = COLUMN;
    config.isInverse = true;
    config.enablemousetracking = true;
  };

  InverseMSColumn2d.prototype.getDSdef = function getDSdef() {
    return _column2['default'];
  };

  InverseMSColumn2d.prototype.getDSGroupdef = function getDSGroupdef() {
    return _column4['default'];
  };

  return InverseMSColumn2d;
}(_fusioncharts2['default']);

exports['default'] = InverseMSColumn2d;

/***/ }),

/***/ 801:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(16);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _fusioncharts3 = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var LINE = 'line';

var InverseMSLine = function (_MSCartesian) {
  _inherits(InverseMSLine, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  InverseMSLine.getName = function getName() {
    return 'InverseMSLine';
  };

  function InverseMSLine() {
    _classCallCheck(this, InverseMSLine);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.defaultPlotShadow = 1;
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  InverseMSLine.prototype.getName = function getName() {
    return 'InverseMSLine';
  };
  /**
   * parse defualt configuration of the chart
   */


  InverseMSLine.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Inverted Y-Axis Multi-series Line Chart';

    config.defaultDatasetType = LINE;
    config.isInverse = true;
    config.zeroplanethickness = 1;
    config.zeroplanealpha = 4;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
    _fusioncharts3._setDefaultConfig.call(this);
  };

  InverseMSLine.prototype.getDSdef = function getDSdef() {
    return _line2['default'];
  };

  InverseMSLine.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  return InverseMSLine;
}(_fusioncharts2['default']);

exports['default'] = InverseMSLine;

/***/ }),

/***/ 802:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(16);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _area = __webpack_require__(23);

var _area2 = _interopRequireDefault(_area);

var _fusioncharts3 = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var InverseMSArea = function (_MSCartesian) {
  _inherits(InverseMSArea, _MSCartesian);

  function InverseMSArea() {
    _classCallCheck(this, InverseMSArea);

    return _possibleConstructorReturn(this, _MSCartesian.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  InverseMSArea.getName = function getName() {
    return 'InverseMSArea';
  };

  /**
   * Sets the name of the component
   * @return {string} name
   */


  InverseMSArea.prototype.getName = function getName() {
    return 'InverseMSArea';
  };
  /**
   * parse defualt configuration of the chart
   */


  InverseMSArea.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Inverted Y-Axis Multi-series Area Chart';
    config.defaultDatasetType = 'area';
    config.isInverse = true;
    config.zeroplanethickness = 2;
    config.zeroplanealpha = 80;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
    _fusioncharts3._setDefaultConfig.call(this);
  };

  InverseMSArea.prototype.getDSdef = function getDSdef() {
    return _area2['default'];
  };

  InverseMSArea.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  return InverseMSArea;
}(_fusioncharts2['default']);

exports['default'] = InverseMSArea;

/***/ }),

/***/ 803:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(16);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _column = __webpack_require__(15);

var _column2 = _interopRequireDefault(_column);

var _errorbar2d = __webpack_require__(144);

var _errorbar2d2 = _interopRequireDefault(_errorbar2d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var ErrorBar2D = function (_MSCartesian) {
  _inherits(ErrorBar2D, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  ErrorBar2D.getName = function getName() {
    return 'ErrorBar2D';
  };

  function ErrorBar2D() {
    _classCallCheck(this, ErrorBar2D);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.showValues = 0;
    _this.isErrorChart = true;
    // this.fireGroupEvent = true;
    _this.eiMethods = {};
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  ErrorBar2D.prototype.getName = function getName() {
    return 'ErrorBar2D';
  };

  ErrorBar2D.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Error Bar Chart';
    config.hasLegend = true;
    config.defaultDatasetType = 'errorbar2d';
    config.enablemousetracking = true;
  };

  ErrorBar2D.prototype.getDSGroupdef = function getDSGroupdef() {
    return _column2['default'];
  };

  ErrorBar2D.prototype.getDSdef = function getDSdef() {
    return _errorbar2d2['default'];
  };

  return ErrorBar2D;
}(_fusioncharts2['default']);

exports['default'] = ErrorBar2D;

/***/ }),

/***/ 804:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _columnAnimation = __webpack_require__(89);

var _columnAnimation2 = _interopRequireDefault(_columnAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  column: { 'initial.dataset.errorBar2D': _columnAnimation2['default']['initial.dataset.column'] },
  error: {
    'initial.dataset.errorBar2D': function initialDatasetErrorBar2D() {
      return {
        'path.appearing': [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          slot: 'final'
        }]
      };
    }
  }
};

/***/ }),

/***/ 805:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(16);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _fusioncharts3 = __webpack_require__(17);

var _errorline = __webpack_require__(806);

var _errorline2 = _interopRequireDefault(_errorline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var ErrorLine = function (_MSCartesian) {
  _inherits(ErrorLine, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  ErrorLine.getName = function getName() {
    return 'ErrorLine';
  };

  function ErrorLine() {
    _classCallCheck(this, ErrorLine);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.useErrorGroup = true;
    _this.isErrorChart = true;
    _this.hasAnchor = true;
    // this.fireGroupEvent = true;
    _this.defaultPlotShadow = 1;
    _this.axisPaddingLeft = 0;
    _this.axisPaddingRight = 0;
    _this.canvasPaddingModifiers = ['anchor', 'errorbar'];
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  ErrorLine.prototype.getName = function getName() {
    return 'ErrorLine';
  };

  ErrorLine.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Error Line Chart';

    config.defaultDatasetType = 'errorline';
    _fusioncharts3._setDefaultConfig.call(this);
    this.zeroplanethickness = 1;
    this.zeroplanealpha = 40;
    this.showzeroplaneontop = 0;
    config.defaultcrosslinethickness = 1;
    config.enablemousetracking = true;
  };

  ErrorLine.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  ErrorLine.prototype.getDSdef = function getDSdef() {
    return _errorline2['default'];
  };

  return ErrorLine;
}(_fusioncharts2['default']);

exports['default'] = ErrorLine;

/***/ }),

/***/ 806:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _errorbar2d = __webpack_require__(144);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _dependencyManager = __webpack_require__(6);

var _errorlineErrorAnimation = __webpack_require__(368);

var _errorlineErrorAnimation2 = _interopRequireDefault(_errorlineErrorAnimation);

var _errorlineLineAnimation = __webpack_require__(807);

var _errorlineLineAnimation2 = _interopRequireDefault(_errorlineLineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var colorStrings = _lib.preDefStr.colors,
    COLOR_AAAAAA = colorStrings.AAAAAA,


// errorBarStr = preDefStr.errorBarStr,
// errorShadowStr = preDefStr.errorShadowStr,
ROUND = _lib.preDefStr.ROUND,
    PERCENTAGESTRING = _lib.preDefStr.PERCENTAGESTRING,
    BLANKSTRING = '',
    UNDEF = void 0,
    COMMASPACE = ', ',
    POINTER = 'pointer',
    TRACKER_FILL = 'rgba(192,192,192,' + (_lib.isIE ? 0.002 : 0.000001) + ')',
    // invisible but clickable

M = 'M',
    H = 'H',
    V = 'V',
    math = Math,
    mathRound = math.round,
    mathMin = math.min,
    mathMax = math.max,
    mathAbs = math.abs,
    HTP = _lib.hasTouch ? _lib.TOUCH_THRESHOLD_PIXELS : _lib.CLICK_THRESHOLD_PIXELS,
    convertColor = _lib.graphics.convertColor;
(0, _dependencyManager.addDep)({
  name: 'errorlineErrorAnimation',
  type: 'animationRule',
  extension: _errorlineErrorAnimation2['default']
});
(0, _dependencyManager.addDep)({
  name: 'errorlineLineAnimation',
  type: 'animationRule',
  extension: _errorlineLineAnimation2['default']
});

var ErrorLineDataset = function (_LINEDataset) {
  _inherits(ErrorLineDataset, _LINEDataset);

  function ErrorLineDataset() {
    _classCallCheck(this, ErrorLineDataset);

    return _possibleConstructorReturn(this, _LINEDataset.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  ErrorLineDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  ErrorLineDataset.prototype.getName = function getName() {
    return 'errorLine';
  };
  /*
   * Parses all the attributes for dataset level and set level
   * Called from init function of area class and line class
   * Both line and area attributes configuration is done here
   */

  ErrorLineDataset.prototype.ErrorValueConfigure = function ErrorValueConfigure() {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        chartConfig = chart.config,
        parentYAxis = conf.parentYAxis,
        JSONData = conf.JSONData,
        setDataArr = JSONData.data,
        chartAttr = chart.getFromEnv('dataSource').chart,
        xAxis = dataSet.getFromEnv('xAxis'),
        len = xAxis.getTicksLen(),
        setData,
        dataObj,
        config,
        dataStore = dataSet.components.data,
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        toolTipValue,
        errorBarAlpha,
        errorBarThickness,
        setErrorValue,
        formatedVal,
        setTooltext,
        positiveCumulativeErrorTooltext,
        negativeCumulativeErrorTooltext,
        positiveErrorToolText,
        negativeErrorToolText,
        errorBarShadow,
        lineThickness = conf.linethickness,
        maxValue = -Infinity,
        minValue = Infinity,
        maxErrorValue,
        minErrorValue,
        setValue,
        errorValue,
        yAxisName = (0, _lib.parseUnsafeString)(chartAttr.yaxisname),
        xAxisName = (0, _lib.parseUnsafeString)(chartAttr.xaxisname),
        cumulativeValueOnErrorBar,
        tooltipSepChar = (0, _lib.pluck)(chartAttr.tooltipsepchar, COMMASPACE),
        macroIndices,
        parserConfig,
        seriesname,
        errorInPercent,
        errorToolText,
        seriesNameInTooltip = (0, _lib.pluckNumber)(chartAttr.seriesnameintooltip, 1),
        getTooltext = function getTooltext(setTooltext) {
      var toolText;

      if (!chartConfig.showtooltip) {
        toolText = false;
      } else {
        if (formatedVal === null) {
          toolText = false;
        } else if (setTooltext !== UNDEF) {
          macroIndices = [1, 2, 3, 4, 5, 6, 7, 99, 100, 101, 102];
          parserConfig = {
            yaxisName: yAxisName,
            xaxisName: xAxisName,
            formattedValue: config.toolTipValue,
            errorValue: setErrorValue,
            errorDataValue: config.errorToolTipValue,
            errorPercentValue: config.errorPercentValue,
            errorPercentDataValue: config.errorPercentValue,
            label: config.label
          };
          toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, setData, chartAttr, JSONData);
        } else {
          if (seriesNameInTooltip) {
            seriesname = (0, _lib.getFirstValue)(JSONData && JSONData.seriesname);
          }
          toolText = seriesname ? seriesname + tooltipSepChar : BLANKSTRING;
          toolText += config.label ? config.label + tooltipSepChar : BLANKSTRING;
        }
      }
      return toolText;
    },
        i;

    conf.errorBarShadow = errorBarShadow = (0, _lib.pluckNumber)(chartAttr.errorbarshadow, chartAttr.showshadow, 1);
    conf.ignoreEmptyDatasets = (0, _lib.pluckNumber)(JSONData.ignoreemptydatasets, 0);
    // halfErrorBar = pluckNumber(chartAttr.halferrorbar, 1);
    conf.notHalfErrorBar = !(0, _lib.pluckNumber)(chartAttr.halferrorbar, 1);

    errorBarAlpha = (0, _lib.getFirstAlpha)((0, _lib.pluck)(JSONData.errorbaralpha, chartAttr.errorbaralpha, conf.alpha));
    conf.errorBarWidth = (0, _lib.pluckNumber)(JSONData.errorbarwidth, chartAttr.errorbarwidth, 5);
    conf.errorBarColor = convertColor((0, _lib.getFirstColor)((0, _lib.pluck)(JSONData.errorbarcolor, chartAttr.errorbarcolor, COLOR_AAAAAA)), errorBarAlpha);
    errorBarThickness = (0, _lib.pluckNumber)(JSONData.errorbarthickness, chartAttr.errorbarthickness, 1);
    conf.errorBarThickness = errorBarThickness > lineThickness ? lineThickness : errorBarThickness;
    conf.shadowOpacity = errorBarShadow ? errorBarAlpha / 250 : 0;

    conf.errorInPercent = errorInPercent = (0, _lib.pluckNumber)(JSONData.errorinpercent, chartAttr.errorinpercent);

    conf.cumulativeValueOnErrorBar = (0, _lib.pluckNumber)(JSONData.cumulativevalueonerrorbar, chartAttr.cumulativevalueonerrorbar, 1);

    for (i = 0; i < len; i++) {
      setData = setDataArr && setDataArr[i];

      if (!setDataArr || !setData) {
        continue;
      }

      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (!dataObj) {
        dataObj = dataStore[i] = {
          graphics: {}
        };
      }

      if (!dataObj.config) {
        config = dataStore[i].config = {};
      }

      setValue = config.setValue;

      config.notHalfErrorBar = conf.notHalfErrorBar;
      setErrorValue = numberFormatter.getCleanValue(setData.errorvalue);
      config.errorToolTipValue = numberFormatter.dataLabels(setErrorValue, parentYAxis);
      // errorPercentValue = (mathRound(((setErrorValue / setValue) * HUNDREDSTRING) * HUNDREDSTRING) /
      //               HUNDREDSTRING) + PERCENTAGESTRING;
      config.setErrorValue = config.errorValue = errorValue = setErrorValue;
      config.hasErrorValue = (0, _lib.pluckNumber)(setData.errorvalue) !== UNDEF ? 1 : 0;

      toolTipValue = config.errorToolTipValue;

      formatedVal = toolTipValue;

      // Parsing tooltext against various configurations provided by the user.
      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, formatedVal)));

      errorToolText = getTooltext(setTooltext);

      config.errorInPercent = (0, _lib.pluckNumber)(setData.errorinpercent, errorInPercent, 0);

      config.errorInPercent && (config.setErrorValue = setErrorValue = (0, _lib.pluckNumber)((setErrorValue / 100 * setValue).toFixed(2)));

      config.cumulativeValueOnErrorBar = cumulativeValueOnErrorBar = (0, _lib.pluckNumber)(setData.cumulativevalueonerrorbar, conf.cumulativeValueOnErrorBar, 1);

      config.positiveErrorValue = numberFormatter.getCleanValue((0, _lib.pluckNumber)(setData.positiveerrorvalue, setData.errorvalue));

      config.errorInPercent && config.positiveErrorValue && (config.positiveErrorValue = (0, _lib.pluckNumber)((config.positiveErrorValue / 100 * setValue).toFixed(2)));

      config.positiveCumulativeErrorValue = setValue + (0, _lib.pluckNumber)(config.positiveErrorValue, config.setErrorValue);

      config.negativeErrorValue = numberFormatter.getCleanValue((0, _lib.pluckNumber)(setData.negativeerrorvalue, setData.errorvalue));

      config.errorInPercent && config.negativeErrorValue && (config.negativeErrorValue = (0, _lib.pluckNumber)((config.negativeErrorValue / 100 * setValue).toFixed(2)));

      config.negativeCumulativeErrorValue = setValue - (0, _lib.pluckNumber)(config.negativeErrorValue, config.setErrorValue);

      config.errorToolTipValue = numberFormatter.dataLabels(setErrorValue, parentYAxis);

      config.negativeErrorToolTipValue = numberFormatter.dataLabels(config.negativeErrorValue, parentYAxis);

      config.negativeCumulativeErrorTooltipValue = numberFormatter.dataLabels(config.negativeCumulativeErrorValue, parentYAxis);

      config.positiveErrorToolTipValue = numberFormatter.dataLabels(config.positiveErrorValue, parentYAxis);

      config.positiveCumulativeErrorTooltipValue = numberFormatter.dataLabels(config.positiveCumulativeErrorValue, parentYAxis);

      config.errorPercentValue = mathRound(setErrorValue / setValue * _lib.HUNDREDSTRING * _lib.HUNDREDSTRING) / _lib.HUNDREDSTRING + PERCENTAGESTRING;

      positiveErrorToolText = negativeErrorToolText = UNDEF;
      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, config.positiveErrorToolTipValue)));

      setTooltext && config.positiveErrorToolTipValue && (positiveErrorToolText = getTooltext(setTooltext));

      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, config.negativeErrorToolTipValue)));

      setTooltext && config.negativeErrorToolTipValue && (negativeErrorToolText = getTooltext(setTooltext));

      if (setData.positiveerrorvalue || setData.negativeerrorvalue) {
        config.halfErrorBar = 0;
        config.notHalfErrorBar = true;
      }

      if (cumulativeValueOnErrorBar) {
        setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, config.positiveCumulativeErrorTooltipValue)));

        setTooltext && config.positiveCumulativeErrorTooltipValue && (positiveCumulativeErrorTooltext = getTooltext(setTooltext));

        setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, config.negativeCumulativeErrorTooltipValue)));

        setTooltext && config.negativeCumulativeErrorTooltipValue && (negativeCumulativeErrorTooltext = getTooltext(setTooltext));
      }
      maxErrorValue = setValue + (config.positiveErrorValue !== null ? config.positiveErrorValue : setErrorValue);
      minErrorValue = setValue - (config.halfErrorBar ? 0 : config.negativeErrorValue < 0 && setValue < 0 ? 0 : config.negativeErrorValue !== null ? config.negativeErrorValue : setErrorValue);

      maxValue = mathMax(maxValue, maxErrorValue, minErrorValue);
      minValue = mathMin(minValue, maxErrorValue, minErrorValue);

      if (setErrorValue === null) {
        setErrorValue = UNDEF;
      }

      config.errorValueArr = [];
      config.positiveErrorValue === null && (config.positiveErrorValue = UNDEF);
      errorValue = -config.positiveErrorValue;
      config.errorValueArr.push({
        errorValue: errorValue,
        tooltext: cumulativeValueOnErrorBar ? positiveCumulativeErrorTooltext : positiveErrorToolText || errorToolText,
        errorEdgeBar: true
      });

      config.errorValueArr.push({
        errorValue: errorValue,
        tooltext: positiveErrorToolText || errorToolText
      });

      if (config.notHalfErrorBar) {
        errorValue = config.negativeErrorValue;
        config.errorValueArr.push({
          errorValue: errorValue,
          tooltext: cumulativeValueOnErrorBar ? negativeCumulativeErrorTooltext : negativeErrorToolText || errorToolText,
          errorEdgeBar: true
        });
        config.errorValueArr.push({
          errorValue: errorValue,
          tooltext: negativeErrorToolText || errorToolText
        });
      }

      config.toolText = getTooltext(config.setTooltext); // toolText;
    }
    conf.maxValue = maxValue;
    conf.minValue = minValue;
  };
  /*
         * Initialization of line dataset
         * @param {Object} chart - chart object of fusioncharts
         * @param {number} datasetIndex - index of line dataset
         * @param {boolean} isLineSet - Whether it is a lineset or a dataset
         * Called from draw graph of line
         */
  /*
   * Makes a dataset visible when clicked on its respective legend
   * Fired every time a deactivated legend is clicked
   */


  ErrorLineDataset.prototype._show = function _show() {
    var dataSet = this,
        chart = dataSet.chart,
        yAxis = dataSet.yAxis,
        container = dataSet.graphics && dataSet.graphics.container,
        dataLabelContainer = dataSet.graphics && dataSet.graphics.dataLabelContainer,
        errorGroupContainer = dataSet.graphics && dataSet.graphics.errorGroupContainer,
        errorShadowContainer = dataSet.graphics && dataSet.graphics.errorShadowContainer;

    chart._chartAnimation();
    container.lineGroup.show();
    container.anchorGroup.show();
    container.anchorShadowGroup.show();
    container.lineShadowGroup.show();
    dataLabelContainer.show();
    dataSet.setState('visible', true);
    errorGroupContainer && errorGroupContainer.show();
    errorShadowContainer && errorShadowContainer.show();
    dataSet._conatinerHidden = false;

    chart._setAxisLimits();
    yAxis.draw();
    // Calling the draw function for redrawing the dataset
    chart._drawDataset();
  };

  /*
   * Hides when clicked on its respective legend
   * Fired every time an activated legend is clicked
   */


  ErrorLineDataset.prototype._hide = function _hide() {
    var dataSet = this,
        chart = dataSet.chart,
        yAxis = dataSet.yAxis;

    chart._chartAnimation();
    dataSet.setState('visible', false);

    chart._setAxisLimits();
    yAxis.draw();
    chart._drawDataset();
  };

  ErrorLineDataset.prototype.draw = function draw() {
    _LINEDataset.prototype.draw.call(this);
    this.drawErrorValue();
  };

  ErrorLineDataset.prototype.drawErrorValue = function drawErrorValue() {
    var dataSet = this,
        conf = dataSet.config,
        chart = dataSet.getFromEnv('chart'),

    // parentContainer = chart.graphics.datasetGroup,
    xAxis = dataSet.getFromEnv('xAxis'),
        len = xAxis.getTicksLen(),
        attr,
        i,
        j,
        k,
        state,
        visible = dataSet.getState('visible'),
        yAxis = dataSet.getFromEnv('yAxis'),
        dataStore = dataSet.components.data,

    // animObj = animationObj.animObj,
    // dummyObj = animationObj.dummyObj,
    // animationDuration = animationObj.duration,

    errorBarThickness = conf.errorBarThickness,
        errorBarWidth = conf.errorBarWidth,
        errorBarColor = conf.errorBarColor,
        showTooltip = chart.config.showtooltip,
        shadowOpacity = conf.shadowOpacity,
        errorGroupContainer = dataSet.getContainer('errorPlotGroup'),
        errorShadowContainer = dataSet.getContainer('errorShadowGroup'),
        setLink,
        xPos,
        yPos,
        useCrispErrorPath = /* !chartLogic.avoidCrispError */1,
        dataObj,
        setValue,

    // groupId,
    config,

    // eventArgs,
    crispY,
        crispX,
        errorPath,
        errorValPos,
        errorValuePosFactor,
        errorValueArr,
        errorValueObj,
        errorValue,
        errorStartPos,
        errorLen,
        halfErrorBarW,
        errorLineElem,
        plotXpos,
        trackerTolerance = errorBarThickness > 5 ? errorBarThickness / 2 : 2.5,
        plotYpos,
        animationManager = dataSet.getFromEnv('animationManager'),
        errorTrackerConfig,
        callbackFn = function callbackFn(state) {
      return function () {
        if (state === 'disappearing') {
          this.hide();
        }
      };
    };

    // Loop through each data points
    for (i = 0; i < len; i++) {
      // setData = setDataArr && setDataArr[i];
      dataObj = dataStore[i];
      errorTrackerConfig = dataObj.errorTrackerConfig = {};
      errorTrackerConfig.errorTrackerArr = [];
      config = dataObj && dataObj.config;
      setValue = config && config.setValue;

      // If plot value is found "null", continue the loop to next iteration.
      if (dataObj === UNDEF || setValue === UNDEF || setValue === null) {
        if (dataObj.graphics.error) {
          for (j = 0; j < dataObj.graphics.error.length; j++) {
            dataObj.graphics.error && dataObj.graphics.error[j] && animationManager.setAnimation({
              el: dataObj.graphics.error[j] || 'path',
              dom: 'path',
              component: dataSet,
              callback: callbackFn('disappearing')
            }).shadow({ opacity: 0 });
          }
        }
        continue;
      }

      errorValueArr = config.errorValueArr;
      errorTrackerConfig.errorLen = errorLen = errorValueArr.length;

      !dataObj.graphics.error && (dataObj.graphics.error = []);
      !dataObj.graphics.errorTracker && (dataObj.graphics.errorTracker = []);

      if (config.errorValue === BLANKSTRING || config.errorValue === UNDEF || config.errorValue === null && config.positiveErrorValue === null && config.negativeErrorValue === null) {
        for (k = 0; k < errorLen; k++) {
          dataObj.graphics.error && dataObj.graphics.error[k] && animationManager.setAnimation({
            el: dataObj.graphics.error[k] || 'path',
            dom: 'path',
            component: dataSet,
            callback: callbackFn('disappearing')
          }).shadow({ opacity: 0 });
        }
        continue;
      }
      setLink = config.setLink;

      plotXpos = dataObj._xPos;
      plotYpos = dataObj._yPos;

      yPos = plotYpos;
      xPos = plotXpos;

      dataObj.errorBar && delete dataObj.errorBar;
      dataObj.errorBar = [];

      // Loop through errorValue array
      while (errorLen--) {
        errorLineElem = null;
        errorTrackerConfig.errorTrackerArr[errorLen] = {};
        errorValueObj = errorValueArr[errorLen];
        errorTrackerConfig.errorTrackerArr[errorLen].tooltext = errorValueObj.tooltext;
        errorStartPos = yPos;
        errorValue = errorValueObj.errorValue;
        if (errorValue === null || isNaN(errorValue)) {
          if (dataObj.graphics.error && dataObj.graphics.error[errorLen]) {
            dataObj.graphics.error[errorLen].hide();
            dataObj.graphics.error[errorLen].shadow({ opacity: 0 });
          }
          continue;
        }
        halfErrorBarW = errorBarWidth / 2;

        errorValuePosFactor = !visible ? 0 : 1;
        // Vertical Error drawing
        errorValPos = plotYpos + (yAxis.getPixel(0) - yAxis.getPixel(1)) * errorValue * errorValuePosFactor;
        crispY = errorValPos;
        crispX = xPos;
        if (useCrispErrorPath) {
          crispY = mathRound(errorValPos) + errorBarThickness % 2 / 2;
          crispX = mathRound(xPos) + errorBarThickness % 2 / 2;
        }

        dataObj.errorBar[errorLen] || (dataObj.errorBar[errorLen] = []);
        if (!errorValueObj.errorEdgeBar) {
          errorPath = [M, crispX, errorStartPos, V, crispY];
          dataObj.errorBar[errorLen][0] = {
            _xPos: crispX - trackerTolerance,
            _yPos: crispY < errorStartPos ? crispY : errorStartPos,
            _height: mathAbs(errorStartPos - crispY),
            _width: 2 * trackerTolerance,
            _toolText: errorValueObj.tooltext
          };
        } else {
          errorPath = [M, crispX - halfErrorBarW, crispY, H, crispX + halfErrorBarW];
          dataObj.errorBar[errorLen][1] = {
            _xPos: crispX - halfErrorBarW - trackerTolerance,
            _yPos: crispY - trackerTolerance,
            _height: 2 * trackerTolerance,
            _width: 2 * (halfErrorBarW + trackerTolerance),
            _toolText: errorValueObj.tooltext
          };
        }

        attr = {
          path: errorPath,
          stroke: errorBarColor,
          // In case of tooltip disabled this element should act as the hot element.
          ishot: !showTooltip,
          'stroke-width': errorBarThickness,
          'cursor': setLink ? POINTER : BLANKSTRING,
          'stroke-linecap': ROUND
        };
        state = !dataObj.graphics.error[errorLen] ? 'appearing' : visible ? 'updating' : 'disappearing';
        errorLineElem = dataObj.graphics.error[errorLen] = animationManager.setAnimation({
          el: dataObj.graphics.error[errorLen] || 'path',
          state: state,
          attr: attr,
          dom: 'path',
          component: dataSet,
          container: errorGroupContainer,
          callback: callbackFn(state)
        });
        state !== 'disappearing' && errorLineElem.show();

        errorLineElem.shadow({ opacity: shadowOpacity }, errorShadowContainer);

        errorTrackerConfig.errorTrackerArr[errorLen].attr = {
          path: errorPath,
          stroke: TRACKER_FILL,
          'stroke-width': errorBarThickness < HTP ? HTP : errorBarThickness,
          'cursor': setLink ? POINTER : BLANKSTRING,
          'ishot': !!setLink
        };
      }
      if (!config.notHalfErrorBar) {
        for (k = 2; k < 4; k++) {
          dataObj.graphics.error && dataObj.graphics.error[k] && animationManager.setAnimation({
            el: dataObj.graphics.error[k] || 'path',
            dom: 'path',
            component: dataSet,
            callback: callbackFn('disappearing')
          }).shadow({ opacity: 0 });
        }
      }
    }
  };

  ErrorLineDataset.prototype._firePlotEvent = function _firePlotEvent(eventType, plotIndex, e) {
    _errorbar2d._firePlotEvent.call(this, eventType, plotIndex, e);
  };

  ErrorLineDataset.prototype._checkPointerOverErrorBar = function _checkPointerOverErrorBar(pX, chartX, chartY) {
    return _errorbar2d._checkPointerOverErrorBar.call(this, pX, chartX, chartY);
  };
  // Helper function of _getHoverPlot()


  ErrorLineDataset.prototype._checkPointerOverPlot = function _checkPointerOverPlot(pX, chartX, chartY) {
    var dataSet = this,
        dataStore = dataSet.components.data,
        data = dataStore[pX],
        config = data && data.config,
        hoverInfo;
    if (!data) {
      return;
    }

    hoverInfo = dataSet.isWithinShape(data, pX, chartX, chartY);

    if (hoverInfo) {
      data.errorBarHovered = false;
      config.finalTooltext = config.toolText !== false && config.toolText + config.toolTipValue;
    } else {
      hoverInfo = dataSet._checkPointerOverErrorBar(pX, chartX, chartY);
      if (hoverInfo) {
        data.errorBarHovered = true;
        config.finalTooltext = hoverInfo.toolText;
      }
    }

    return hoverInfo;
  };

  ErrorLineDataset.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    return _errorbar2d._getHoveredPlot.call(this, chartX, chartY);
  };
  /*
   * This functions calculate the space required for a dataset and return that to the chart
   *
   */


  ErrorLineDataset.prototype.getCanvasPadding = function getCanvasPadding() {
    var dataset = this,
        conf = dataset.config,
        halfErrorBarW = conf.errorBarWidth * 0.5,
        components = dataset.components || {},
        chart = dataset.getFromEnv('chart'),
        dataLabelStyle = chart.config.dataLabelStyle,
        data = components.data || [],
        firstData = data[0],
        lastData = data[data.length - 1],
        dataConf,
        label,
        dataAnchorConf,
        labelDim = {},
        padding,
        labelSpace,
        showValue,
        SmartLabel = chart.getFromEnv('smartLabel'),
        retrunDimension = {
      paddingLeft: 0,
      paddingRight: 0
    };

    // @todo also calculate the space for the labels

    if (firstData) {
      dataConf = firstData.config;
      showValue = dataConf.showValue;
      dataAnchorConf = dataConf && dataConf.anchorProps || {};
      if (showValue) {
        label = dataConf.displayValue;
        SmartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
        SmartLabel.setStyle(dataLabelStyle);
        labelDim = SmartLabel.getOriSize(label);
      }
      if (dataConf.setValue) {
        padding = mathMax((0, _lib.pluckNumber)(dataAnchorConf.radius, 0), halfErrorBarW) + (0, _lib.pluckNumber)(dataAnchorConf.borderThickness, 0);
        labelSpace = (labelDim.width || 0) / 2;
      }

      retrunDimension.paddingLeft = mathMax(padding, labelSpace);
    }

    if (lastData) {
      dataConf = lastData.config;
      showValue = dataConf.showValue;
      dataAnchorConf = dataConf && dataConf.anchorProps || {};
      if (showValue) {
        label = dataConf.displayValue;
        SmartLabel.setStyle(dataLabelStyle);
        labelDim = SmartLabel.getOriSize(label);
      }
      if (dataConf.setValue) {
        padding = mathMax((0, _lib.pluckNumber)(dataAnchorConf.radius, 0), halfErrorBarW) + (0, _lib.pluckNumber)(dataAnchorConf.borderThickness, 0);
        labelSpace = (labelDim.width || 0) / 2;
      }

      retrunDimension.paddingRight = mathMax(padding, labelSpace);
    }

    return retrunDimension;
  };
  /**
  * method to remove data from the dataset during update
  */


  ErrorLineDataset.prototype.removeElements = function removeElements() {
    _errorbar2d.removeElements.call(this);
  };

  return ErrorLineDataset;
}(_line2['default']);

exports['default'] = ErrorLineDataset;

/***/ }),

/***/ 807:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lineAnimation = __webpack_require__(25);

var _lineAnimation2 = _interopRequireDefault(_lineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.dataset.errorLine': _lineAnimation2['default']['initial.dataset.line']
};

/***/ }),

/***/ 808:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(142);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _errorscatter = __webpack_require__(809);

var _errorscatter2 = _interopRequireDefault(_errorscatter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var ErrorScatter = function (_ScatterBase) {
  _inherits(ErrorScatter, _ScatterBase);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  ErrorScatter.getName = function getName() {
    return 'ErrorScatter';
  };

  function ErrorScatter() {
    _classCallCheck(this, ErrorScatter);

    var _this = _possibleConstructorReturn(this, _ScatterBase.call(this));

    _this.isXY = true;
    _this.defaultZeroPlaneHighlighted = false;
    _this.useErrorGroup = true;
    _this.isErrorChart = true;
    _this.hasAnchor = true;
    // this.fireGroupEvent = true;
    _this.initAnimation = true;
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  ErrorScatter.prototype.getName = function getName() {
    return 'ErrorScatter';
  };

  ErrorScatter.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ScatterBase.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    config.friendlyName = 'Error Scatter Chart';
    config.defaultDatasetType = 'errorscatter';
    config.enablemousetracking = true;
  };

  ErrorScatter.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  ErrorScatter.prototype.getDSdef = function getDSdef() {
    return _errorscatter2['default'];
  };

  return ErrorScatter;
}(_fusioncharts2['default']);

exports['default'] = ErrorScatter;

/***/ }),

/***/ 809:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _keys = __webpack_require__(22);

var _keys2 = _interopRequireDefault(_keys);

var _scatter = __webpack_require__(109);

var _scatter2 = _interopRequireDefault(_scatter);

var _lib = __webpack_require__(5);

var _kdtree = __webpack_require__(110);

var _kdtree2 = _interopRequireDefault(_kdtree);

var _dependencyManager = __webpack_require__(6);

var _errorscatterAnimation = __webpack_require__(810);

var _errorscatterAnimation2 = _interopRequireDefault(_errorscatterAnimation);

var _errorscatterErrorAnimation = __webpack_require__(811);

var _errorscatterErrorAnimation2 = _interopRequireDefault(_errorscatterErrorAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var colorStrings = _lib.preDefStr.colors,
    COLOR_AAAAAA = colorStrings.AAAAAA,
    ROUND = _lib.preDefStr.ROUND,
    PERCENTAGESTRING = _lib.preDefStr.PERCENTAGESTRING,
    BLANK = '',
    UNDEF,
    COMMASPACE = ', ',
    POINTER = 'pointer',
    HORIZONTAL = 'horizontal',
    VERTICAL = 'vertical',
    OPTIONAL = 'optional',

// TRACKER_FILL = 'rgba(192,192,192,' + (isIE ? 0.002 : 0.000001) + ')', // invisible but clickable
M = 'M',
    H = 'H',
    V = 'V',

// HTP = hasTouch ? TOUCH_THRESHOLD_PIXELS : CLICK_THRESHOLD_PIXELS,
convertColor = _lib.graphics.convertColor;
(0, _dependencyManager.addDep)({
  name: 'errorscatterAnimation',
  type: 'animationRule',
  extension: _errorscatterAnimation2['default']
});
(0, _dependencyManager.addDep)({
  name: 'errorscatterErrorAnimation',
  type: 'animationRule',
  extension: _errorscatterErrorAnimation2['default']
});

var ErrorScatter = function (_ScatterDataset) {
  _inherits(ErrorScatter, _ScatterDataset);

  function ErrorScatter() {
    _classCallCheck(this, ErrorScatter);

    return _possibleConstructorReturn(this, _ScatterDataset.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  ErrorScatter.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  ErrorScatter.prototype.getName = function getName() {
    return 'errorScatter';
  };

  ErrorScatter.prototype.ErrorValueConfigure = function ErrorValueConfigure() {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        JSONData = conf.JSONData,
        categories = dataSet.getFromEnv('chartConfig').categories,
        chartAttr = dataSet.getFromEnv('chart-attrib'),
        setDataArr = JSONData.data,
        setDataLen = setDataArr && setDataArr.length || 0,
        setData,
        dataObj,
        config,
        dataStore = dataSet.components.data,
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        errorBarAlpha,
        errorBarThickness,
        errorBarShadow,
        errorBarWidth,
        errorBarColor,
        halfHorizontalErrorBar,
        halfVerticalErrorBar,
        horizontalErrorBarAlpha,
        verticalErrorBarAlpha,
        horizontalErrorBarColor,
        verticalErrorBarColor,
        horizontalErrorBarThickness,
        verticalErrorBarThickness,
        hErrorValue,
        vErrorValue,
        hErrorToolTipValue,
        vErrorToolTipValue,
        tooltipSepChar = (0, _lib.pluck)(chartAttr.tooltipsepchar, COMMASPACE),
        yAxisName = (0, _lib.parseUnsafeString)(chartAttr.yaxisname),
        xAxisName = (0, _lib.parseUnsafeString)(chartAttr.xaxisname),
        parentYAxis = conf.parentYAxis,
        setValue,
        formatedVal,
        toolText,
        horizontalErrorPercent,
        verticalErrorPercent,
        macroIndices,
        parserConfig,
        seriesname,
        infMin = -Infinity,
        infMax = +Infinity,
        maxErrorValue,
        minErrorValue,
        horizontal,
        vertical,
        vPositiveErrorValue,
        hNegativeErrorValue,
        hPositiveErrorValue,
        hPositiveSetTooltext,
        hPositiveErrorToolTipValue,
        hCPErrorToolText,
        hCPErrorToolTipValue,
        hNegativeErrorToolTipValue,
        hCNErrorToolTipValue,
        vPositiveErrorToolTipValue,
        hNegativeSetTooltext,
        vCPErrorToolTipValue,
        vNegativeErrorValue,
        vCNErrorToolText,
        vCNErrorToolTipValue,
        vPositiveSetTooltext,
        hCNErrorToolText,
        vCPErrorToolText,
        cumulativeValueOnErrorBar,
        vNegativeSetTooltext,
        vNegativeErrorToolTipValue,
        yMax = infMin,
        yMin = infMax,
        xMin = infMax,
        xMax = infMin,
        getTooltext = function getTooltext(setTooltext, errorValue) {
      var toolText;

      if (!conf.showTooltip) {
        toolText = false;
      } else {
        if (formatedVal === null) {
          toolText = false;
        } else if (setTooltext !== UNDEF) {
          macroIndices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109];
          parserConfig = {
            yaxisName: yAxisName,
            xaxisName: xAxisName,
            yDataValue: formatedVal,
            xDataValue: config.label,
            formattedValue: config.toolTipValue,
            horizontalErrorValue: hErrorValue,
            horizontalErrorDataValue: hErrorToolTipValue,
            verticalErrorValue: vErrorValue,
            verticalErrorDataValue: vErrorToolTipValue,
            horizontalErrorPercent: horizontalErrorPercent,
            verticalErrorPercent: verticalErrorPercent,
            label: config.label,
            errorValue: errorValue,
            errorDataValue: errorValue,
            errorPercentValue: config.errorPercentValue,
            errorPercentDataValue: config.errorPercentValue
          };
          toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, setData, chartAttr, JSONData);
        } else {
          if (formatedVal === null) {
            toolText = false;
          } else {
            if (conf.seriesNameInTooltip) {
              seriesname = (0, _lib.getFirstValue)(JSONData && JSONData.seriesname);
            }
            toolText = seriesname ? seriesname + tooltipSepChar : BLANK;
            toolText += setValue.x ? numberFormatter.xAxis(setValue.x) + tooltipSepChar : BLANK;
            toolText += config.toolTipValue;
          }
        }
      }
      return toolText;
    },
        i;

    conf.errorBarShadow = errorBarShadow = (0, _lib.pluckNumber)(chartAttr.errorbarshadow, chartAttr.showshadow, 0);
    conf.ignoreEmptyDatasets = (0, _lib.pluckNumber)(JSONData.ignoreemptydatasets, 0);
    conf.notHalfErrorBar = !(0, _lib.pluckNumber)(chartAttr.halferrorbar, 1);

    conf.errorBarAlpha = (0, _lib.getFirstAlpha)((0, _lib.pluck)(JSONData.errorbaralpha, chartAttr.errorbaralpha));
    conf.errorBarWidth = errorBarWidth = (0, _lib.pluckNumber)(JSONData.errorbarwidth, chartAttr.errorbarwidth, 5);
    conf.errorBarColor = errorBarColor = convertColor((0, _lib.getFirstColor)((0, _lib.pluck)(JSONData.errorbarcolor, chartAttr.errorbarcolor, COLOR_AAAAAA)), errorBarAlpha);
    conf.errorBarThickness = errorBarThickness = (0, _lib.pluckNumber)(JSONData.errorbarthickness, chartAttr.errorbarthickness, 1);
    conf.shadowOpacity = errorBarShadow ? errorBarAlpha / 250 : 0;

    conf.halfHorizontalErrorBar = halfHorizontalErrorBar = (0, _lib.pluckNumber)(chartAttr.halfhorizontalerrorbar, 1);
    conf.halfVerticalErrorBar = halfVerticalErrorBar = (0, _lib.pluckNumber)(chartAttr.halfverticalerrorbar, 1);

    conf.initAnimation === UNDEF && (conf.initAnimation = chart.initAnimation);

    horizontalErrorBarAlpha = (0, _lib.pluck)(JSONData.horizontalerrorbaralpha, JSONData.errorbaralpha, chartAttr.horizontalerrorbaralpha, errorBarAlpha);

    verticalErrorBarAlpha = (0, _lib.pluckNumber)(JSONData.verticalerrorbaralpha, JSONData.errorbaralpha, chartAttr.verticalerrorbaralpha, errorBarAlpha);

    horizontalErrorBarColor = convertColor((0, _lib.pluck)(JSONData.horizontalerrorbarcolor, JSONData.errorbarcolor, chartAttr.horizontalerrorbarcolor, errorBarColor), horizontalErrorBarAlpha);

    verticalErrorBarColor = convertColor((0, _lib.pluck)(JSONData.verticalerrorbarcolor, JSONData.errorbarcolor, chartAttr.verticalerrorbarcolor, errorBarColor), verticalErrorBarAlpha);

    horizontalErrorBarThickness = (0, _lib.pluckNumber)(JSONData.horizontalerrorbarthickness, JSONData.errorbarthickness, chartAttr.horizontalerrorbarthickness, errorBarThickness);

    verticalErrorBarThickness = (0, _lib.pluckNumber)(JSONData.verticalerrorbarthickness, JSONData.errorbarthickness, chartAttr.verticalerrorbarthickness, errorBarThickness);

    conf.horizontalErrorBarWidth = (0, _lib.pluckNumber)(JSONData.horizontalerrorbarwidth, chartAttr.horizontalerrorbarwidth, errorBarWidth);

    conf.verticalErrorBarWidth = (0, _lib.pluckNumber)(JSONData.verticalerrorbarwidth, chartAttr.verticalerrorbarwidth, errorBarWidth);

    conf.cumulativeValueOnErrorBar = (0, _lib.pluckNumber)(JSONData.cumulativevalueonerrorbar, chartAttr.cumulativevalueonerrorbar, 1);

    for (i = 0; i < setDataLen; i++) {
      if (!setDataArr) {
        continue;
      }

      setData = setDataArr && setDataArr[i];
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (!dataObj) {
        dataObj = dataStore[i] = {
          graphics: {}
        };
      }

      if (!dataObj.config) {
        config = dataStore[i].config = {};
      }

      // setErrorValue = numberFormatter.getCleanValue(setData.errorvalue);

      setValue = config.setValue;
      config.errorValue = setData.errorvalue;

      config.cumulativeValueOnErrorBar = cumulativeValueOnErrorBar = (0, _lib.pluckNumber)(setData.cumulativevalueonerrorbar, conf.cumulativeValueOnErrorBar, 1);

      config.hErrorValue = hErrorValue = numberFormatter.getCleanValue((0, _lib.pluck)(setData.horizontalerrorvalue, setData.errorvalue));

      config.vErrorValue = vErrorValue = numberFormatter.getCleanValue((0, _lib.pluck)(setData.verticalerrorvalue, setData.errorvalue));

      config.hPositiveErrorValue = hPositiveErrorValue = numberFormatter.getCleanValue((0, _lib.pluck)(setData.horizontalpositiveerrorvalue, setData.positiveerrorvalue, hErrorValue));
      config.hNegativeErrorValue = hNegativeErrorValue = numberFormatter.getCleanValue((0, _lib.pluck)(setData.horizontalnegativeerrorvalue, setData.negativeerrorvalue, hErrorValue));

      config.vPositiveErrorValue = vPositiveErrorValue = numberFormatter.getCleanValue((0, _lib.pluck)(setData.verticalpositiveerrorvalue, setData.positiveerrorvalue, vErrorValue));
      config.vNegativeErrorValue = vNegativeErrorValue = numberFormatter.getCleanValue((0, _lib.pluck)(setData.verticalnegativeerrorvalue, setData.negativeerrorvalue, vErrorValue));

      hPositiveErrorToolTipValue = numberFormatter.dataLabels(hPositiveErrorValue, parentYAxis);

      hPositiveSetTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, hPositiveErrorToolTipValue)));

      hNegativeErrorToolTipValue = numberFormatter.dataLabels(hNegativeErrorValue, parentYAxis);

      hNegativeSetTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, hNegativeErrorToolTipValue)));

      vPositiveErrorToolTipValue = numberFormatter.dataLabels(vPositiveErrorValue, parentYAxis);

      vPositiveSetTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, vPositiveErrorToolTipValue)));

      vNegativeErrorToolTipValue = numberFormatter.dataLabels(vNegativeErrorValue, parentYAxis);

      vNegativeSetTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, vNegativeErrorToolTipValue)));
      hCPErrorToolText = hCNErrorToolText = vCPErrorToolText = vCNErrorToolText = UNDEF;
      if (cumulativeValueOnErrorBar) {
        hCPErrorToolTipValue = numberFormatter.dataLabels(setValue.x + hPositiveErrorValue, parentYAxis);
        hCPErrorToolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, hCPErrorToolTipValue)));

        hCNErrorToolTipValue = numberFormatter.dataLabels(setValue.x - hNegativeErrorValue, parentYAxis);
        hCNErrorToolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, hCNErrorToolTipValue)));

        vCPErrorToolTipValue = numberFormatter.dataLabels(setValue.y + vPositiveErrorValue, parentYAxis);
        vCPErrorToolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, vCPErrorToolTipValue)));

        vCNErrorToolTipValue = numberFormatter.dataLabels(setValue.y - vNegativeErrorValue, parentYAxis);
        vCNErrorToolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.errorplottooltext, JSONData.errorplottooltext, chartAttr.errorplottooltext, vCNErrorToolTipValue)));
      }

      categories && categories[i] && (config.label = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(categories[i].tooltext, categories[i].label))));

      if (setData.horizontalpositiveerrorvalue || setData.positiveerrorvalue || setData.horizontalnegativeerrorvalue || setData.negativeerrorvalue) {
        config.halfHorizontalErrorBar = halfHorizontalErrorBar = 0;
      } else {
        config.halfHorizontalErrorBar = halfHorizontalErrorBar = conf.halfHorizontalErrorBar;
      }

      if (setData.verticalpositiveerrorvalue || setData.positiveerrorvalue || setData.verticalnegativeerrorvalue || setData.negativeerrorvalue) {
        config.halfVerticalErrorBar = halfVerticalErrorBar = 0;
      } else {
        config.halfVerticalErrorBar = halfVerticalErrorBar = conf.halfVerticalErrorBar;
      }

      if (setValue.x !== null) {
        maxErrorValue = setValue.x + Number(hPositiveErrorValue);
        minErrorValue = setValue.x - (halfHorizontalErrorBar ? 0 : Number(hNegativeErrorValue));

        xMax = Math.max(xMax, maxErrorValue, minErrorValue);
        xMin = Math.min(xMin, maxErrorValue, minErrorValue);
      }

      if (setValue.y !== null) {
        maxErrorValue = setValue.y + Number(vPositiveErrorValue);
        minErrorValue = setValue.y - (halfVerticalErrorBar ? 0 : Number(vNegativeErrorValue));

        yMax = Math.max(yMax, maxErrorValue, minErrorValue);
        yMin = Math.min(yMin, maxErrorValue, minErrorValue);
      }

      config.useHorizontalErrorBar = (0, _lib.pluckNumber)(setData.usehorizontalerrorbar, JSONData.usehorizontalerrorbar, chartAttr.usehorizontalerrorbar, 0);

      config.useVerticalErrorBar = (0, _lib.pluckNumber)(setData.useverticalerrorbar, JSONData.useverticalerrorbar, chartAttr.useverticalerrorbar, 1);

      config.errorValueConf = {};
      // horizontal error bar related segments
      horizontal = config.errorValueConf.horizontal = {};
      // this segments are mandatory as this part will show regardless show half error value is true or false
      horizontal.mandatory = {};
      // marker is one of the segment of error bar which denotes the error value
      horizontal.mandatory.marker = {
        errorValue: -(hPositiveErrorValue === null ? UNDEF : hPositiveErrorValue),
        tooltext: getTooltext(hPositiveSetTooltext, hPositiveErrorToolTipValue),
        errorBarColor: horizontalErrorBarColor,
        isHorizontal: true,
        errorBarThickness: horizontalErrorBarThickness,
        shadowOpacity: errorBarShadow ? horizontalErrorBarAlpha / 250 : 0
      };
      // limit denotes the error value or cummulative value of the error bar thats why we are calling it limit
      // as it conveys that the end of error bar
      horizontal.mandatory.limit = {
        errorValue: -(hPositiveErrorValue === null ? UNDEF : hPositiveErrorValue),
        tooltext: cumulativeValueOnErrorBar ? getTooltext(hCPErrorToolText, hCPErrorToolTipValue) : getTooltext(hPositiveSetTooltext, hPositiveErrorToolTipValue),
        errorBarColor: horizontalErrorBarColor,
        isHorizontal: true,
        errorBarThickness: horizontalErrorBarThickness,
        shadowOpacity: errorBarShadow ? horizontalErrorBarAlpha / 250 : 0,
        errorEdgeBar: true
      };
      // this segments are option as this part will show only show half error value is true
      horizontal.optional = {};
      // marker is one of the segment of error bar which denotes the error value
      horizontal.optional.marker = {
        errorValue: hNegativeErrorValue,
        tooltext: getTooltext(hNegativeSetTooltext, hNegativeErrorToolTipValue),
        errorBarColor: horizontalErrorBarColor,
        isHorizontal: true,
        errorBarThickness: horizontalErrorBarThickness,
        shadowOpacity: errorBarShadow ? horizontalErrorBarAlpha / 250 : 0
      };
      // limit denotes the error value or cummulative value of the error bar thats why we are calling it limit
      // as it conveys that the end of error bar
      horizontal.optional.limit = {
        errorValue: hNegativeErrorValue,
        tooltext: cumulativeValueOnErrorBar ? getTooltext(hCNErrorToolText, hCNErrorToolTipValue) : getTooltext(hNegativeSetTooltext, hNegativeErrorToolTipValue),
        errorBarColor: horizontalErrorBarColor,
        isHorizontal: true,
        errorBarThickness: horizontalErrorBarThickness,
        shadowOpacity: errorBarShadow ? horizontalErrorBarAlpha / 250 : 0,
        errorEdgeBar: true
      };
      // vertical error bar related segments
      vertical = config.errorValueConf.vertical = {};
      // this segments are mandatory as this part will show regardless show half error value is true or false
      vertical.mandatory = {};
      // marker is one of the segment of error bar which denotes the error value
      vertical.mandatory.marker = {
        errorValue: -(vPositiveErrorValue === null ? UNDEF : vPositiveErrorValue),
        tooltext: getTooltext(vPositiveSetTooltext, vPositiveErrorToolTipValue),
        errorBarColor: verticalErrorBarColor,
        errorBarThickness: verticalErrorBarThickness,
        shadowOpacity: errorBarShadow ? verticalErrorBarAlpha / 250 : 0
      };
      // limit denotes the error value or cummulative value of the error bar thats why we are calling it limit
      // as it conveys that the end of error bar
      vertical.mandatory.limit = {
        errorValue: -(vPositiveErrorValue === null ? UNDEF : vPositiveErrorValue),
        tooltext: cumulativeValueOnErrorBar ? getTooltext(vCPErrorToolText, vCPErrorToolTipValue) : getTooltext(vPositiveSetTooltext, vPositiveErrorToolTipValue),
        errorBarColor: verticalErrorBarColor,
        errorBarThickness: verticalErrorBarThickness,
        shadowOpacity: errorBarShadow ? verticalErrorBarAlpha / 250 : 0,
        errorEdgeBar: true
      };
      // this segments are option as this part will show only show half error value is true
      vertical.optional = {};
      // marker is one of the segment of error bar which denotes the error value
      vertical.optional.marker = {
        errorValue: vNegativeErrorValue,
        tooltext: getTooltext(vNegativeSetTooltext, vNegativeErrorToolTipValue),
        errorBarColor: verticalErrorBarColor,
        errorBarThickness: verticalErrorBarThickness,
        shadowOpacity: errorBarShadow ? verticalErrorBarAlpha / 250 : 0
      };
      // limit denotes the error value or cummulative value of the error bar thats why we are calling it limit
      // as it conveys that the end of error bar
      vertical.optional.limit = {
        errorValue: vNegativeErrorValue,
        tooltext: cumulativeValueOnErrorBar ? getTooltext(vCNErrorToolText, vCNErrorToolTipValue) : getTooltext(vNegativeSetTooltext, vNegativeErrorToolTipValue),
        errorBarColor: verticalErrorBarColor,
        errorBarThickness: verticalErrorBarThickness,
        shadowOpacity: errorBarShadow ? verticalErrorBarAlpha / 250 : 0,
        errorEdgeBar: true
      };

      setValue = config.setValue;

      // errorPercentValue = (Math.round(((setErrorValue / setValue) * HUNDREDSTRING) * HUNDREDSTRING) /
      //               HUNDREDSTRING) + PERCENTAGESTRING;

      horizontalErrorPercent = Math.round(hErrorValue / setValue * _lib.HUNDREDSTRING * _lib.HUNDREDSTRING) / _lib.HUNDREDSTRING + PERCENTAGESTRING;

      verticalErrorPercent = Math.round(vErrorValue / setValue * _lib.HUNDREDSTRING * _lib.HUNDREDSTRING) / _lib.HUNDREDSTRING + PERCENTAGESTRING;

      formatedVal = config.formatedVal;

      // Initial tooltext parsing
      if (!conf.showTooltip) {
        toolText = false;
      } else if (config.setTooltext !== UNDEF) {
        macroIndices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109];
        parserConfig = {
          yaxisName: yAxisName,
          xaxisName: xAxisName,
          yDataValue: formatedVal,
          xDataValue: config.label,
          formattedValue: config.toolTipValue,
          horizontalErrorValue: hErrorValue,
          horizontalErrorDataValue: hErrorToolTipValue,
          verticalErrorValue: vErrorValue,
          verticalErrorDataValue: vErrorToolTipValue,
          horizontalErrorPercent: horizontalErrorPercent,
          verticalErrorPercent: verticalErrorPercent,
          label: config.label
        };
        toolText = (0, _lib.parseTooltext)(config.setTooltext, macroIndices, parserConfig, setData, chartAttr, JSONData);
      } else {
        // determine the default tooltext then.
        if (formatedVal === null) {
          toolText = false;
        } else {
          if (conf.seriesNameInTooltip) {
            seriesname = (0, _lib.getFirstValue)(JSONData && JSONData.seriesname);
          }
          toolText = seriesname ? seriesname + tooltipSepChar : BLANK;
          toolText += setValue.x ? numberFormatter.xAxis(setValue.x) + tooltipSepChar : BLANK;
          toolText += config.toolTipValue;
        }
      }
      config.toolText = toolText;
    }

    conf.xMax = xMax;
    conf.xMin = xMin;
    conf.yMin = yMin;
    conf.yMax = yMax;
  };

  ErrorScatter.prototype.drawErrorValue = function drawErrorValue() {
    var dataSet = this,
        JSONData = dataSet.config.JSONData,
        conf = dataSet.config,
        setDataArr = JSONData.data,
        dataSetLen = setDataArr && setDataArr.length,
        attr,
        i,
        errorGraphicsString,
        visible = dataSet.getState('visible'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis'),
        dataStore = dataSet.components.data,
        graphics,

    // yAxisPVR = yAxis.getPVR(),
    // xAxisPVR = xAxis.getPVR(),
    isHorizontal,
        errorBarThickness,
        errorBarWidth,
        errorBarColor,
        shadowOpacity = conf.shadowOpacity,
        errorGroupContainer = dataSet.getContainer('errorPlotGroup'),
        errorShadowContainer = dataSet.getContainer('errorShadowGroup'),
        setLink,
        xPos,
        yPos,
        useCrispErrorPath = 1,
        dataObj,
        setValue,
        animState,
        config,
        notRequiredHEB,
        notRequiredVEB,
        isHalfHorizontalErrorBar,
        isHalfVertictalErrorBar,
        crispY,
        crispX,
        errorPath,
        errorValPos,
        errorValuePosFactor,
        subType,
        errorBar,
        subErrorBar,
        segment,
        segmentType,
        currErrorTracker,
        errorValue,
        errorStartPos,
        halfErrorBarW,
        errorLineElem,
        plotXpos,
        plotYpos,
        errorBarSegmentLen,
        errorBarSegmentStartPos,
        l,
        j = 0,
        k,
        errorValueConf,
        errorBarType,
        trackerTolerance,
        keys,
        animationManager = dataSet.getFromEnv('animationManager'),
        searchDataArr = [],
        errorTrackerConfig,
        callbackFn = function callbackFn(state) {
      return function () {
        if (state === 'disappearing') {
          this.hide();
        }
      };
    };

    // Loop through each data points
    for (i = 0; i < dataSetLen; i++) {
      dataObj = dataStore[i];
      errorTrackerConfig = dataObj.errorTrackerConfig = {};
      errorTrackerConfig.errorTrackerArr = [];
      config = dataObj && dataObj.config;
      setValue = config && config.setValue;

      errorValueConf = config.errorValueConf;

      // If plot value is found "null", continue the loop to next iteration.
      if (dataObj === UNDEF || setValue === UNDEF || setValue === null || !errorValueConf) {
        continue;
      }
      keys = (0, _keys2['default'])(graphics = dataObj.graphics);
      if (config.vErrorValue === null && config.vPositiveErrorValue === null && config.vNegativeErrorValue === null) {
        for (k = 0; k < keys.length; k++) {
          if (keys[k].match(/error-horizontal-/)) {
            animationManager.setAnimation({
              el: graphics[keys[k]],
              state: 'disappearing',
              callback: callbackFn('disappearing')
            });
            graphics[keys[k]].shadow({ opacity: 0 });
          }
        }
      }

      if (config.hErrorValue === null && config.hPositiveErrorValue === null && config.vPositiveErrorValue === null) {
        for (k = 0; k < keys.length; k++) {
          if (keys[k].match(/error-vertical-/)) {
            animationManager.setAnimation({
              el: graphics[keys[k]],
              state: 'disappearing',
              callback: callbackFn('disappearing')
            });
            graphics[keys[k]].shadow({ opacity: 0 });
          }
        }
      }

      if (config.hErrorValue === null && config.vErrorValue === null && config.hPositiveErrorValue && config.hNegativeErrorValue && config.vPositiveErrorValue && config.vNegativeErrorValue) {
        continue;
      }

      setLink = config.setLink;

      plotXpos = dataObj._xPos;
      plotYpos = dataObj._yPos;

      yPos = plotYpos;
      xPos = plotXpos;
      // errorBarType := horizontal / vertical
      for (errorBarType in errorValueConf) {
        if (!errorValueConf.hasOwnProperty(errorBarType)) {
          continue;
        }
        errorBar = errorValueConf[errorBarType];
        // subType := mandatory / optional
        for (subType in errorBar) {
          if (!errorBar.hasOwnProperty(subType)) {
            continue;
          }
          subErrorBar = errorBar[subType];
          // segmentType := marker / limit
          for (segmentType in subErrorBar) {
            if (!subErrorBar.hasOwnProperty(segmentType)) {
              continue;
            }
            animState = UNDEF;
            segment = subErrorBar[segmentType];
            attr = {};
            currErrorTracker = errorTrackerConfig.errorTrackerArr[j] = {};
            errorLineElem = null;

            currErrorTracker.tooltext = segment.tooltext;
            errorStartPos = yPos;
            errorValue = segment.errorValue;

            notRequiredHEB = !config.useHorizontalErrorBar && errorBarType === HORIZONTAL;
            notRequiredVEB = !config.useVerticalErrorBar && errorBarType === VERTICAL;
            isHalfHorizontalErrorBar = config.halfHorizontalErrorBar && errorBarType === HORIZONTAL && subType === OPTIONAL;
            isHalfVertictalErrorBar = config.halfVerticalErrorBar && errorBarType === VERTICAL && subType === OPTIONAL;
            if (notRequiredHEB || notRequiredVEB || isHalfHorizontalErrorBar || isHalfVertictalErrorBar) {
              animState = 'disappearing';
            } else if (errorValue === null || errorValue === UNDEF || isNaN(errorValue)) {
              animState = 'disappearing';
            } else {
              errorBarColor = segment.errorBarColor;
              isHorizontal = segment.isHorizontal;
              errorBarThickness = segment.errorBarThickness;

              errorBarWidth = isHorizontal ? conf.horizontalErrorBarWidth : conf.verticalErrorBarWidth;

              halfErrorBarW = !visible ? 0 : errorBarWidth / 2;

              errorValuePosFactor = !visible ? 0 : -1;

              trackerTolerance = errorBarThickness > 5 ? errorBarThickness / 2 + 0.5 : 5.5 / 2;

              if (isHorizontal) {
                errorValPos = xAxis.getPixel(dataObj.config._x + errorValue * errorValuePosFactor);
                crispY = errorValPos;
                crispX = xPos;

                if (useCrispErrorPath) {
                  crispY = Math.round(errorStartPos) + errorBarThickness % 2 / 2;
                  crispX = Math.round(errorValPos) + errorBarThickness % 2 / 2;
                }

                if (segment.errorEdgeBar) {
                  errorPath = [M, crispX, crispY - halfErrorBarW, V, crispY + halfErrorBarW];

                  errorBarSegmentLen = 2 * halfErrorBarW;
                  errorBarSegmentStartPos = crispY - halfErrorBarW;
                  for (l = trackerTolerance; l < errorBarSegmentLen; l += 2 * trackerTolerance) {
                    searchDataArr.push({
                      x: crispX,
                      y: errorBarSegmentStartPos + l,
                      r: trackerTolerance,
                      index: i,
                      data: dataObj,
                      toolText: segment.tooltext,
                      barType: 'h'
                    });
                  }
                } else {
                  errorPath = [M, xPos, crispY, H, crispX];

                  errorBarSegmentLen = Math.abs(xPos - crispX);
                  errorBarSegmentStartPos = xPos > crispX ? crispX : xPos;
                  for (l = trackerTolerance; l < errorBarSegmentLen; l += 2 * trackerTolerance) {
                    searchDataArr.push({
                      x: errorBarSegmentStartPos + l,
                      y: crispY,
                      r: trackerTolerance,
                      index: i,
                      data: dataObj,
                      toolText: segment.tooltext,
                      barType: 'h'
                    });
                  }
                }
              } else {
                // Vertical Error drawing
                errorValPos = yAxis.getPixel(dataObj.config._y + errorValue * errorValuePosFactor);
                crispY = errorValPos;
                crispX = xPos;
                if (useCrispErrorPath) {
                  crispY = Math.round(errorValPos) + errorBarThickness % 2 / 2;
                  crispX = Math.round(xPos) + errorBarThickness % 2 / 2;
                }

                if (segment.errorEdgeBar) {
                  errorPath = [M, crispX - halfErrorBarW, crispY, H, crispX + halfErrorBarW];

                  errorBarSegmentLen = 2 * halfErrorBarW;
                  errorBarSegmentStartPos = crispX - halfErrorBarW;
                  for (l = trackerTolerance; l <= errorBarSegmentLen; l += 2 * trackerTolerance) {
                    searchDataArr.push({
                      x: errorBarSegmentStartPos + l,
                      y: crispY,
                      r: trackerTolerance,
                      index: i,
                      data: dataObj,
                      toolText: segment.tooltext,
                      barType: 'v'
                    });
                  }
                } else {
                  errorPath = [M, crispX, errorStartPos, V, crispY];

                  errorBarSegmentLen = Math.abs(errorStartPos - crispY);
                  errorBarSegmentStartPos = errorStartPos > crispY ? crispY : errorStartPos;
                  for (l = trackerTolerance; l <= errorBarSegmentLen; l += 2 * trackerTolerance) {
                    searchDataArr.push({
                      x: crispX,
                      y: errorBarSegmentStartPos + l,
                      r: trackerTolerance,
                      index: i,
                      data: dataObj,
                      toolText: segment.tooltext,
                      barType: 'v'
                    });
                  }
                }
              }
              attr = {
                path: errorPath,
                'stroke-width': visible ? errorBarThickness : 0,
                stroke: errorBarColor,
                'cursor': setLink ? POINTER : BLANK,
                'stroke-linecap': ROUND
              };
            }
            errorGraphicsString = ['error', errorBarType, subType, segmentType].join('-');
            if (!animState) {
              if (graphics[errorGraphicsString]) {
                animState = 'updating';
              } else {
                animState = 'appearing';
              }
            }
            if (!graphics[errorGraphicsString] && animState === 'disappearing') {
              continue;
            }
            errorLineElem = graphics[errorGraphicsString] = animationManager.setAnimation({
              el: graphics[errorGraphicsString] || 'path',
              container: errorGroupContainer,
              component: dataSet,
              attr: attr,
              state: animState,
              dom: 'path',
              callback: callbackFn(animState)
            });
            animState !== 'disappearing' && errorLineElem.show();
            // @todo has to validate how it works
            // why we need to set opacity while it is follower to main element
            errorLineElem.shadow({ opacity: animState === 'disappearing' ? 0 : shadowOpacity }, errorShadowContainer);
          }
        }
      }
    }
    searchDataArr.length && (this.config.dataTreeB = new _kdtree2['default']().buildKdTree(searchDataArr));
    conf.initAnimation = false;
  };

  /*
         * Using kdtree algo for searching
        */


  ErrorScatter.prototype._getHoveredPlot = function _getHoveredPlot(x, y) {
    var res, res1, tooltext, errorBarToolText, hoverEffects, element;

    res = this.config.dataTree.getNeighbour({
      x: x,
      y: y
    }, true);

    // searching neighbour from Kdtree with basic search flag on
    if (res) {
      tooltext = res.data.config.toolText;
      res.data.config.finalTooltext = tooltext;
      hoverEffects = res.data.config.hoverEffects;
      element = res.data.graphics.element;
      element.data('hoverEnabled', hoverEffects.enabled);
      hoverEffects.enabled && element.attr(element.getData().setRolloverAttr);
      return {
        pointIndex: res.index,
        hovered: true,
        pointObj: res.data
      };
    } else {
      res1 = this.config.dataTreeB && this.config.dataTreeB.getNeighbour({
        x: x,
        y: y
      }, true);
      if (res1) {
        if (res1.barType === 'h') {
          errorBarToolText = res1.toolText;
        } else if (res1.barType === 'v') {
          errorBarToolText = res1.toolText;
        }
        res1.data.config.finalTooltext = errorBarToolText;
        element = res1.data.graphics.element;
        element.data('hoverEnabled', false);
        element.attr(element.getData().setRolloutAttr);
        return {
          pointIndex: res1.index,
          hovered: true,
          pointObj: res1.data
        };
      }
    }
  };
  // Function to remove a data from a dataset during real time update.


  ErrorScatter.prototype.removeElements = function removeElements() {
    var dataSet = this,
        components = dataSet.components,
        removeDataArr = components.removeDataArr,
        pool = components.pool || (components.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        animationManager = dataSet.getFromEnv('animationManager'),
        len = removeDataArr.length,
        removeData,
        graphics,
        i,
        key,
        callback = function callback() {
      this.hide();
      this.shadow({ opacity: 0 });
    };

    for (i = 0; i < len; i++) {
      removeData = removeDataArr[0];
      removeDataArr.splice(0, 1);
      // In case of non existing data plot continue;
      if (!removeData || !removeData.graphics) {
        continue;
      }

      graphics = removeData.graphics;

      for (key in graphics) {
        if (graphics.hasOwnProperty(key)) {
          animationManager.setAnimation({
            el: graphics[key],
            component: dataSet,
            attr: {},
            state: 'disappering',
            callback: callback
          });
        }
      }

      // Storing the graphic elements for reuse.
      removeData.graphics.element && (pool.element = pool.element.concat(removeData.graphics.element));
      removeData.graphics.label && (pool.label = pool.label.concat(removeData.graphics.label));
    }
    components.pool = pool;
  };

  return ErrorScatter;
}(_scatter2['default']);

exports['default'] = ErrorScatter;

/***/ }),

/***/ 810:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lineAnimation = __webpack_require__(25);

var _lineAnimation2 = _interopRequireDefault(_lineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.dataset.errorScatter': _lineAnimation2['default']['initial.dataset.line']
};

/***/ }),

/***/ 811:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _errorlineErrorAnimation = __webpack_require__(368);

var _errorlineErrorAnimation2 = _interopRequireDefault(_errorlineErrorAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.dataset.errorScatter': _errorlineErrorAnimation2['default']['initial.dataset.errorLine']
};

/***/ }),

/***/ 812:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(16);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _fusioncharts3 = __webpack_require__(17);

var _msstepline = __webpack_require__(813);

var _msstepline2 = _interopRequireDefault(_msstepline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var MSStepLine = function (_MSCartesian) {
  _inherits(MSStepLine, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSStepLine.getName = function getName() {
    return 'MSStepLine';
  };

  function MSStepLine() {
    _classCallCheck(this, MSStepLine);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.defaultPlotShadow = 1;
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  MSStepLine.prototype.getName = function getName() {
    return 'MSStepLine';
  };

  MSStepLine.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Multi-series Step Line Chart';
    config.defaultDatasetType = 'msstepline';
    config.drawverticaljoins = 1;
    config.useforwardsteps = 1;
    config.zeroplanethickness = 1;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
    _fusioncharts3._setDefaultConfig.call(this);
  };

  MSStepLine.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  MSStepLine.prototype.getDSdef = function getDSdef() {
    return _msstepline2['default'];
  };

  return MSStepLine;
}(_fusioncharts2['default']);

exports['default'] = MSStepLine;

/***/ }),

/***/ 813:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _dependencyManager = __webpack_require__(6);

var _msStepLineAnimation = __webpack_require__(814);

var _msStepLineAnimation2 = _interopRequireDefault(_msStepLineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var LINE = 'line',
    H = 'H',
    V = 'V',
    M = 'M',
    UNDEF = void 0;
(0, _dependencyManager.addDep)({
  name: 'stepLineAnimation',
  type: 'animationRule',
  extension: _msStepLineAnimation2['default']
});

var MSStepLineDataset = function (_LineDataset) {
  _inherits(MSStepLineDataset, _LineDataset);

  function MSStepLineDataset() {
    _classCallCheck(this, MSStepLineDataset);

    return _possibleConstructorReturn(this, _LineDataset.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  MSStepLineDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  MSStepLineDataset.prototype.getName = function getName() {
    return 'stepLine';
  };

  MSStepLineDataset.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _LineDataset.prototype.__setDefaultConfig && _LineDataset.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.drawverticaljoins = UNDEF;
    config.useforwardsteps = UNDEF;
  };

  MSStepLineDataset.prototype._addLegend = function _addLegend() {
    var dataset = this,
        conf = dataset.config,
        legend = dataset.getFromEnv('legend'),
        drawAnchors = (0, _lib.pluckNumber)(conf.drawanchors, 1),
        legendItem,
        config = {
      enabled: conf.includeinlegend,
      type: LINE,
      /* In case of scatter (a child chartAPI of line),
      line is drawn in legend only when drawLine is set
      to true. */
      drawLine: (0, _lib.pluck)(conf.drawLine, true),
      anchorSide: drawAnchors ? conf.anchorsides : 0,
      label: (0, _lib.getFirstValue)(dataset.config.JSONData.seriesname)
    };
    if (conf.includeinlegend) {
      legendItem = legend.getItem(dataset.config.legendItemId);
      if (!legendItem) {
        dataset.config.legendItemId = legend.createItem(dataset);
        legendItem = legend.getItem(dataset.config.legendItemId);
        dataset.addExtEventListener('click', function () {
          dataset.legendInteractivity(legendItem);
        }, legendItem);
      }
      legendItem.configure(config);
      legendItem.setStateCosmetics('default', {
        symbol: {
          fill: (0, _lib.toRaphaelColor)({
            color: conf.anchorbgcolor,
            alpha: conf.anchorbgalpha
          }),
          stroke: (0, _lib.toRaphaelColor)({
            color: conf.anchorbordercolor,
            alpha: '100'
          }),
          'stroke-width': conf.anchorborderthickness
        }
      });
      // check if dataset is initiallyhidden
      if (!dataset.getState('visible')) {
        legendItem.setLegendState('hidden');
      }
    } else if (dataset.config.legendItemId) {
      legend.disposeItem(dataset.config.legendItemId);
    }
  };

  MSStepLineDataset.prototype.getLinePath = function getLinePath(data, lastObj, positions) {
    var dataset = this,
        conf = dataset.config,
        chartConfig = dataset.getFromEnv('chartConfig'),
        connectNullData = (0, _lib.pluckNumber)(chartConfig.connectnulldata),
        obj = lastObj || {},
        xAxis = dataset.getFromEnv('xAxis'),
        drawVerticalJoins = (0, _lib.pluckNumber)(conf.drawverticaljoins),
        useForwardSteps = (0, _lib.pluckNumber)(conf.useforwardsteps),
        halfStep = (0, _lib.pluckNumber)(chartConfig.stepatmiddle) ? xAxis.getPVR() * 0.5 : 0,

    // Used for determining whether the last value was valid
    // Initially it is false
    lastValidValue = obj.lastValidValue || false,
        temp = obj.temp || [],
        temp2 = obj.temp2 || [],
        pathArr = obj.pathArr || [],
        path2Arr = obj.path2Arr || [],
        lastXPos,
        i,
        config,
        xPos,
        yPos,
        length = data.length,
        pointsJoined = obj.pointsJoined || 0,
        dataObj,
        setValue,
        startPos = positions && positions.begin || 0,
        endPos = positions && positions.end || length,
        step = chartConfig.viewPortConfig.step || 1,
        dataWithRemovedPaths = [];
    // Added current dataStore to arr
    dataWithRemovedPaths = dataWithRemovedPaths.concat(data);

    for (i = startPos; i < endPos; i += step) {
      dataObj = dataWithRemovedPaths[i];
      if (!dataObj) {
        continue;
      }

      config = dataObj.config;
      setValue = config.setValue;

      // skip the data plot if isSkipped flag is set to false
      if (setValue === UNDEF || config && config.isSkipped === true) {
        config && delete config.isSkipped;
        continue;
      }
      xPos = config._Px;
      yPos = config._Py;

      // create the path array
      // If the last value is valid
      if (setValue === null || setValue.isNull) {
        // If null data points are also to be connected
        if (!connectNullData) {
          temp = [];
          temp2 = [];
          lastValidValue = false;
        }
      } else {
        if (lastValidValue) {
          if (temp.length) {
            pathArr = pathArr.concat(temp);
            temp = [];
            pointsJoined++;
          }
          if (useForwardSteps) {
            pathArr.push([H, xPos - halfStep]);
            if (drawVerticalJoins) {
              pathArr.push([V, yPos]);
            } else {
              pathArr.push([M, xPos - halfStep, yPos]);
            }
            if (halfStep) {
              pathArr.push([H, xPos]);
            }
          } else {
            if (drawVerticalJoins) {
              pathArr.push([V, yPos]);
            } else {
              pathArr.push([M, lastXPos, yPos]);
            }
            pathArr.push([H, xPos]);
            lastXPos = xPos;
          }
          // Push the upper x and y position to pathArr
          // pathArr.push([L, xPos, yPos]);
        } else {
          // Push the upper x and y positions of area plot to temp
          temp.push([M, xPos, yPos]);
          lastXPos = xPos;
          // No points are joined when starting a new path
          pointsJoined = 0;
          lastValidValue = true;
        }
      }
    }
    return {
      pathArr: pathArr,
      path2Arr: path2Arr,
      lastValidValue: lastValidValue,
      pointsJoined: pointsJoined,
      temp: temp,
      temp2: temp2,
      getPathArr: dataset.getPathArr
    };
  };

  return MSStepLineDataset;
}(_line2['default']);

exports['default'] = MSStepLineDataset;

/***/ }),

/***/ 814:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lineAnimation = __webpack_require__(25);

var _lineAnimation2 = _interopRequireDefault(_lineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.dataset.stepLine': _lineAnimation2['default']['initial.dataset.line']
};

/***/ }),

/***/ 815:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _stringify = __webpack_require__(36);

var _stringify2 = _interopRequireDefault(_stringify);

var _lib = __webpack_require__(5);

var _fusioncharts = __webpack_require__(142);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _selectscatter = __webpack_require__(816);

var _selectscatter2 = _interopRequireDefault(_selectscatter);

var _fusioncharts3 = __webpack_require__(364);

var _dependencyManager = __webpack_require__(6);

var _ajax = __webpack_require__(80);

var _ajax2 = _interopRequireDefault(_ajax);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var Raphael = (0, _dependencyManager.getDep)('redraphael', 'plugin'),
    transcoders = (0, _dependencyManager.getDepsByType)('transcoder'),
    UNDEF = void 0,
    COMMA = ',',
    configStr = 'config',
    TRACKER_FILL = 'rgba(192,192,192,' + (_lib.isIE ? 0.002 : 0.000001) + ')',
    VISIBLE = 'visible',
    HIDDEN = 'hidden',
    ROUND = 'round',
    POINTER = 'pointer',
    deg2rad = Math.PI / 180,
    getArcPath = function getArcPath(endX, endY, rX, rY, isClockWise, isLargeArc) {
  return ['A', rX, rY, 0, isLargeArc, isClockWise, endX, endY];
},
    M = 'M',
    L = 'L',
    Z = 'Z',
    t = 't';

function _createSelectionBox(event) {
  var chart = event.chart,
      paper = chart.getFromEnv('paper'),
      chartConfig = chart.config,
      yAxis = chart.getChildren('yAxis')[0],
      xAxis = chart.getChildren('xAxis')[0],
      x = event.selectionLeft,
      y = event.selectionTop,
      width = event.selectionWidth,
      height = event.selectionHeight,
      x2 = x + width,
      y2 = y + height,
      TRACKER_WIDTH = 12,
      TRACKER_HALF_WIDTH = TRACKER_WIDTH * 0.5,
      trackerRadius = 12,
      resizeInnerSymbolColor = '#999999',
      resizeOuterSymbolColor = '#777777',
      closeButtonRadius = 6,
      cornerSymbolRadius = 15,
      isSmall = width > cornerSymbolRadius && height > cornerSymbolRadius,
      selectEleObj = {
    resizeEleRadius: cornerSymbolRadius,
    canvasTop: chartConfig.canvasTop,
    canvasRight: chartConfig.canvasLeft + chartConfig.canvasWidth,
    canvasLeft: chartConfig.canvasLeft,
    canvasBottom: chartConfig.canvasTop + chartConfig.canvasHeight
  },
      trackerG = chart.getChildContainer('trackerGroup'),
      selectEleArr = chartConfig._selectEleArr || (chartConfig._selectEleArr = []),
      selectBoxG;

  // var TRACKER_FILL = 'rgba(255,0,0,0.3)';

  selectEleObj.index = selectEleArr.length;
  selectEleObj.id = 'SELECT_' + selectEleObj.index;

  selectEleObj.selectBoxG = selectBoxG = paper.group('selection-box', trackerG).toFront();

  // Drawing the main box element
  selectEleObj.selectBoxTracker = paper.rect(x, y, width, height, selectBoxG).attr({
    'stroke-width': 1,
    stroke: (0, _lib.toRaphaelColor)(chartConfig.selectBorderColor),
    ishot: true,
    fill: chartConfig.selectFillColor
  }).css({
    cursor: 'move'
  });
  selectEleObj.selectBoxTracker.data(configStr, {
    position: 6, // MOVE
    selectEleObj: selectEleObj,
    chart: chart,
    xChange: true,
    yChange: true
  });

  // Draw top tracker element
  selectEleObj.topTracker = paper.rect(x, y - TRACKER_HALF_WIDTH, width, TRACKER_WIDTH, selectBoxG).attr({
    'stroke-width': 0,
    ishot: true,
    fill: TRACKER_FILL
  }).css('cursor', _lib.hasSVG && 'ns-resize' || 'n-resize');
  selectEleObj.topTracker.data(configStr, {
    position: 1, // TOP
    selectEleObj: selectEleObj,
    yChange: true,
    chart: chart
  });

  // Draw right tracker element
  selectEleObj.rightTracker = paper.rect(x + width - TRACKER_HALF_WIDTH, y, TRACKER_WIDTH, height, selectBoxG).attr({
    'stroke-width': 0,
    ishot: true,
    fill: TRACKER_FILL
  }).css('cursor', _lib.hasSVG && 'ew-resize' || 'w-resize');
  selectEleObj.rightTracker.data(configStr, {
    position: 2, // RIGHT
    chart: chart,
    selectEleObj: selectEleObj,
    xChange: true
  });

  // Draw bottom tracker element
  selectEleObj.bottomTracker = paper.rect(x, y + height - TRACKER_HALF_WIDTH, width, TRACKER_WIDTH, selectBoxG).attr({
    'stroke-width': 0,
    ishot: true,
    fill: TRACKER_FILL
  }).css('cursor', _lib.hasSVG && 'ns-resize' || 'n-resize');
  selectEleObj.bottomTracker.data(configStr, {
    position: 3, // BOTTOM
    chart: chart,
    selectEleObj: selectEleObj,
    yChange: true
  });

  // Draw left tracker element
  selectEleObj.leftTracker = paper.rect(x - TRACKER_HALF_WIDTH, y, TRACKER_WIDTH, height, selectBoxG).attr({
    'stroke-width': 0,
    ishot: true,
    fill: TRACKER_FILL
  }).css('cursor', _lib.hasSVG && 'ew-resize' || 'e-resize');
  selectEleObj.leftTracker.data(configStr, {
    position: 4, // LEFT
    chart: chart,
    selectEleObj: selectEleObj,
    xChange: true
  });

  selectEleObj.cornerInnerSymbol = paper.symbol('resizeIcon', 0, 0, cornerSymbolRadius, selectBoxG).attr({
    transform: t + x2 + COMMA + y2,
    'stroke-width': 1,
    visibility: isSmall ? VISIBLE : HIDDEN,
    ishot: true,
    stroke: resizeInnerSymbolColor
  });

  selectEleObj.cornerOuterSymbol = paper.symbol('resizeIcon', 0, 0, -cornerSymbolRadius * 0.8, selectBoxG).attr({
    transform: t + x2 + COMMA + y2,
    strokeWidth: 1,
    visibility: !isSmall ? VISIBLE : HIDDEN,
    ishot: true,
    stroke: resizeOuterSymbolColor
  });

  selectEleObj.resizeTracker = paper.circle(x2, y2, trackerRadius, selectBoxG).attr({
    'stroke-width': 1,
    stroke: TRACKER_FILL,
    ishot: true,
    fill: TRACKER_FILL
  }).css('cursor', _lib.hasSVG && 'nwse-resize' || 'nw-resize');
  selectEleObj.resizeTracker.data(configStr, {
    position: 5, // Corner
    chart: chart,
    selectEleObj: selectEleObj,
    yChange: true,
    xChange: true
  });

  selectEleObj.closeButton = paper.symbol('closeIcon', 0, 0, closeButtonRadius, selectBoxG).attr({
    transform: 't' + x2 + COMMA + y,
    'stroke-width': 2,
    stroke: chartConfig.selectionCancelButtonBorderColor,
    fill: chartConfig.selectionCancelButtonFillColor,
    'stroke-linecap': ROUND,
    ishot: true,
    'stroke-linejoin': ROUND
  }).css({
    cursor: POINTER,
    _cursor: 'hand'
  }).click(function () {
    // Delete the selection
    chart.deleteSelection(this, chart);
  });
  selectEleObj.closeButton.data(configStr, {
    chart: chart,
    index: selectEleObj.index
  });

  // Previously wrong calculations were done. Fixed it.
  selectEleObj.startX = xAxis.getValue(x);
  selectEleObj.startY = yAxis.getValue(y);
  selectEleObj.endX = xAxis.getValue(x2);
  selectEleObj.endY = yAxis.getValue(y2);
  selectEleObj.isVisible = true;

  selectEleArr.push(selectEleObj);
  chart.bindDragEvent(selectEleObj);
}

function _deleteSelection(ele, chart) {
  var index = ele.data(configStr).index,
      selectEleArr = chart.config._selectEleArr,
      selectEleObj = selectEleArr[index],
      selectT = selectEleObj.selectBoxTracker,
      selectEleItem,
      xAxis = chart.getChildren('xAxis')[0],
      yAxis = chart.getChildren('yAxis')[0],
      items,
      bBox,
      eventArgs;
  bBox = selectT.getBBox();
  eventArgs = {
    selectionLeft: bBox.x,
    selectionTop: bBox.y,
    selectionWidth: bBox.width,
    selectionHeight: bBox.height,
    startXValue: xAxis.getPixel(bBox.x, 1),
    startYValue: yAxis.getPixel(bBox.y, 1),
    endXValue: xAxis.getPixel(bBox.x + bBox.width, 1),
    endYValue: yAxis.getPixel(bBox.y + bBox.height, 1),
    data: chart.getCollatedData(),
    id: selectEleObj.id
  };

  for (items in selectEleObj) {
    if (selectEleObj.hasOwnProperty(items)) {
      selectEleItem = selectEleObj[items];
      selectEleItem.remove && selectEleItem.remove();
      delete selectEleObj[items];
    }
  }
  selectEleArr.splice(index, 1);
  /**
   * This event is raised when the selection of a SelectScatter chart is removed. This happens when one
   * clicks the close button on a selection that one has made on the chart.
   *
   * @event FusionCharts#selectionRemoved
   * @group chart-powercharts:selectscatter
   *
   * @param {Object} data - This returns the subset of data that was selected.
   */
  chart.fireChartInstanceEvent('selectionRemoved', eventArgs);
}

Raphael.addSymbol({
  resizeIcon: function resizeIcon(x, y, radius) {
    var LINE_GAP = (0, _lib.pluckNumber)(radius, 15) / 3,
        LINE_DIS = 3,
        paths = [],
        i;

    if (LINE_GAP < 0) {
      LINE_GAP = -LINE_GAP;
      radius = -radius;
      x += radius - LINE_GAP / 2;
      y += radius - LINE_GAP / 2;
    }

    for (i = 3; i > 0; i -= 1) {
      paths.push(M, x - LINE_GAP * i, y - LINE_DIS, L, x - LINE_DIS, y - LINE_GAP * i);
    }
    return paths;
  },
  closeIcon: function closeIcon(x, y, r) {
    var icoX = x,
        icoY = y,
        rad = r * 1.3,
        startAngle = 43 * deg2rad,

    // to prevent cos and sin of start and end from becoming
    // equal on 360 arcs
    endAngle = 48 * deg2rad,
        startX = icoX + rad * Math.cos(startAngle),
        startY = icoY + rad * Math.sin(startAngle),
        endX = icoX + rad * Math.cos(endAngle),
        endY = icoY + rad * Math.sin(endAngle),
        paths,
        r1 = 0.71 * (r - 2),
        // (r - 2) * 0.5,
    r2 = 0.71 * (r - 2),
        // (r - 2) * 0.87,

    arcPath = getArcPath(endX, endY, rad, rad, 0, 1);

    paths = [M, startX, startY];
    paths = paths.concat(arcPath);
    paths = paths.concat([M, x + r1, y - r2, L, x - r1, y + r2, M, x - r1, y - r2, L, x + r1, y + r2]);

    return paths;
  },
  configureIcon: function configureIcon(x, y, r) {
    r = r - 1;
    var k = 0.5,
        l = 0.25,
        r1 = r * 0.71,
        r2 = (r + 2) * 0.71,
        x1 = x - r,
        y1 = y - r,
        x2 = x + r,
        y2 = y + r,
        x3 = x + k,
        y3 = y + k,
        x4 = x - k,
        y4 = y - k,
        x5 = x1 - 2,
        y5 = y1 - 2,
        x6 = x2 + 2,
        y6 = y2 + 2,
        x7 = x + r1,
        y7 = y + r1,
        x8 = x - r1,
        y8 = y - r1,
        x9 = x + r2,
        y9 = y + r2,
        x10 = x - r2,
        y10 = y - r2,
        paths;

    paths = [M, x1, y3, L, x5, y3, x5, y4, x1, y4, x8 - l, y8 + l, x10 - l, y10 + l, x10 + l, y10 - l, x8 + l, y8 - l, x4, y1, x4, y5, x3, y5, x3, y1, x7 - l, y8 - l, x9 - l, y10 - l, x9 + l, y10 + l, x7 + l, y8 + l, x2, y4, x6, y4, x6, y3, x2, y3, x7 + l, y7 - l, x9 + l, y9 - l, x9 - l, y9 + l, x7 - l, y7 + l, x3, y2, x3, y6, x4, y6, x4, y2, x8 + l, y7 + l, x10 + l, y9 + l, x10 - l, y9 - l, x8 - l, y7 - l, Z];
    return paths;
  },
  axisIcon: function axisIcon(x, y, r) {
    r = r - 1;
    var r1 = r * 0.33,
        r2 = r / 2,
        x1 = x - r,
        y1 = y - r,
        x2 = x + r2,
        y2 = y + r,
        x3 = x - r2,
        y3 = y + r1,
        y4 = y - r1,
        paths;

    paths = [M, x1, y1, L, x2, y1, x2, y2, x1, y2, M, x3, y3, L, x2, y3, M, x3, y4, L, x2, y4];
    return paths;
  },
  loggerIcon: function loggerIcon(x, y, r) {
    r = r - 1;
    x = x - r;
    y = y - r;
    var r2 = r * 2,
        x1 = x + r2,
        x2 = x + 2,
        x3 = x1 - 2,
        y1 = y + 2,
        y2 = y1 + r,
        y3 = y2 + 2,
        paths;

    paths = [M, x, y, L, x1, y, x1, y1, x3, y1, x3, y2, x1, y2, x1, y3, x, y3, x, y2, x2, y2, x2, y1, x, y1, x, y];
    return paths;
  }
});

var SelectScatter = function (_ScatterBase) {
  _inherits(SelectScatter, _ScatterBase);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  SelectScatter.getName = function getName() {
    return 'SelectScatter';
  };

  function SelectScatter() {
    _classCallCheck(this, SelectScatter);

    var _this = _possibleConstructorReturn(this, _ScatterBase.call(this));

    _this.isXY = true;

    _this.defaultZeroPlaneHighlighted = false;
    _this.eiMethods = {
      getData: function getData(format) {
        var apiInstance = this.apiInstance;
        return apiInstance && apiInstance.getData(format);
      },
      restoreData: function restoreData() {
        var apiInstance = this.apiInstance;
        return apiInstance && apiInstance.restoreData();
      },
      submitData: function submitData() {
        var apiInstance = this.apiInstance;
        return apiInstance && apiInstance.submitData();
      }
    };
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  SelectScatter.prototype.getName = function getName() {
    return 'SelectScatter';
  };

  SelectScatter.prototype.configure = function configure(dataObj) {
    var iapi = this,
        chartConfig = iapi.getFromEnv('chart').config,
        chartAttr = iapi.getFromEnv('dataSource').chart;
    chartConfig.formAction = (0, _lib.getValidValue)(chartAttr.formaction);
    _fusioncharts3.configurer.call(iapi, dataObj);
  };

  SelectScatter.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ScatterBase.prototype.__setDefaultConfig && _ScatterBase.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Dragable Scatter Chart';
    config.hasLegend = true;
    config.defaultDatasetType = 'selectScatter';
    config.allowreversexaxis = true;
    config.enablemousetracking = true;
  };

  SelectScatter.prototype._createToolBox = function _createToolBox() {
    _ScatterBase.prototype._createToolBox.call(this);
    var iapi = this,
        chartConfig = iapi.getFromEnv('chartConfig'),
        chartMenuList = iapi.getFromEnv('chartMenuList');

    chartConfig.showRestoreBtn && chartMenuList.appendAsList([{
      'Restore': {
        handler: function handler() {
          iapi.restoreData();
        },
        action: 'click'
      }
    }]);

    chartConfig.formAction && chartMenuList.appendAsList([{
      'Submit': {
        handler: function handler() {
          iapi.submitData();
        },
        action: 'click'
      }
    }]);
  };

  SelectScatter.prototype.getData = function getData(format) {
    // create a two dimensional array as given in the docs
    var iapi = this,
        dataObj = iapi.getCollatedData(),
        returnObj = [],
        datasets = dataObj.dataset,
        length = datasets && datasets.length || 0,
        index = 0,
        NULLSTR = 'null',
        dsInd = 0,
        setLen,
        set,
        j;

    // When a format is provided
    if (format) {
      // no transcoding needed for json
      if (/^json$/ig.test(format)) {
        returnObj = dataObj;
      } else if (/^csv$/ig.test(format)) {
        returnObj = iapi.getCSVString();
      } else {
        returnObj = global.core.transcodeData(dataObj, 'json', format);
      }
    } else {
      // if no format has been specified, return data as 2d array.
      // while (length--) {
      for (; index < length; index += 1) {
        set = datasets[index];
        if (set) {
          set = datasets[index] && datasets[index].data;
          j = setLen = set && set.length || 0;
          j && (returnObj[dsInd] || (returnObj[dsInd] = [(0, _lib.getValidValue)(datasets[index].id, NULLSTR)]));
          while (j--) {
            returnObj[dsInd][j + 1] = (0, _lib.getValidValue)(set[j].id, NULLSTR);
          }

          setLen && (dsInd += 1);
        }
      }
    }
    return returnObj;
  };

  SelectScatter.prototype.getCSVString = function getCSVString() {
    var chart = this,
        dataObj = chart.getData(),
        i = dataObj.length;

    while (i--) {
      dataObj[i] = dataObj[i].join(COMMA);
    }

    return dataObj.join('|');
  };

  /**
   * Takes datasource and finds out all the points present in the selection box.
   * @returns {Object} origChartData - Final data
   * @memberof SelectScatter
   */


  SelectScatter.prototype.getCollatedData = function getCollatedData() {
    var api = this,
        dataset = api.getDatasets(),
        selectedArr = api.config._selectEleArr,
        len = selectedArr && selectedArr.length || 0,
        jsonData = api.getFromEnv('dataSource'),
        origChartData = (0, _lib.extend2)({}, jsonData),
        origDataSets = origChartData.dataset,
        xPos,
        yPos,
        oriDataArr,
        selectionBoxObj,
        lenDS = origDataSets && origDataSets.length,
        isSelected = false,
        dataIndex,
        setObj,
        dataLen,
        startX,
        endX,
        startY,
        endY,
        selectedData = [];

    if (!len || !lenDS) {
      return jsonData;
    }
    while (len--) {
      selectionBoxObj = selectedArr[len];
      if (!selectionBoxObj) {
        continue;
      }
      startX = selectionBoxObj.startX;
      endX = selectionBoxObj.endX;
      startY = selectionBoxObj.startY;
      endY = selectionBoxObj.endY;
      dataIndex = lenDS;
      while (dataIndex--) {
        if (!dataset[dataIndex].getState('visible')) {
          continue;
        }
        selectedData[dataIndex] || (selectedData[dataIndex] = {
          data: []
        });
        oriDataArr = origDataSets[dataIndex].data;
        dataLen = oriDataArr && oriDataArr.length;
        while (dataLen--) {
          setObj = oriDataArr[dataLen];
          xPos = setObj.x;
          yPos = setObj.y;
          if (xPos > startX && xPos < endX && yPos < startY && yPos > endY) {
            selectedData[dataIndex].data[dataLen] = isSelected = true;
          }
        }
      }
    }

    while (lenDS--) {
      oriDataArr = origDataSets[lenDS].data;
      dataLen = oriDataArr && oriDataArr.length;
      while (dataLen--) {
        if (!(selectedData[lenDS] && selectedData[lenDS].data[dataLen])) {
          oriDataArr.splice(dataLen, 1);
        }
      }
    }
    return isSelected ? origChartData : jsonData;
  };

  SelectScatter.prototype.createSelectionBox = function createSelectionBox(event) {
    _createSelectionBox.call(this, event);
  };

  SelectScatter.prototype._deleteAllSelection = function _deleteAllSelection() {
    var chart = this,
        selectEleArr = chart.config._selectEleArr,
        selectEleObj,
        selectEleItem,
        items,
        items1;

    for (items in selectEleArr) {
      if (selectEleArr.hasOwnProperty(items)) {
        selectEleObj = selectEleArr[items];
        for (items1 in selectEleObj) {
          if (selectEleObj.hasOwnProperty(items1)) {
            selectEleItem = selectEleObj[items1];
            selectEleItem.remove && selectEleItem.remove();
            delete selectEleObj[items1];
          }
        }
        delete selectEleArr[items];
      }
    }
  };

  SelectScatter.prototype.deleteSelection = function deleteSelection(ele, chart) {
    _deleteSelection.call(this, ele, chart);
  };

  SelectScatter.prototype.bindDragEvent = function bindDragEvent(selectEleObj) {
    var chart = this,

    // logic = chart.logic,
    item;
    for (item in selectEleObj) {
      /Tracker/.test(item) && selectEleObj[item].drag(chart.move, chart.start, chart.up);
    }
  };

  SelectScatter.prototype.start = function start() {
    var ele = this,
        data = ele.data(configStr),
        selectEleObj = data.selectEleObj,
        topT = selectEleObj.topTracker,
        rightT = selectEleObj.rightTracker,
        bottomT = selectEleObj.bottomTracker,
        leftT = selectEleObj.leftTracker,
        resizeT = selectEleObj.resizeTracker,
        topTData = topT.data(configStr),
        rightTData = rightT.data(configStr),
        bottomTData = bottomT.data(configStr),
        leftTData = leftT.data(configStr),
        resizeTData = resizeT.data(configStr),
        selectTData = selectEleObj.selectBoxTracker.data(configStr),
        bBox = selectEleObj.selectBoxTracker.getBBox();

    topTData.ox = bBox.x;
    topTData.oy = bBox.y;

    rightTData.ox = bBox.x2;
    rightTData.oy = bBox.y;

    bottomTData.ox = bBox.x;
    bottomTData.oy = bBox.y2;

    leftTData.ox = bBox.x;
    leftTData.oy = bBox.y;

    topTData.ox = bBox.x;
    topTData.oy = bBox.y;

    resizeTData.ox = bBox.x2;
    resizeTData.oy = bBox.y2;

    selectTData.ox = bBox.x;
    selectTData.oy = bBox.y;
    selectTData.ow = bBox.width;
    selectTData.oh = bBox.height;
    selectTData.ox2 = bBox.x2;
    selectTData.oy2 = bBox.y2;
    // on click take the selection box on top.
    selectEleObj.selectBoxG.toFront();

    topT.hide();
    rightT.hide();
    bottomT.hide();
    leftT.hide();
    resizeT.hide();
    ele.show();
  };

  SelectScatter.prototype.move = function move(evt) {
    var ele = this,
        data = ele.data(configStr),
        selectEleObj = data.selectEleObj,
        chart = data.chart,
        topT = selectEleObj.topTracker,
        rightT = selectEleObj.rightTracker,
        bottomT = selectEleObj.bottomTracker,
        leftT = selectEleObj.leftTracker,
        resizeT = selectEleObj.resizeTracker,
        selectT = selectEleObj.selectBoxTracker,
        canvasLeft = selectEleObj.canvasLeft,
        canvasRight = selectEleObj.canvasRight,
        canvasTop = selectEleObj.canvasTop,
        canvasBottom = selectEleObj.canvasBottom,
        HALF_T_WID = -6,
        xAxis = chart.getChildren('xAxis')[0],
        yAxis = chart.getChildren('yAxis')[0],
        selectTData = selectT.data(configStr),
        attrib = {},
        bBox,
        dx = evt.data[0],
        dy = evt.data[1],
        eventArgs,
        x,
        y;

    dx = data.xChange ? dx : 0;
    dy = data.yChange ? dy : 0;

    x = dx + data.ox;
    y = dy + data.oy;

    x = Math.min(canvasRight - (data.ow || 0), Math.max(x, canvasLeft));
    y = Math.min(canvasBottom - (data.oh || 0), Math.max(y, canvasTop));

    switch (data.position) {
      case 1:
        // TOP
        attrib.y = Math.min(selectTData.oy2, y);
        attrib.height = Math.abs(selectTData.oy2 - y) || 1;
        topT.attr({
          y: y + HALF_T_WID
        });
        break;
      case 2:
        // Right
        attrib.x = Math.min(selectTData.ox, x);
        attrib.width = Math.abs(selectTData.ox - x) || 1;
        rightT.attr({
          x: x + HALF_T_WID
        });
        break;
      case 3:
        // Bottom
        attrib.y = Math.min(selectTData.oy, y);
        attrib.height = Math.abs(selectTData.oy - y) || 1;
        bottomT.attr({
          y: y + HALF_T_WID
        });
        break;
      case 4:
        // Left
        attrib.x = Math.min(selectTData.ox2, x);
        attrib.width = Math.abs(selectTData.ox2 - x) || 1;
        leftT.attr({
          x: x + HALF_T_WID
        });
        break;
      case 5:
        // Corner
        attrib.x = Math.min(selectTData.ox, x);
        attrib.width = Math.abs(selectTData.ox - x) || 1;
        attrib.y = Math.min(selectTData.oy, y);
        attrib.height = Math.abs(selectTData.oy - y) || 1;
        resizeT.attr({
          cx: x,
          cy: y
        });
        break;
      default:
        attrib.x = x;
        attrib.y = y;
        break;
    }

    if (!ele.data('dragStarted')) {
      bBox = selectT.getBBox();

      eventArgs = {
        selectionLeft: bBox.x,
        selectionTop: bBox.y,
        selectionWidth: bBox.width,
        selectionHeight: bBox.height,
        startXValue: xAxis.getValue(bBox.x),
        startYValue: yAxis.getValue(bBox.y),
        endXValue: xAxis.getValue(bBox.x + bBox.width),
        endYValue: yAxis.getValue(bBox.y + bBox.height),
        id: selectEleObj.id
      };

      chart.fireChartInstanceEvent('BeforeSelectionUpdate', eventArgs);
      ele.data('dragStarted', 1);
    }

    selectT.animate(attrib);

    if (selectEleObj.isVisible) {
      selectEleObj.closeButton.hide();
      selectEleObj.cornerInnerSymbol.hide();
      selectEleObj.cornerOuterSymbol.hide();
      selectEleObj.isVisible = false;
    }
  };

  SelectScatter.prototype.up = function up() {
    var ele = this,
        data = ele.data(configStr),
        selectEleObj = data.selectEleObj,
        chart = data.chart,
        xAxis = chart.getChildren('xAxis')[0],
        yAxis = chart.getChildren('yAxis')[0],
        topT = selectEleObj.topTracker,
        rightT = selectEleObj.rightTracker,
        bottomT = selectEleObj.bottomTracker,
        leftT = selectEleObj.leftTracker,
        resizeT = selectEleObj.resizeTracker,
        selectT = selectEleObj.selectBoxTracker,
        RESIZE_T_RADIUS = 15,
        HALF_T_WID = -6,
        bBox,
        eventArgs;

    // using setTimeout to fix for the issue #RED-476.
    setTimeout(function () {
      bBox = selectT.getBBox();

      selectEleObj.startX = xAxis.getValue(bBox.x);
      selectEleObj.startY = yAxis.getValue(bBox.y);
      selectEleObj.endX = xAxis.getValue(bBox.x2);
      selectEleObj.endY = yAxis.getValue(bBox.y2);

      topT.attr({
        x: bBox.x,
        y: bBox.y + HALF_T_WID,
        width: bBox.width
      });
      rightT.attr({
        x: bBox.x2 + HALF_T_WID,
        y: bBox.y,
        height: bBox.height
      });
      bottomT.attr({
        x: bBox.x,
        y: bBox.y2 + HALF_T_WID,
        width: bBox.width
      });
      leftT.attr({
        x: bBox.x + HALF_T_WID,
        y: bBox.y,
        height: bBox.height
      });
      resizeT.attr({
        cx: bBox.x2,
        cy: bBox.y2
      });

      selectEleObj.closeButton.transform(t + bBox.x2 + COMMA + bBox.y);
      selectEleObj.cornerInnerSymbol.transform(t + bBox.x2 + COMMA + bBox.y2);
      selectEleObj.cornerOuterSymbol.transform(t + bBox.x2 + COMMA + bBox.y2);
      selectEleObj.closeButton.show();
      if (bBox.width < RESIZE_T_RADIUS || bBox.height < RESIZE_T_RADIUS) {
        selectEleObj.cornerInnerSymbol.hide();
        selectEleObj.cornerOuterSymbol.show();
      } else {
        selectEleObj.cornerInnerSymbol.show();
        selectEleObj.cornerOuterSymbol.hide();
      }
      selectEleObj.isVisible = true;

      topT.show();
      rightT.show();
      bottomT.show();
      leftT.show();
      resizeT.show();

      if (ele.data('dragStarted')) {
        eventArgs = {
          selectionLeft: bBox.x,
          selectionTop: bBox.y,
          selectionWidth: bBox.width,
          selectionHeight: bBox.height,
          startXValue: xAxis.getValue(bBox.x),
          startYValue: yAxis.getValue(bBox.y),
          endXValue: xAxis.getValue(bBox.x + bBox.width),
          endYValue: yAxis.getValue(bBox.y + bBox.height),
          data: chart.getCollatedData(),
          id: selectEleObj.id
        };
        chart.fireChartInstanceEvent('SelectionUpdated', eventArgs);
        ele.data('dragStarted', 0);
      }
    }, 100);
  };

  SelectScatter.prototype.restoreData = function restoreData() {
    var chart = this,
        datasets = [],
        i;

    chart.iterateComponents(function (child) {
      if (child.getType && child.getType() === 'dataset') {
        datasets.push(child);
      }
    });

    chart._deleteAllSelection();
    for (i = 0; i < datasets.length; i++) {
      datasets[i].asyncDraw();
    }
    // raiseEvent('dataRestored', {}, chart.chartInstance, [chart.chartInstance.id]);
    return true;
  };

  /**
   * Executes on clicking submit.
   * Takes data preent in the selection box and sends it to the server.
   * @memberof SelectScatter
   */


  SelectScatter.prototype.submitData = function submitData() {
    var chart = this,

    // iapi = chart.apiInstance,
    ajaxObj = new _ajax2['default'](),
        chartConf = chart.config,
        json = transcoders.json(),
        csv = transcoders.csv && transcoders.csv() || 'csv',
        xml = transcoders.xml(),
        url = chartConf.formAction,
        chartInstance = chart.getFromEnv('chartInstance'),
        submitAsAjax = chartConf.submitFormAsAjax,
        requestType,
        data,
        paramObj,
        tempSpan,
        formEle;

    if (chartConf.formDataFormat === json.format) {
      requestType = json.format;
      data = (0, _stringify2['default'])(chart.getCollatedData());
    } else if (chartConf.formDataFormat && chartConf.formDataFormat === csv.format) {
      requestType = csv.format;
      data = chart.getCSVString && chart.getCSVString();
      if (data === UNDEF || data === '') {
        data = csv.fromJSON(chart.getCollatedData()).data;
      }
    } else {
      requestType = xml.format;
      data = xml.fromJSON(chart.getCollatedData()).data;
    }

    // cancel data submit function added in event options
    /**
     * For interative charts like `Select Scatter`, `DragNode`, `Dragable Column2D ` and etc., data
     * points value can be selected for `Scatter Chart` and values can be changed for dragable charts by
     * clicking and dragging the data points whose data point values can be sent to an URL by ajax POST.
     * This is the first event raised when `Submit` button is clicked where the current chart data is
     * about to be sent to the set URL.
     *
     * @event FusionCharts#beforeDataSubmit
     * @group chart-powercharts
     *
     * @param {string} data - Contains the XML string with complete chart data at it's current state.
     *
     */
    chart.fireChartInstanceEvent('beforeDataSubmit', {
      data: data
    }, UNDEF, function () {
      // After the collation is done, we have to submit the data using
      // ajax or form submit method.
      if (!submitAsAjax) {
        // Create a hidden form with data inside it.
        tempSpan = window.document.createElement('span');
        tempSpan.innerHTML = '<form style="display:none" action="' + url + '" method="' + chartConf.formMethod + '" target="' + chartConf.formTarget + '"> <input type="hidden" name="strXML" value="' + (0, _lib.xssEncode)(data) + '"><input type="hidden" name="dataFormat" value="' + requestType.toUpperCase() + '" /></form>';

        formEle = tempSpan.removeChild(tempSpan.firstChild);

        // Append the form to body and then submit it.
        window.document.body.appendChild(formEle);
        formEle.submit && formEle.submit();
        // cleanup
        formEle.parentNode.removeChild(formEle);
        tempSpan = formEle = null;
      } else {
        // eslint-disable-next-line
        ajaxObj.onError = function (response, wrapper, ajaxData, url) {
          /**
           * For interative charts like `Select Scatter`, `DragNode`, `Dragable Column2D ` and etc.,
           * data points value can be selected for `Scatter Chart` and values can be changed for
           * dragable charts by clicking and dragging the data points whose data point values can be
           * sent to an URL by ajax POST. This event is raised if there is an ajax error in sending
           * the chart XML data.
           *
           * @event FusionCharts#dataSubmitError
           * @group chart-powercharts
           *
           * @param {string} data - Contains the XML string with complete chart data.
           * @param {number} httpStatus - Tells the status code of the ajax POST request
           * @param {string} statusText - Contains the ajax error message.
           * @param {string} url - URL to which the data is sent as ajax POST request.
           * @param {object} xhrObject - XMLHttpRequest object which takes care of sending the XML
           * chart data. In case of error, this object won't be defined.
           */
          chart.fireChartInstanceEvent('dataSubmitError', {
            xhrObject: wrapper.xhr,
            url: url,
            statusText: response,
            httpStatus: wrapper.xhr && wrapper.xhr.status ? wrapper.xhr.status : -1,
            data: data
          }, [chartInstance.id, response, wrapper.xhr && wrapper.xhr.status]);
        };
        // eslint-disable-next-line
        ajaxObj.onSuccess = function (response, wrapper, ajaxData, url) {
          /**
           * For interative charts like `Select Scatter`, `DragNode`, `Dragable Column2D ` and etc.,
           * data points value can be selected for `Scatter Chart` and values can be changed for
           * dragable charts by clicking and dragging the data points whose data point values can be
           * sent to an URL by ajax POST. This event is raised when the ajax POST request is
           * successfully completed.
           *
           * @event FusionCharts#dataSubmitted
           * @group chart-powercharts
           *
           * @param {string} data - Contains the XML string with complete chart data.
           * @param {string} reponse - Contains the reponse returned by the web server to which the
           * HTTP POST request was submitted.
           * @param {string} url - URL to which the data is sent as HTTP POST request.
           * @param {object} xhrObject - XMLHttpRequest object which takes care of sending the XML
           * chart data
           */
          chart.fireChartInstanceEvent('dataSubmitted', {
            xhrObject: ajaxObj,
            response: response,
            url: url,
            data: data
          }, [chartInstance.id, response]);
        };

        paramObj = {};
        paramObj['str' + requestType.toUpperCase()] = data;

        if (ajaxObj.open) {
          ajaxObj.abort();
        }
        ajaxObj.post(url, paramObj);
      }
    }, function () {
      /**
       * For interative charts like `Select Scatter`, `DragNode`, `Dragable Column2D ` and etc.,
       * data points value can be selected for `Scatter Chart` and values can be changed for
       * dragable charts by clicking and dragging the data points whose data point values can be
       * sent to an URL by ajax POST. This event is raised when `preventDefault()` method is called
       * from the `eventObject` of FusionCharts#beforeDataSubmit event.
       *
       * @event FusionCharts#dataSubmitCancelled
       * @group chart-powercharts
       *
       * @param {string} data - Contains the XML string with complete chart data.
       * @param {number} httpStatus - Tells the status code of the ajax POST request
       * @param {string} statusText - Contains the ajax error message.
       * @param {string} url - URL to which the data is sent as ajax POST request.
       * @param {object} xhrObject - XMLHttpRequest object which takes care of sending the XML
       * chart data. In case of error, this object won't be defined.
       * @example
       * FusionCharts.addEventListener('beforeDataSubmit', function(eventObject, parameterObject) {
       *  eventObject.preventDefault();
       * }
       */
      chart.fireChartInstanceEvent('dataSubmitCancelled', {
        data: data
      });
    });
  };

  SelectScatter.prototype._postSpaceManagement = function _postSpaceManagement() {
    var iapi = this;
    _ScatterBase.prototype._postSpaceManagement.call(this);
    iapi._deleteAllSelection();
  };

  SelectScatter.prototype.getDSdef = function getDSdef() {
    return _selectscatter2['default'];
  };
  // This method return the dataset-group definations for this charts


  SelectScatter.prototype.getDSGroupdef = function getDSGroupdef() {
    return UNDEF;
  };

  return SelectScatter;
}(_fusioncharts2['default']);

exports['default'] = SelectScatter;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)))

/***/ }),

/***/ 816:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _scatter = __webpack_require__(109);

var _scatter2 = _interopRequireDefault(_scatter);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var COLOR_FFFFFF = 'FFFFFF',
    convertColor = _lib.graphics.convertColor,
    altHGridColorStr = _lib.preDefStr.altHGridColorStr,
    altHGridAlphaStr = _lib.preDefStr.altHGridAlphaStr;
/**
 * Creates dataset class of Select scatter
 */

var SelectScatterDataset = function (_ScatterDataset) {
  _inherits(SelectScatterDataset, _ScatterDataset);

  function SelectScatterDataset() {
    _classCallCheck(this, SelectScatterDataset);

    return _possibleConstructorReturn(this, _ScatterDataset.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  SelectScatterDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  SelectScatterDataset.prototype.getName = function getName() {
    return 'selectScatter';
  };
  /**
   * Configure default settings for datasets
   * @param {Object} datasetJSON dataset json
   */


  SelectScatterDataset.prototype.configure = function configure(datasetJSON) {
    _ScatterDataset.prototype.configure.call(this, datasetJSON);
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        chartAttr = chart.getFromEnv('dataSource').chart,
        colorM = dataSet.getFromEnv('color-manager'),
        borderColor = (0, _lib.pluck)(chartAttr.selectbordercolor, colorM.getColor('canvasBorderColor')),
        borderAlpha = (0, _lib.pluckNumber)(chartAttr.selectborderalpha, colorM.getColor('canvasBorderAlpha'));

    chartConfig.selectBorderColor = // convertColor(borderColor, borderAlpha);
    {
      FCcolor: {
        color: borderColor,
        alpha: borderAlpha
      }
    };
    chartConfig.selectFillColor = convertColor((0, _lib.pluck)(chartAttr.selectfillcolor, colorM.getColor(altHGridColorStr)), (0, _lib.pluckNumber)(chartAttr.selectfillalpha, colorM.getColor(altHGridAlphaStr)));

    chartConfig.selectionCancelButtonBorderColor = convertColor((0, _lib.pluck)(chartAttr.selectioncancelbuttonbordercolor, borderColor), (0, _lib.pluckNumber)(chartAttr.selectioncancelbuttonborderalpha, borderAlpha));
    chartConfig.selectionCancelButtonFillColor = convertColor((0, _lib.pluck)(chartAttr.selectioncancelbuttonfillcolor, COLOR_FFFFFF), (0, _lib.pluckNumber)(chartAttr.selectioncancelbuttonfillalpha, 100));
    chartConfig.connativeZoom = false;
    chartConfig.zoomType = 'xy';

    if (chartAttr.submitdataasxml === _lib.ZEROSTRING && !chartAttr.formdataformat) {
      chartAttr.formdataformat = global.dataFormats.CSV;
    }
    // @ temp will work after transcoder fix
    // chartConfig.formDataFormat = pluck(chartAttr.formdataformat,
    //             global.dataFormats.XML);
    chartConfig.formDataFormat = (0, _lib.pluck)(chartAttr.formdataformat);
    chartConfig.formTarget = (0, _lib.pluck)(chartAttr.formtarget, '_self');
    chartConfig.formMethod = (0, _lib.pluck)(chartAttr.formmethod, 'POST');
    chartConfig.submitFormAsAjax = (0, _lib.pluckNumber)(chartAttr.submitformusingajax, 1);
  };
  /**
   * Draws plot graphics
   */


  SelectScatterDataset.prototype.draw = function draw() {
    _ScatterDataset.prototype.draw.call(this);
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        container = chart.getFromEnv('chart-container'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis');

    (0, _lib.bindSelectionEvent)(chart, {
      selectionStart: function selectionStart(data) {
        var pos = (0, _lib.getMouseCoordinate)(container, data.originalEvent),
            eventArgs = (0, _lib.extend2)({
          selectionLeft: data.selectionLeft,
          selectionTop: data.selectionTop,
          selectionWidth: data.selectionWidth,
          selectionHeight: data.selectionHeight,
          startXValue: xAxis.getPixel(data.selectionLeft, 1),
          startYValue: yAxis.getPixel(data.selectionTop, 1)
        }, pos);
        /**
         * Raised when user starts to draw a selection box on a `selectScatter` chart.
         * @event FusionCharts#selectionStart
         *
         * @param {number} chartX - The x-coordinate of the mouse with respect to the chart.
         * @param {number} chartY - The y-coordinate of the mouse with respect to the chart.
         * @param {number} pageX - The x-coordinate of the mouse with respect to the page.
         * @param {number} pageY - The y-coordinate of the mouse with respect to the page.
         * @param {number} startXValue - The value on the canvas x-axis where the selection started.
         * @param {number} startYValue - The value on the canvas y-axis where the selection started.
         */
        data.chart.fireChartInstanceEvent('selectionStart', eventArgs);
      },
      selectionEnd: function selectionEnd(data) {
        var pos = (0, _lib.getMouseCoordinate)(container, data.originalEvent),
            eventArgs = (0, _lib.extend2)({
          selectionLeft: data.selectionLeft,
          selectionTop: data.selectionTop,
          selectionWidth: data.selectionWidth,
          selectionHeight: data.selectionHeight,
          startXValue: xAxis.getPixel(data.selectionLeft, 1),
          startYValue: yAxis.getPixel(data.selectionTop, 1),
          endXValue: xAxis.getPixel(data.selectionLeft + data.selectionWidth, 1),
          endYValue: yAxis.getPixel(data.selectionTop + data.selectionHeight, 1)
        }, pos);

        /**
         * Raised when user completes a selection box on a `selectScatter` chart.
         * @event FusionCharts#selectionEnd
         *
         * @param {number} chartX - The x-coordinate of the mouse with respect to the chart.
         * @param {number} chartY - The y-coordinate of the mouse with respect to the chart.
         * @param {number} pageX - The x-coordinate of the mouse with respect to the page.
         * @param {number} pageY - The y-coordinate of the mouse with respect to the page.
         * @param {number} startXValue - The value on the canvas x-axis where the selection started.
         * @param {number} startYValue - The value on the canvas y-axis where the selection started.
         * @param {number} endXValue - The value on the canvas x-axis where the selection ended.
         * @param {number} endYValue - The value on the canvas y-axis where the selection ended.
         * @param {number} selectionLeft - The x-coordinate from where selection started with
         * respect to the chart.
         * @param {number} selectionTop - The y-coordinate from where selection started with
         * respect to the chart.
         * @param {number} selectionWidth - The width of the selection in pixels.
         * @param {number} selectionHeight - The height of the selection box in pixels.
         */
        data.chart.fireChartInstanceEvent('selectionEnd', eventArgs);
        data.chart.createSelectionBox(data);
      }
    });
  };

  return SelectScatterDataset;
}(_scatter2['default']);

exports['default'] = SelectScatterDataset;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)))

/***/ }),

/***/ 817:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(369);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _fusioncharts3 = __webpack_require__(17);

var _mssplinearea = __webpack_require__(94);

var _mssplinearea2 = _interopRequireDefault(_mssplinearea);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var SplineArea = function (_Spline) {
  _inherits(SplineArea, _Spline);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  SplineArea.getName = function getName() {
    return 'SplineArea';
  };

  function SplineArea() {
    _classCallCheck(this, SplineArea);

    var _this = _possibleConstructorReturn(this, _Spline.call(this));

    _this.defaultPlotShadow = 0;
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  SplineArea.prototype.getName = function getName() {
    return 'SplineArea';
  };
  /**
   * parse defualt configuration of the chart
   */


  SplineArea.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _Spline.prototype.__setDefaultConfig && _Spline.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    _fusioncharts3._setDefaultConfig.call(this);
    config.friendlyName = 'Spline Area Chart';
    config.singleseries = true;
    config.hasLegend = false;
    config.defaultDatasetType = 'mssplinearea';
    config.anchoralpha = '100';
    config.minimizetendency = 0;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
  };

  SplineArea.prototype.getDSdef = function getDSdef() {
    return _mssplinearea2['default'];
  };

  SplineArea.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  return SplineArea;
}(_fusioncharts2['default']);

exports['default'] = SplineArea;

/***/ }),

/***/ 819:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(17);

var _fusioncharts2 = __webpack_require__(70);

var _fusioncharts3 = _interopRequireDefault(_fusioncharts2);

var _msspline = __webpack_require__(45);

var _msspline2 = _interopRequireDefault(_msspline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var MSSplineDy = function (_MSDyBaseCartesian) {
  _inherits(MSSplineDy, _MSDyBaseCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSSplineDy.getName = function getName() {
    return 'MSSplineDy';
  };

  function MSSplineDy() {
    _classCallCheck(this, MSSplineDy);

    var _this = _possibleConstructorReturn(this, _MSDyBaseCartesian.call(this));

    _this.isDual = true;
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  MSSplineDy.prototype.getName = function getName() {
    return 'MSSplineDy';
  };
  /**
   * parse defualt configuration of the chart
   */


  MSSplineDy.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSDyBaseCartesian.prototype.__setDefaultConfig && _MSDyBaseCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Multi-series Dual Y-Axis Spline Chart';
    config.defaultDatasetType = 'msspline';
    config.minimizetendency = 0;
    config.zeroplanethickness = 1;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
    config.isdual = true;
    _fusioncharts._setDefaultConfig.call(this);
  };

  MSSplineDy.prototype.getDSdef = function getDSdef() {
    return _msspline2['default'];
  };

  MSSplineDy.prototype.getDSGroupdef = function getDSGroupdef() {}
  // this fn overrides

  /**
   * function to return dataset type applicable for this chart
   * @param   {string}  name  dataset type
   * @return  {string}        dataset type applicable for this chart
   */
  ;

  MSSplineDy.prototype.getDSType = function getDSType() {
    return 'spline';
  };

  return MSSplineDy;
}(_fusioncharts3['default']);

exports['default'] = MSSplineDy;

/***/ }),

/***/ 820:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(371);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _fusioncharts3 = __webpack_require__(17);

var _mssplinearea = __webpack_require__(94);

var _mssplinearea2 = _interopRequireDefault(_mssplinearea);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var MSSplineArea = function (_MSSpline) {
  _inherits(MSSplineArea, _MSSpline);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSSplineArea.getName = function getName() {
    return 'MSSplineArea';
  };

  function MSSplineArea() {
    _classCallCheck(this, MSSplineArea);

    var _this = _possibleConstructorReturn(this, _MSSpline.call(this));

    _this.friendlyName = 'Multi-series Spline Area Chart';

    _this.defaultPlotShadow = 0;
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  MSSplineArea.prototype.getName = function getName() {
    return 'MSSplineArea';
  };
  /**
   * parse defualt configuration of the chart
   */


  MSSplineArea.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSSpline.prototype.__setDefaultConfig && _MSSpline.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    _fusioncharts3._setDefaultConfig.call(this);
    config.defaultDatasetType = 'mssplinearea';
    config.minimizetendency = 0;
    config.zeroplanethickness = 2;
    config.zeroplanealpha = 80;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
    config.defaultcrosslinethickness = 1;
  };

  MSSplineArea.prototype.getDSdef = function getDSdef() {
    return _mssplinearea2['default'];
  };

  MSSplineArea.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  return MSSplineArea;
}(_fusioncharts2['default']);

exports['default'] = MSSplineArea;

/***/ }),

/***/ 821:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(131);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _mlpieDataset = __webpack_require__(822);

var _mlpieDataset2 = _interopRequireDefault(_mlpieDataset);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var MultilevelPie = function (_CommonAPI) {
  _inherits(MultilevelPie, _CommonAPI);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MultilevelPie.getName = function getName() {
    return 'MultilevelPie';
  };

  function MultilevelPie() {
    _classCallCheck(this, MultilevelPie);

    var _this = _possibleConstructorReturn(this, _CommonAPI.call(this));

    _this.defaultPaletteOptions = null;
    _this.registerFactory('dataset', _mlpieDataset2['default'], ['canvas']);
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  MultilevelPie.prototype.getName = function getName() {
    return 'MultilevelPie';
  };
  /**
   * parse defualt configuration of the chart
   */


  MultilevelPie.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _CommonAPI.prototype.__setDefaultConfig && _CommonAPI.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.is3D = false;
    config.friendlyName = 'Multi-level Pie Chart';
    config.hasLegend = false;
    config.defaultDatasetType = 'multiLevelPie';
    config.valuefontbold = 0;
    config.skipCanvasDrawing = true;
  };
  /**
   * function to check if the chart specific data is proper is not
   * this fn is define for specific chart types
   * @return {boolean} if JSON data is valid or not
   */
  // eslint-disable-next-line


  MultilevelPie.prototype._checkInvalidSpecificData = function _checkInvalidSpecificData() {
    // this fn will override
  };

  MultilevelPie.prototype._spaceManager = function _spaceManager() {
    var availableHeight,
        iapi = this,
        config = iapi.config;
    //* ***** Manage space
    iapi._allocateSpace(iapi._manageActionBarSpace && iapi._manageActionBarSpace(config.availableHeight * 0.225) || {});
    availableHeight = config.canvasHeight * 0.7;
    // a space manager that manages the space for the tools as well as the captions.
    iapi._manageChartMenuBar(availableHeight);
  };

  return MultilevelPie;
}(_fusioncharts2['default']);

exports['default'] = MultilevelPie;

/***/ }),

/***/ 822:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var jsonData = chart.getFromEnv('dataSource'),
      categories = void 0,
      catLength = void 0,
      length = void 0,
      datasetJSON = {};

  categories = chart.config.categories = jsonData.category || [];
  catLength = categories.length;

  if (!length && catLength) {
    datasetJSON = categories;
    length = catLength;
  }
  // if the data has no categories in them.
  if (!catLength) {
    chart.setChartMessage();
    return;
  }
  (0, _lib.datasetFactory)(chart, _multilevelpie2['default'], 'dataset', length, [datasetJSON]);
};

var _lib = __webpack_require__(5);

var _multilevelpie = __webpack_require__(823);

var _multilevelpie2 = _interopRequireDefault(_multilevelpie);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 823:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _pie2d = __webpack_require__(108);

var _pie2d2 = _interopRequireDefault(_pie2d);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _multilevelpieAnimation = __webpack_require__(824);

var _multilevelpieAnimation2 = _interopRequireDefault(_multilevelpieAnimation);

var _schedular = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var convertColor = _lib.graphics.convertColor,
    BLANK = '',
    NORMALSTRING = 'normal',
    COLOR_FFFFFF = 'FFFFFF',
    COLOR_000000 = '000000',
    pInt = function pInt(s, mag) {
  return parseInt(s, mag || 10);
},
    DASH_DEF = 'none',
    UNDEF = void 0,
    ROLLOVER = 'DataPlotRollOver',
    ROLLOUT = 'DataPlotRollOut',
    POINTER = 'pointer',
    EVENTARGS = 'eventArgs',
    PX = 'px',
    INNERRADIUS = /^[0-9]+\%?$|^([0-9]+[.][0-9]+)\%?$/,
    calculateInnerRadius = function calculateInnerRadius(innerRadius, pieRadius) {
  var innerRadiusLength = innerRadius && innerRadius.length,
      calculatedInnerRadius = void 0;
  if (!innerRadius) {
    return 0;
  }
  if (innerRadius.charAt(innerRadiusLength - 1) === '%') {
    // execute when innerRadius is given as percentage
    calculatedInnerRadius = (0, _lib.pluckNumber)(pieRadius) * ((0, _lib.pluckNumber)(innerRadius.split('%')[0]) / 100);
  } else {
    // execute when innerRadius is given in pixels.
    calculatedInnerRadius = (0, _lib.pluckNumber)(innerRadius);
  }

  if (calculatedInnerRadius < pieRadius) {
    return calculatedInnerRadius;
  } else return 0;
};
(0, _dependencyManager.addDep)({
  name: 'multilevelpieAnimation',
  type: 'animationRule',
  extension: _multilevelpieAnimation2['default']
});

var MultiLevelPieDataset = function (_Pie2DDataset) {
  _inherits(MultiLevelPieDataset, _Pie2DDataset);

  function MultiLevelPieDataset() {
    _classCallCheck(this, MultiLevelPieDataset);

    var _this = _possibleConstructorReturn(this, _Pie2DDataset.call(this));

    _this.components = {
      data: []
    };
    _this.graphics = {};
    return _this;
  }
  /**
   * Sets the type of the component
   * @return {string} type
   */


  MultiLevelPieDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  MultiLevelPieDataset.prototype.getName = function getName() {
    return 'multiLevelPie';
  };

  MultiLevelPieDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.config.JSONData = datasetJSON;
    var fontBdrColor,
        dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        dataSetConfig = dataSet.config || (dataSet.config = {}),
        dataLabels = dataSetConfig.dataLabelOptions || (dataSetConfig.dataLabelOptions = {}),
        piePlotOptions = dataSetConfig.piePlotOptions,
        style = chart.config.style,
        jsonData = dataSet.config.JSONData,
        chartAttrs = chart.getFromEnv('dataSource').chart,
        enableAnimation = dataSetConfig.enableAnimation = (0, _lib.pluckNumber)(chartAttrs.animation, chartAttrs.defaultanimation, 1),
        centerAngle = (0, _lib.pluckNumber)(-chartAttrs.centerangle, 180),
        totalAngle = (0, _lib.pluckNumber)(chartAttrs.totalangle, 360),
        tranverseToRoot = function tranverseToRoot(dataObj, evtType) {
      var pointObj = this.data('plotItem');
      while (dataObj.graphics.element) {
        dataObj.graphics.element.attr({
          fill: evtType === 'mouseover' ? dataSetConfig.hoverFillColor : (dataObj.config || pointObj).color
        });
        dataObj = dataObj.config.parent;
      }
    },
        traverseAllChildren = function traverseAllChildren(dataObj, evtType) {
      var k,
          pointObj = this.data('plotItem');
      dataObj.graphics.element.attr({
        fill: evtType === 'mouseover' ? dataSetConfig.hoverFillColor : (dataObj.config || pointObj).color
      });
      for (k = 0; k < (dataObj.components.data && dataObj.components.data.length); k++) {
        traverseAllChildren.call(this, dataObj.components.data[k], evtType);
      }
    },
        mouseEvtHandler = function mouseEvtHandler(evtType) {
      if (!dataSetConfig.useHoverColor) {
        return;
      }
      var point = this.data('plotItem'),
          selfRef = point.selfRef;

      if (!dataSetConfig.highlightParentPieSlices && !dataSetConfig.highlightChildPieSlices) {
        selfRef.graphics.element.attr({
          fill: evtType === 'mouseover' ? dataSetConfig.hoverFillColor : (selfRef.config || point).color
        });
      } else if (!dataSetConfig.highlightParentPieSlices && dataSetConfig.highlightChildPieSlices) {
        traverseAllChildren.call(this, selfRef, evtType);
      } else if (dataSetConfig.highlightParentPieSlices && !dataSetConfig.highlightChildPieSlices) {
        tranverseToRoot.call(this, selfRef, evtType);
      } else if (dataSetConfig.highlightParentPieSlices && dataSetConfig.highlightChildPieSlices) {
        tranverseToRoot.call(this, selfRef, evtType);
        traverseAllChildren.call(this, selfRef, evtType);
      }
    };

    dataSetConfig.animation = !enableAnimation ? false : {
      duration: (0, _lib.pluckNumber)(chartAttrs.animationduration, chartAttrs.moveduration, 1) * 1000
    };
    dataSetConfig.showShadow = (0, _lib.pluckNumber)(chartAttrs.showshadow, 0);
    dataSetConfig.useHoverColor = Boolean((0, _lib.pluckNumber)(chartAttrs.usehovercolor, 1));
    dataSetConfig.hoverFillColor = convertColor((0, _lib.pluck)(chartAttrs.hoverfillcolor, 'FF5904'), (0, _lib.pluckNumber)(chartAttrs.hoverfillalpha, 100));
    fontBdrColor = (0, _lib.getFirstValue)(chartAttrs.valuebordercolor, BLANK);
    fontBdrColor = fontBdrColor ? convertColor(fontBdrColor, (0, _lib.pluckNumber)(chartAttrs.valueborderalpha, chartAttrs.valuebgalpha, chartAttrs.valuealpha, 100)) : BLANK;
    // create the style object if required.
    // fix for multilevel pie datavalue cosmetics issue RED-1594
    !dataLabels.style && (dataLabels.style = {
      fontFamily: (0, _lib.pluck)(chartAttrs.valuefont, style.fontFamily),
      fontSize: (0, _lib.pluckNumber)(chartAttrs.valuefontsize, pInt(style.fontSize, 10)) + PX,
      color: convertColor((0, _lib.pluck)(chartAttrs.valuefontcolor, style.color), (0, _lib.pluckNumber)(chartAttrs.valuefontalpha, chartAttrs.valuealpha, 100)),
      fontWeight: (0, _lib.pluckNumber)(chartAttrs.valuefontbold) ? 'bold' : NORMALSTRING,
      fontStyle: (0, _lib.pluckNumber)(chartAttrs.valuefontitalic) ? 'italic' : NORMALSTRING,
      backgroundColor: chartAttrs.valuebgcolor ? convertColor(chartAttrs.valuebgcolor, (0, _lib.pluckNumber)(chartAttrs.valuebgalpha, chartAttrs.valuealpha, 100)) : BLANK,
      border: fontBdrColor || chartAttrs.valuebgcolor ? (0, _lib.pluckNumber)(chartAttrs.valueborderthickness, 1) + 'px solid' : BLANK,
      borderPadding: (0, _lib.pluckNumber)(chartAttrs.valueborderpadding, 2),
      borderThickness: (0, _lib.pluckNumber)(chartAttrs.valueborderthickness, style.borderThickness, 1),
      borderRadius: (0, _lib.pluckNumber)(chartAttrs.valueborderradius, style.borderRadius, 0),
      borderColor: fontBdrColor,
      borderDash: (0, _lib.pluckNumber)(chartAttrs.valueborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(chartAttrs.valueborderdashlen, 4), (0, _lib.pluckNumber)(chartAttrs.valueborderdashgap, 2)) : DASH_DEF
    });

    // stop point slicing
    !piePlotOptions && (piePlotOptions = dataSetConfig.piePlotOptions = {});
    piePlotOptions.allowPointSelect = false;

    dataSetConfig.borderColor = convertColor((0, _lib.pluck)(chartAttrs.plotbordercolor, chartAttrs.piebordercolor, COLOR_FFFFFF), chartAttrs.showplotborder != _lib.ZEROSTRING ? (0, _lib.pluck)(chartAttrs.plotborderalpha, chartAttrs.pieborderalpha, 100) : 0);
    dataSetConfig.showTooltip = (0, _lib.pluckNumber)(chartAttrs.showtooltip, 1);

    dataSetConfig.borderWidth = (0, _lib.pluckNumber)(chartAttrs.pieborderthickness, chartAttrs.plotborderthickness, 1);

    piePlotOptions.startingAngle = 0; // set the chart's startingAngle as 0 [alwase]
    piePlotOptions.size = '100%';

    dataSetConfig.highlightParentPieSlices = (0, _lib.pluckNumber)(chartAttrs.highlightparentpieslices, chartAttrs.highlightparentpienodes, 1);
    dataSetConfig.highlightChildPieSlices = (0, _lib.pluckNumber)(chartAttrs.highlightchildpieslices, chartAttrs.highlightchildpienodes, 0);

    dataSetConfig.showLabels = (0, _lib.pluckNumber)(chartAttrs.showlabels, 1);
    dataSetConfig.showValues = (0, _lib.pluckNumber)(chartAttrs.showvalues, 0);
    dataSetConfig.showValuesInTooltip = (0, _lib.pluckNumber)(chartAttrs.showvaluesintooltip, chartAttrs.showvalues, 0);
    dataSetConfig.showPercentValues = (0, _lib.pluckNumber)(chartAttrs.showpercentvalues, chartAttrs.showpercentagevalues, 0);
    dataSetConfig.showPercentInTooltip = (0, _lib.pluckNumber)(chartAttrs.showpercentintooltip, 0);
    dataSetConfig.toolTipSepChar = (0, _lib.pluck)(chartAttrs.tooltipsepchar, chartAttrs.hovercapsepchar, _lib.COMMASPACE);
    dataSetConfig.labelSepChar = (0, _lib.pluck)(chartAttrs.labelsepchar, dataSetConfig.toolTipSepChar);
    dataSetConfig.tooltext = chartAttrs.plottooltext;
    dataSetConfig.alpha = (0, _lib.pluck)(chartAttrs.plotfillalpha, chartAttrs.piefillalpha, 100);
    dataSetConfig.startAngle = (centerAngle - totalAngle / 2) * (Math.PI / 180);
    dataSetConfig.endtAngle = (centerAngle + totalAngle / 2) * (Math.PI / 180);
    dataSetConfig.initialAngle = dataSetConfig.endtAngle;
    dataSetConfig.originX = (0, _lib.pluckNumber)(chartAttrs.originx);
    dataSetConfig.originY = (0, _lib.pluckNumber)(chartAttrs.originy);

    dataSetConfig.events = {
      mouseOver: function mouseOver() {
        mouseEvtHandler.call(this, 'mouseover');
      },
      mouseOut: function mouseOut() {
        mouseEvtHandler.call(this, 'mouseout');
      }
    };

    // remove the plotboder
    chartConfig.plotBorderWidth = 0;

    // remove the plotboder
    chartConfig.plotBorderWidth = 0;
    dataSetConfig.maxLevel = dataSet.addMSPieCat(jsonData, 1, dataSet, dataSetConfig.startAngle, dataSetConfig.endtAngle);
    dataSetConfig.pieRadius = parseInt(chartAttrs.pieradius, 10);

    // dataSetConfig.innerRadius = pluckNumber(Number(pluck(chartAttrs.innerradius, '0%').split('%')[0]), 0);
    dataSetConfig.innerRadius = '0';
    INNERRADIUS.test(chartAttrs.innerradius) && (dataSetConfig.innerRadius = (0, _lib.pluck)(chartAttrs.innerradius));

    dataLabels.distance = 0;
    dataLabels.placeLabelsInside = true;
  };
  // doHide is a Boolean Flag to hide the element or not.
  // All the graphical elements in excess are pushed to the graphics pool. They are hidden only after the
  // entire draw is complete.


  MultiLevelPieDataset.prototype.removalFn = function removalFn(ele, prop) {
    var dataSet = this,
        animationManager = dataSet.getFromEnv('animationManager'),
        hideFN = function hideFN() {
      this.remove();
    };

    animationManager.setAnimation({
      el: ele,
      label: prop === 'element' ? 'ringpath' : 'label',
      component: dataSet,
      callback: hideFN
    });
  };

  MultiLevelPieDataset.prototype.removeGraphics = function removeGraphics(obj) {
    var i,
        prop,
        dataSet = this,
        childData = obj.components && obj.components.data,
        len,
        graphics = obj.graphics;
    if (childData) {
      len = childData.length;
      for (i = 0; i < len; i += 1) {
        dataSet.removeGraphics(childData[i]);
      }
    }

    if (obj.graphics) {
      for (prop in graphics) {
        if (graphics.hasOwnProperty(prop)) {
          dataSet.removalFn(obj.graphics[prop], prop);
        }
      }
    }
  };

  MultiLevelPieDataset.prototype.removeChild = function removeChild(removalStore, doHide, type) {
    var i,
        elemObj,
        dataSet = this;
    if (removalStore.length) {
      for (i = 0; i < removalStore.length; i += 1) {
        elemObj = removalStore[i];
        if (type) {
          dataSet.removalFn(elemObj, doHide, type);
        } else {
          dataSet.removeGraphics(elemObj, doHide);
        }
      }
    } else {
      // if the removalStore is in the Object structure.
      for (i in removalStore) {
        dataSet.removeChild(removalStore[i], doHide, i);
      }
    }
  };

  MultiLevelPieDataset.prototype.addMSPieCat = function addMSPieCat(catArr, level, parentObj, startAngle, endAngle) {
    var dataObj,
        dataObjLen,
        cat = (0, _lib.extend2)([], catArr),
        catObjLen,
        catLen = cat.length,
        dataSet = this,
        data = parentObj.components.data,
        dataSetConfig = dataSet.config,
        plotBorderThickness = dataSetConfig.borderWidth,
        plotBorderColor = dataSetConfig.borderColor,
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        colorM = dataSet.getFromEnv('color-manager'),
        sharePercent,
        totalValue = 0,
        catObj,
        catVal,
        i,
        label,
        labelSepChar = dataSetConfig.labelSepChar,
        fillalpha,
        valueStr,
        pValueStr,
        toolText,
        displayValue,
        maxLevel = level,
        dataLength = data.length,
        removalFn = function removalFn() {
      dataSet.removeChild.apply(dataSet, arguments);
    },
        catLength = cat.length,
        totAngle = endAngle - startAngle,
        tempAngle,
        cumilative = 0,
        preDataOldEndAngle;

    for (i = 0; i < catLen; i += 1) {
      // store for letter use
      catObj = cat[i];
      catObj._userValue = numberFormatter.getCleanValue(catObj.value, true);
      catObj._value = (0, _lib.pluckNumber)(catObj._userValue, 1);
      totalValue += catObj._value;
    }
    // Total value can't be zero, since its used in denominator to find ratio.
    totalValue = totalValue || 1;

    // add the category
    sharePercent = totAngle / totalValue;
    for (i = catLen - 1; i >= 0; i -= 1) {
      catObj = cat[i];
      catVal = sharePercent * catObj._value;
      label = (0, _lib.parseUnsafeString)((0, _lib.pluck)(catObj.label, catObj.name));
      valueStr = catObj._userValue !== null ? numberFormatter.dataLabels(catObj._userValue) : BLANK;
      pValueStr = numberFormatter.percentValue(catObj._value / totalValue * 100);
      // pointIndex = sLevel.length - 1;
      fillalpha = (0, _lib.pluckNumber)(catObj.alpha, dataSetConfig.alpha);
      displayValue = dataSetConfig.showLabels ? label : BLANK;
      if (dataSetConfig.showValues) {
        if (dataSetConfig.showPercentValues) {
          displayValue += displayValue !== BLANK ? labelSepChar + pValueStr : pValueStr;
        } else if (valueStr !== UNDEF && valueStr !== BLANK) {
          displayValue += displayValue !== BLANK ? labelSepChar + valueStr : valueStr;
        }
      }
      toolText = dataSetConfig.showTooltip ? (0, _lib.parseUnsafeString)((0, _lib.pluck)(catObj.tooltext, catObj.hovertext, dataSetConfig.tooltext)) : UNDEF;
      if (toolText === BLANK) {
        toolText = label;
        if (dataSetConfig.showValuesInTooltip) {
          if (dataSetConfig.showPercentInTooltip) {
            toolText += toolText !== BLANK ? labelSepChar + pValueStr : pValueStr;
          } else if (valueStr !== UNDEF && valueStr !== BLANK) {
            toolText += toolText !== BLANK ? labelSepChar + valueStr : valueStr;
          }
        }
      } else {
        toolText = (0, _lib.parseTooltext)(toolText, [1, 2, 3, 14], {
          percentValue: pValueStr,
          label: label,
          formattedValue: valueStr
        }, catObj);
      }

      dataObj = data[i];
      tempAngle = startAngle + cumilative;
      cumilative += catVal;
      if (!dataObj) {
        dataObj = data[i] = {
          components: {
            data: []
          },
          config: {},
          graphics: {}
        };
      }
      // store old end angle for newly added element's aimation position
      if (dataObj.graphics.element) {
        preDataOldEndAngle = dataObj.config.startAngle + dataObj.config.angleStrech;
      }
      dataObj.config = {
        initialAngle: preDataOldEndAngle || (parentObj.config || parentObj.config).initialAngle,
        startAngle: tempAngle,
        angleStrech: catVal,
        level: level,
        displayValue: displayValue,
        toolText: toolText,
        link: (0, _lib.getValidValue)(catObj.link),
        doNotSlice: true, // added to stop slicing
        color: convertColor(catObj.color || colorM.getPlotColor(), fillalpha),
        borderWidth: (0, _lib.pluckNumber)(catObj.borderwidth, plotBorderThickness),
        borderColor: (0, _lib.pluck)(catObj.bordercolor, plotBorderColor),
        dashStyle: (0, _lib.pluckNumber)(catObj.valueborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(catObj.borderdashlen, 4), (0, _lib.pluckNumber)(catObj.borderdashgap, 2)) : DASH_DEF,
        shadow: {
          opacity: Math.round(fillalpha > 50 ? fillalpha * fillalpha * fillalpha * 0.0001 : fillalpha * fillalpha * 0.01) * 0.01
        },
        isSingleTon: !(catLen > 1)
      };
      dataObj.config.parent = parentObj;

      if (catObj.category) {
        maxLevel = Math.max(maxLevel, dataSet.addMSPieCat(catObj.category, level + 1, dataObj, tempAngle, catVal + tempAngle));
        if ((dataObjLen = dataObj.components.data.length) > (catObjLen = catObj.category.length)) {
          removalFn(dataObj.components.data.splice(dataObjLen - 1, catObjLen));
        }
      } else {
        dataObjLen = dataObj.components.data.length;
        if (dataObjLen) {
          // no child category, recursively remove existing childs (dataObj.components.data)
          removalFn(dataObj.components.data.splice(0, dataObjLen));
        }
      }
    }
    // remove estra data
    if (dataLength > catLength) {
      // recursively remove elements with child
      removalFn(data.splice(catLength));
    }
    return maxLevel;
  };

  MultiLevelPieDataset.prototype.parsePlotAttributes = function parsePlotAttributes(parentObj) {
    var angle,
        _textAttrs,
        centerDistance,
        level,
        dataSet = this,
        dataSetConfig = dataSet.config || {},
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        dataSetComponents = dataSet.components,
        data = dataSetComponents.data,
        len = data.length,
        seriesDataLabelsStyle = chartConfig.dataLabelStyle,
        textDirection = chartConfig.textDirection,
        tooltipOptions = chartConfig.tooltip || {},
        isTooltip = tooltipOptions && tooltipOptions.enabled !== false,
        canvasWidth = chartConfig.canvasWidth,
        canvasHeight = chartConfig.canvasHeight,
        cx = (0, _lib.pluckNumber)(dataSetConfig.originX, chartConfig.canvasLeft + canvasWidth * 0.5),
        cy = (0, _lib.pluckNumber)(dataSetConfig.originY, chartConfig.canvasTop + canvasHeight * 0.5),
        r,
        r2,
        color,
        val,
        displayValue,
        setLink,
        angle1,
        angle2,
        i,
        setGraphics,
        setConfig,
        element,
        pieSize = (0, _lib.pluckNumber)(dataSetConfig.pieRadius * 2, Math.min(canvasWidth, canvasHeight)),

    // innerRadius in diameter of inner circle
    innerRadius = calculateInnerRadius(dataSetConfig.innerRadius, pieSize / 2),
        pool = dataSet.config.pool || (dataSet.config.pool = {}),

    // either the user-specified size is chosen or the minimum aspect dimension is choosen
    // pieSize is diameter of full pie
    seriesHalfWidth = (pieSize - 2 * innerRadius) / (2 * dataSetConfig.maxLevel);
    dataSetConfig.innerSize = innerRadius * 2;

    if (!parentObj) {
      parentObj = dataSet;
    }
    len = parentObj.components.data.length;
    for (i = 0; i < len; i += 1) {
      dataSet.parsePlotAttributes(parentObj.components.data[i]);
    }
    setConfig = parentObj.config;
    level = setConfig.level;
    if (level) {
      r = level * seriesHalfWidth + innerRadius;
      r2 = (level - 1) * seriesHalfWidth + innerRadius;

      setGraphics = parentObj.graphics;
      val = setConfig.angleStrech;
      displayValue = setConfig.displayValue;
      // toolText = setConfig.toolText;
      setLink = !!setConfig.link;
      color = setConfig.color;

      angle1 = setConfig.startAngle;
      angle2 = angle1 + setConfig.angleStrech;
      element = setGraphics.element;
      if (pool.element && pool.element.length) {
        element = setGraphics.element = element || pool.element.shift();
      }
      setConfig.plotItem = {
        chart: chart,
        link: setConfig.link,
        value: val,
        color: color,
        labelText: displayValue,
        graphics: {
          element: element
        },
        selfRef: parentObj
      };

      setConfig.eventArgs = {
        link: setConfig.link,
        label: setConfig.displayValue,
        toolText: setConfig.toolText
      };

      setConfig.props = {
        element: {
          attr: {
            ringpath: [cx, cy, r, r2, angle1, angle2],
            'stroke-width': setConfig.borderWidth,
            'stroke': setConfig.borderColor,
            fill: (0, _lib.toRaphaelColor)(setConfig.color),
            'stroke-dasharray': setConfig.dashStyle,
            // In case of tooltip disabled this element should act as the hot element.
            ishot: !isTooltip,
            cursor: setLink ? POINTER : _lib.BLANKSTRING
          }
        }
      };
      if (displayValue !== UNDEF && displayValue !== _lib.BLANKSTRING) {
        angle = (angle1 + angle2) / 2;
        // for the innermost Concentric circle the center distance is presumed to be zero
        centerDistance = r2 === 0 && setConfig.isSingleTon ? 0 : r2 + (r - r2) / 2;
        if (!(_textAttrs = setConfig._textAttrs)) {
          _textAttrs = setConfig._textAttrs = {};
        }

        _textAttrs.text = displayValue;
        _textAttrs.fill = seriesDataLabelsStyle.color || COLOR_000000;
        _textAttrs.direction = textDirection;
        _textAttrs.ishot = setLink;
        _textAttrs.cursor = setLink ? POINTER : _lib.BLANKSTRING;
        _textAttrs.x = cx + centerDistance * Math.cos(angle);
        _textAttrs.y = cy + centerDistance * Math.sin(angle);
        _textAttrs['text-bound'] = [seriesDataLabelsStyle.backgroundColor, seriesDataLabelsStyle.borderColor, seriesDataLabelsStyle.borderThickness, seriesDataLabelsStyle.borderPadding, seriesDataLabelsStyle.borderRadius, seriesDataLabelsStyle.borderDash];
      }
    }
  };

  /**
   * Parses label attributes and position during post space management
   *
   * @param {any} parentObj
   * @memberof MultiLevelPieDataset
   */


  MultiLevelPieDataset.prototype.parseLabelAttributes = function parseLabelAttributes(parentObj) {
    var _textAttrs,
        level,
        dataSet = this,
        dataSetComponents = dataSet.components,
        data = dataSetComponents.data,
        len = data.length,
        displayValue,
        i,
        setConfig;

    // dataLabelsLayer.show();
    !parentObj && (parentObj = dataSet);
    len = parentObj.components.data.length;
    for (i = 0; i < len; i += 1) {
      dataSet.parseLabelAttributes(parentObj.components.data[i]);
    }
    setConfig = parentObj.config;
    // plotItem = setConfig.plotItem;
    displayValue = setConfig.displayValue;
    _textAttrs = setConfig._textAttrs;
    level = setConfig.level;
    if (level) {
      if (displayValue !== UNDEF && displayValue !== _lib.BLANKSTRING) {
        setConfig.props.label = {
          attr: _textAttrs
        };
      }
    }
  };

  MultiLevelPieDataset.prototype.draw = function draw(parentObj) {
    var level,
        dataSet = this,
        dataSetConfig = dataSet.config || {},
        chart = dataSet.getFromEnv('chart'),
        animationManager = dataSet.getFromEnv('animationManager'),
        toolTipController = dataSet.getFromEnv('toolTipController'),
        chartConfig = chart.config,
        dataSetComponents = dataSet.components,
        data = dataSetComponents.data,
        len = data.length,
        seriesDataLabelsStyle = chartConfig.dataLabelStyle,
        seriesShadow = dataSetConfig.showShadow,
        i,
        datasetLayer = chart.getChildContainer('plotGroup').trackTooltip(true),
        setGraphics,
        setConfig,
        element,
        dataLabelsLayer = chart.getChildContainer('datalabelsGroup'),
        events = dataSetConfig.events || {},
        plotHoverFN = function plotHoverFN(e) {
      var o = this,
          mouseOver = events.mouseOver,
          plotItem = o.plotItem || o.data('plotItem'),
          chart = plotItem.chart,
          dataset = chart.getDatasets()[0];
      _lib.plotEventHandler.call(o, chart, e, ROLLOVER);
      mouseOver && mouseOver.call(o);
      dataset.fireEvent('datasetrollover', { pValue: plotItem.pValue, value: plotItem.value, displayValue: setConfig.displayValue });
    },
        plotMouseOut = function plotMouseOut(e) {
      var o = this,
          mouseOut = events.mouseOut,
          plotItem = o.plotItem || o.data('plotItem'),
          chart = plotItem.chart,
          dataset = chart.getDatasets()[0];
      _lib.plotEventHandler.call(o, chart, e, ROLLOUT);
      mouseOut && mouseOut.call(o);
      dataset.fireEvent('datasetrollout', { pValue: plotItem.pValue, value: plotItem.value, displayValue: setConfig.displayValue });
    },

    // Fired when clicked over the hot elements.
    clickFunc = function clickFunc(setDataArr) {
      var ele = this;
      _lib.plotEventHandler.call(ele, chart, setDataArr);
    },
        pool = dataSet.config.pool || (dataSet.config.pool = {}),
        removeDataArr = dataSetComponents.removeDataArr,
        removeDataArrLen = removeDataArr && removeDataArr.length;
    // dataSetConfig.innerSize = innerRadius * 2;

    removeDataArrLen && dataSet.removeElement();
    if (!parentObj) {
      parentObj = dataSet;
      dataLabelsLayer.css(seriesDataLabelsStyle);
    }
    len = parentObj.components.data.length;
    for (i = 0; i < len; i += 1) {
      dataSet.draw(parentObj.components.data[i]);
    }
    setConfig = parentObj.config;
    level = setConfig.level;
    if (level) {
      setGraphics = parentObj.graphics;
      element = setGraphics.element;
      if (pool.element && pool.element.length) {
        element = setGraphics.element = element || pool.element.shift();
      }
      // Create/reuse element
      element = setGraphics.element = animationManager.setAnimation({
        el: setGraphics.element || 'ringpath',
        attr: setConfig.props.element.attr,
        container: datasetLayer,
        component: dataSet,
        state: 'appearing',
        dom: 'ringpath'
      });

      element.shadow(seriesShadow && !!setConfig.shadow).data('plotItem', setConfig.plotItem).data(EVENTARGS, setConfig.eventArgs).mouseover(plotHoverFN).mouseout(plotMouseOut).mouseup(clickFunc);
      toolTipController.enableToolTip(element, setConfig.toolText);

      if (!i && !dataSetConfig._drawn) {
        dataSetConfig._drawn = true;
        dataLabelsLayer.show();
        dataSet.addJob('labelJob', dataSet.drawLabel.bind(dataSet), _schedular.priorityList.label);
      }
    } else {
      // If the chart is already drawn, then instead of sheduling the label drawing, directly draw the
      // labels.
      dataSetConfig._drawn && dataSet.drawLabel();
      // at the end of all the tree structure, hide all the pool elements.
      dataSet.removeChild(dataSet.config.pool, true);
    }
  };

  MultiLevelPieDataset.prototype.drawLabel = function drawLabel(parentObj) {
    var level,
        dataSet = this,
        dataSetConfig = dataSet.config || {},
        chart = dataSet.getFromEnv('chart'),
        animationManager = dataSet.getFromEnv('animationManager'),
        chartConfig = chart.config,
        dataSetComponents = dataSet.components,
        data = dataSetComponents.data,
        len = data.length,
        seriesDataLabelsStyle = chartConfig.dataLabelStyle,
        toolTipController = dataSet.getFromEnv('toolTipController'),
        tooltipOptions = chartConfig.tooltip || {},
        isTooltip = tooltipOptions && tooltipOptions.enabled !== false,
        toolText,
        plotItem,
        displayValue,
        i,
        setGraphics,
        setConfig,
        label,
        events = dataSetConfig.events || {},
        labelHoverFN = function labelHoverFN(e) {
      var o = this,
          mouseOver = events.mouseOver;
      _lib.plotEventHandler.call(o, chart, e, ROLLOVER);
      mouseOver && mouseOver.call(o);
    },
        labelOutFN = function labelOutFN(e) {
      var o = this,
          mouseOut = events.mouseOut;
      _lib.plotEventHandler.call(o, chart, e, ROLLOUT);
      mouseOut && mouseOut.call(o);
    },

    // Fired when clicked over the hot elements.
    clickFunc = function clickFunc(setDataArr) {
      var ele = this;
      _lib.plotEventHandler.call(ele, chart, setDataArr);
    },
        pool = dataSet.config.pool || (dataSet.config.pool = {}),
        dataLabelsLayer = chart.getChildContainer('datalabelsGroup');

    dataLabelsLayer.show();
    !parentObj && (parentObj = dataSet);
    len = parentObj.components.data.length;
    for (i = 0; i < len; i += 1) {
      dataSet.drawLabel(parentObj.components.data[i]);
    }
    setConfig = parentObj.config;
    plotItem = setConfig.plotItem;
    displayValue = setConfig.displayValue;
    level = setConfig.level;
    if (level) {
      setGraphics = parentObj.graphics;
      label = setGraphics.label;
      if (displayValue !== UNDEF && displayValue !== _lib.BLANKSTRING) {
        label = setGraphics.label;
        if (pool.label && pool.label.length) {
          label = setGraphics.label = label || pool.label.shift();
        }

        // Create/Reuse label
        label = setGraphics.label = animationManager.setAnimation({
          el: label || 'text',
          attr: setConfig.props.label.attr,
          container: dataLabelsLayer,
          component: dataSet,
          state: 'appearing',
          dom: 'text'
        });

        label.mouseup(clickFunc).mouseout(labelOutFN).mouseover(labelHoverFN).css(seriesDataLabelsStyle).show().data('plotItem', plotItem).data(EVENTARGS, setConfig.eventArgs);

        isTooltip && toolTipController.enableToolTip(label, toolText);
      } else {
        // In case of extra labels, hide them
        label && animationManager.setAnimation({
          el: label,
          component: dataSet,
          callback: function callback() {
            this.hide();
          },
          dom: 'text'
        });
      }
    } else {
      // at the end of all the tree structure, hide all the pool elements.
      dataSet.removeChild(dataSet.config.pool, true);
    }
  };

  return MultiLevelPieDataset;
}(_pie2d2['default']);

exports['default'] = MultiLevelPieDataset;

/***/ }),

/***/ 824:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.multiLevelPie': function initialDatasetMultiLevelPie() {
    var datasetConf = this.config,
        ringpath = void 0;
    return {
      'ringpath.appearing': function ringpathAppearing(inputJSON) {
        ringpath = inputJSON.attr.ringpath;
        return [{
          initialAttr: {
            ringpath: [ringpath[0], ringpath[1], ringpath[2], ringpath[3], datasetConf.initialAngle, datasetConf.initialAngle]
          },
          slot: 'plot'
        }];
      },
      'text.appearing': function textAppearing() {
        return [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          slot: 'final'
        }];
      }
    };
  }
};

/***/ }),

/***/ 825:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(372);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _kagi = __webpack_require__(828);

var _kagi2 = _interopRequireDefault(_kagi);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF = void 0,
    HUNDREDSTRING = '100',
    SEVENTYSTRING = '70';

var Kagi = function (_WaterFall2D) {
  _inherits(Kagi, _WaterFall2D);

  function Kagi() {
    _classCallCheck(this, Kagi);

    return _possibleConstructorReturn(this, _WaterFall2D.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  Kagi.getName = function getName() {
    return 'Kagi';
  };

  /**
   * Sets the name of the component
   * @return {string} name
   */


  Kagi.prototype.getName = function getName() {
    return 'Kagi';
  };

  Kagi.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _WaterFall2D.prototype.__setDefaultConfig && _WaterFall2D.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.friendlyName = 'Kagi Chart';
    config.singleseries = true;
    config.hasLegend = false;
    config.defaultDatasetType = 'kagi';
    config.setAdaptiveMin = true;
    config.anchorborderthickness = 1;
    config.anchorimageurl = UNDEF;
    config.anchorimagepadding = 1;
    config.anchorsides = 1;
    config.anchoralpha = UNDEF;
    config.anchorbgalpha = HUNDREDSTRING;
    config.anchorimagealpha = HUNDREDSTRING;
    config.anchorimagescale = 100;
    config.anchorstartangle = 90;
    config.anchorshadow = 0;
    config.anchorbgcolor = UNDEF;
    config.anchorbordercolor = UNDEF;
    config.anchorradius = 3;
    config.showvalues = 1;
    config.plotfillalpha = SEVENTYSTRING;
    config.linedashlen = 5;
    config.linedashgap = 4;
    config.linedashed = UNDEF;
    config.linealpha = HUNDREDSTRING;
    config.linethickness = 2;
    config.drawfullareaborder = 1;
    config.connectnulldata = 0;
    config.zeroplanethickness = 1;
    config.enablemousetracking = true;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
  };

  Kagi.prototype._getDataset = function _getDataset() {
    var iapi = this,
        dataSetArr = [];

    iapi.iterateComponents(function (child) {
      if (child.getType && child.getType() === 'dataset') {
        dataSetArr.push(child);
      }
    });
    return dataSetArr;
  };

  Kagi.prototype._postSpaceManagement = function _postSpaceManagement() {
    var iapi = this,
        config = iapi.config,
        xAxis = iapi.getChildren('xAxis')[0],
        yAxis = iapi.getChildren('yAxis')[0],
        canvas = iapi.getChildren('canvas')[0],
        canvasConfig = canvas.config,
        canvasBorderWidth = canvasConfig.canvasBorderWidth,
        canvasPadding = (0, _lib.pluckNumber)(canvasConfig.canvasPadding, 15),
        canvasPaddingTop = canvasConfig.canvasPaddingTop,
        canvasPaddingBottom = canvasConfig.canvasPaddingBottom,
        canvasPaddingLeft = canvasConfig.canvasPaddingLeft,
        canvasPaddingRight = canvasConfig.canvasPaddingRight,
        chartAttrs = iapi.getFromEnv('dataSource').chart,
        dataset = iapi._getDataset(),
        series = dataset[0].config,
        shiftCount = series && series.shiftCount,
        min = (0, _lib.pluckNumber)(xAxis.getAxisConfig('axisMinValue'), 0),
        max = (0, _lib.pluckNumber)(xAxis.getAxisConfig('axisMaxValue'), shiftCount - 1),
        canvasWidth = iapi.config.canvasWidth,

    // plot area will not be less then 10 px
    // leftPixelPad = mathMin(pluckNumber(chartAttrs.canvaspadding, 0), (canvasWidth / 2) - 10),
    // rightPixelPad = leftPixelPad,
    // The maximum horizontal shift in percentage of the
    // available canvas width
    maxHShiftPercent = (0, _lib.pluckNumber)(chartAttrs.maxhshiftpercent, 10),
        effectiveCanvasWidth = canvasWidth - canvasPadding * 2,
        xShiftLength;

    yAxis && yAxis.setAxisDimention({
      x: config.canvasLeft - canvasBorderWidth,
      y: config.canvasTop + canvasPaddingTop,
      opposite: config.canvasRight + canvasBorderWidth,
      axisLength: config.canvasHeight - canvasPaddingTop - canvasPaddingBottom
    });

    iapi._setPosition();
    if (series) {
      // maxHShiftPercent can not be < 0
      maxHShiftPercent = maxHShiftPercent <= 0 ? 10 : maxHShiftPercent;
      xShiftLength = series.xShiftLength = Math.min(effectiveCanvasWidth / shiftCount, maxHShiftPercent * effectiveCanvasWidth / 100);
      // leftPixelPad = canvasPadding + xShiftLength / 2;
      // canvasWidth - ((xShiftLength *
      // // handling single value rendering issue in Kagi
      // mathMax((shiftCount - 1), 1)) + leftPixelPad);
      // Fix for Kagi chart single value rendering issue
      // If there is a single value, we use xAxis max value
      // as 1 not as 0
      max = Math.max(max, 1);
    }

    // function for adjusting value padding depending upon data and axis labels.
    canvas.setCanvasPadding();
    xAxis && xAxis.setAxisConfig({
      'canvasPaddingLeft': Math.max(canvasPaddingLeft, canvasPadding) + xShiftLength / 2,
      'canvasPaddingRight': Math.max(canvasPaddingRight, canvasPadding) + xShiftLength / 2
    });
    xAxis && xAxis.setAxisDimention({
      x: iapi.config.canvasLeft + canvasPadding + xShiftLength / 2,
      axisLength: xShiftLength * (max - min),
      y: config.canvasBottom + (config.shift || 0) + canvasBorderWidth,
      opposite: config.canvasTop - canvasBorderWidth
    });
  };

  Kagi.prototype._setPosition = function _setPosition() {
    var i,
        point,
        yValue,
        isRally,
        lastHigh,
        lastLow,
        isRallyInitialised,
        lastPoint,
        iapi = this,
        dataObj = iapi.getFromEnv('dataSource'),
        dataSet = iapi._getDataset()[0],
        categories = dataObj.data || dataSet && dataSet[0] && dataSet[0].data,
        setDataArr = dataSet.components.data,
        dataSetLen = setDataArr && setDataArr.length,
        yAxis = iapi.getChildren('yAxis')[0],
        xValue = 0,
        plotX = xValue,
        catArr = [];
    // create plot elements
    for (i = 0; i < dataSetLen; i++) {
      point = setDataArr[i].config;
      yValue = point.setValue;

      dataObj = setDataArr[i];

      // Creating the data object if not created
      if (!dataObj) {
        dataObj = setDataArr[i] = {
          graphics: {}
        };
      }
      if (!point.isDefined) {
        yValue = point.plotValue;
      }

      // Getting appropiate value for the current plot point.
      yValue = (0, _lib.pluck)(point.plotValue, yValue);

      // Set the y position.
      point.plotY = (0, _lib.toPrecision)(yAxis.getPixel(point.setValue), 2);

      // Store value textbox y position.
      point.graphY = (0, _lib.toPrecision)(yAxis.getPixel(yValue), 2);

      // Abscissa of the point on the kagi line.
      point.plotX = plotX;
      // If there is a horizontal shift, then abscissa of the kagi
      // line and as such all points on it shifts to the right by a
      // slab more.
      if (point.isShift) {
        xValue += 1;
        plotX = xValue;
        categories && catArr.push(categories[i]);
      } else if (i === dataSetLen - 1) {
        categories && catArr.push(categories[i]);
      }

      if (i) {
        lastPoint = setDataArr[i - 1].config;

        // Getting the previously bundled up properties in local
        // variables.
        isRally = point && point.objParams && point.objParams.isRally;
        lastHigh = point && point.objParams && point.objParams.lastHigh;
        lastLow = point && point.objParams && point.objParams.lastLow;
        isRallyInitialised = point && point.objParams && point.objParams.isRallyInitialised;

        // To find if there is a change in trend towards the current
        // plot.
        if (lastPoint && isRallyInitialised && lastPoint.isRally !== point.isRally) {
          // Setting in this.data for the plot, to be used for.
          // Setting the color/thickness the graph segments.
          point.isChanged = true;

          // To get the pixel position of the transtion point and
          // storing in data point for the plot.
          point.ty = (0, _lib.toPrecision)(yAxis.getPixel(isRally ? lastHigh : lastLow), 2);
        } else {
          // Setting in this.data for the plot.
          point.isChanged = false;
        }
      }
    }
    // end of previous translation
  };

  Kagi.prototype.getDSdef = function getDSdef() {
    return _kagi2['default'];
  };

  return Kagi;
}(_fusioncharts2['default']);

exports['default'] = Kagi;

/***/ }),

/***/ 826:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _dependencyManager = __webpack_require__(6);

var _waterFall2DAnimation = __webpack_require__(827);

var _waterFall2DAnimation2 = _interopRequireDefault(_waterFall2DAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var HUNDREDSTRING = '100',
    PLOTBORDERCOLOR = 'plotBorderColor',
    PLOTGRADIENTCOLOR = 'plotGradientColor',
    COMMA = ',',
    BLANK = '',
    SHOWSHADOW = 'showShadow',
    NONE = 'none',
    convertColor = _lib.graphics.convertColor,
    getColumnColor = _lib.graphics.getColumnColor,
    getLightColor = _lib.graphics.getLightColor,
    MAX_MITER_LINEJOIN = 2,
    M = 'M',
    H = 'H',
    UNDEF = void 0;
(0, _dependencyManager.addDep)({
  name: 'waterFall2DAnimation',
  type: 'animationRule',
  extension: _waterFall2DAnimation2['default']
});

var WaterFall2DDataset = function (_ColumnDataset) {
  _inherits(WaterFall2DDataset, _ColumnDataset);

  function WaterFall2DDataset() {
    _classCallCheck(this, WaterFall2DDataset);

    return _possibleConstructorReturn(this, _ColumnDataset.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  WaterFall2DDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  WaterFall2DDataset.prototype.getName = function getName() {
    return 'waterFall2D';
  };

  WaterFall2DDataset.prototype.configure = function configure(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.config.JSONData = datasetJSON;
    var catData,
        catObj,
        dataSet = this,
        chart = dataSet.getFromEnv('chart'),

    // logic = chart.logic,
    conf = dataSet.config,

    // fcJSON = dataSet.fcJSON,
    JSONData = dataSet.config.JSONData,
        setDataArr = JSONData.data,
        setDataLen = setDataArr && setDataArr.length,
        xAxis = dataSet.getFromEnv('xAxis'),
        catLen = xAxis.getTicksLen(),
        len = Math.min(catLen, setDataLen),
        chartJSON = chart.getFromEnv('dataSource'),
        chartAttr = chartJSON.chart,
        colorM = dataSet.getFromEnv('color-manager'),
        index = dataSet.index || dataSet.positionIndex,
        showplotborder,
        plotColor = colorM.getPlotColor(index),
        plotBorderDash = (0, _lib.pluckNumber)(JSONData.dashed, chartAttr.plotborderdashed),
        usePlotGradientColor = (0, _lib.pluckNumber)(chartAttr.useplotgradientcolor, 1),
        showTooltip = (0, _lib.pluckNumber)(chartAttr.showtooltip, 1),
        yAxisName = (0, _lib.parseUnsafeString)(chartAttr.yaxisname),
        xAxisName = (0, _lib.parseUnsafeString)(chartAttr.xaxisname),
        tooltipSepChar = (0, _lib.parseUnsafeString)((0, _lib.pluck)(chartAttr.tooltipsepchar, ', ')),
        formatedVal,
        parserConfig,
        setTooltext,

    // seriesname,
    macroIndices,

    // tempPlotfillAngle,
    toolText,
        plotDashLen,
        plotDashGap,
        plotBorderThickness,
        isRoundEdges,
        showHoverEffect,
        plotfillAngle,
        plotFillAlpha,
        plotFillRatio,
        plotgradientcolor,
        plotBorderAlpha,
        plotBorderColor,
        plotBorderDashStyle,
        initailPlotBorderDashStyle,
        setData,
        setValue,
        dataObj,
        config,

    // label,
    colorArr,
        hoverColor,
        hoverAlpha,
        hoverGradientColor,
        hoverRatio,
        hoverAngle,
        hoverBorderColor,
        hoverBorderAlpha,
        hoverBorderThickness,
        hoverBorderDashed,
        hoverBorderDashGap,
        hoverBorderDashLen,
        hoverDashStyle,
        hoverColorArr,
        dataStore = dataSet.components.data,
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        toolTipValue,
        setDisplayValue,

    // isBar = chart.isBar,
    // is3D = chart.config.is3D,
    // isStacked = chart.isStacked,
    isBar = false,
        is3D = false,
        isStacked = false,
        stack100Percent,
        enableAnimation,
        parentYAxis,
        setDataDashed,
        setDataPlotDashLen,
        setDataPlotDashGap,
        i,
        reflowData = /* logic.chartInstance.jsVars._reflowData */{},
        reflowDataObj = reflowData.dataObj || (reflowData.dataObj = {}),
        reflowChartObj = reflowDataObj.chart || (reflowDataObj.chart = {}),


    // fcJSON = dataSet.fcJSON,
    // isSingleSeries = chart.config.singleseries,
    lineThickness = (0, _lib.pluck)(chartAttr.connectorthickness, 1),
        showSum,
        dataLabel,
        showLabel,
        itemValue,
        maxValue = -Infinity,
        minValue = Infinity,
        seriesSum = 0,
        total = 0,
        lastComTotal = 0,
        formatedSum,
        issum,
        zLine,
        setColor,
        cumulative,
        sumObj,
        countPoint,
        plotfillangle;
    dataSet.setState('visible', (0, _lib.pluckNumber)(JSONData.visible, !Number(JSONData.initiallyhidden), 1) === 1);
    // dataplot border width. Managing for 3D too
    showplotborder = conf.showplotborder = (0, _lib.pluckNumber)(chartAttr.showplotborder, is3D ? 0 : 1);
    // waterfall2D chart doesn't show the plotborder by default until we set showplotborder true
    conf.plotBorderThickness = plotBorderThickness = showplotborder ? is3D ? 1 : (0, _lib.pluckNumber)(chartAttr.plotborderthickness, 1) : 0;
    // whether to use round edges or not in the waterfall2D
    conf.isRoundEdges = isRoundEdges = (0, _lib.pluckNumber)(chartAttr.useroundedges, 0);
    // dataplot border alpha
    conf.plotBorderAlpha = plotBorderAlpha = showplotborder ? (0, _lib.pluck)(chartAttr.plotborderalpha, plotFillAlpha, HUNDREDSTRING) : 0;
    // dataplot border color
    conf.plotBorderColor = plotBorderColor = (0, _lib.pluck)(chartAttr.plotbordercolor, is3D ? '#ffffff' : colorM.getColor(PLOTBORDERCOLOR).split(COMMA)[0]);
    // GradientColor of the plot fill
    conf.plotgradientcolor = plotgradientcolor = usePlotGradientColor ? (0, _lib.getDefinedColor)(chartAttr.plotgradientcolor, colorM.getColor(PLOTGRADIENTCOLOR)) : BLANK;
    conf.plotDashLen = plotDashLen = (0, _lib.pluckNumber)(chartAttr.plotborderdashlen, 6);
    conf.plotDashGap = plotDashGap = (0, _lib.pluckNumber)(chartAttr.plotborderdashgap, 3);
    // use3DLighting to show gredient color effect in waterfall2D charts
    conf.use3DLighting = (0, _lib.pluckNumber)(chartAttr.use3dlighting, 1);
    conf.showSum = showSum = (0, _lib.pluckNumber)(chartAttr.showsumatend, 1);
    conf.plotColor = plotColor = (0, _lib.pluck)(JSONData.color, plotColor);
    // defaultAngle depend upon item value
    conf.plotfillAngle = plotfillAngle = (0, _lib.pluckNumber)(360 - chartAttr.plotfillangle, 90);
    conf.showShadow = isRoundEdges || is3D ? (0, _lib.pluckNumber)(chartAttr.showshadow, 1) : (0, _lib.pluckNumber)(chartAttr.showshadow, colorM.getColor(SHOWSHADOW));
    conf.showHoverEffect = showHoverEffect = (0, _lib.pluckNumber)(chartAttr.plothovereffect, chartAttr.showhovereffect, UNDEF);

    // todo start - **Needs to remove them if not required in waterfall2D*****************
    conf.plotFillAlpha = plotFillAlpha = (0, _lib.pluck)(JSONData.alpha, chartAttr.plotfillalpha, HUNDREDSTRING);
    conf.plotRadius = (0, _lib.pluckNumber)(chartAttr.useRoundEdges, conf.isRoundEdges ? 1 : 0);
    conf.plotFillRatio = plotFillRatio = (0, _lib.pluck)(JSONData.ratio, chartAttr.plotfillratio);

    conf.plotBorderDashStyle = initailPlotBorderDashStyle = plotBorderDash ? (0, _lib.getDashStyle)(plotDashLen, plotDashGap) : 'none';
    conf.showValues = (0, _lib.pluckNumber)(JSONData.showvalues, chartAttr.showvalues, 1);
    conf.valuePadding = (0, _lib.pluckNumber)(chartAttr.valuepadding, 2);
    conf.enableAnimation = enableAnimation = (0, _lib.pluckNumber)(chartAttr.animation, chartAttr.defaultanimation, 1);
    conf.animation = !enableAnimation ? false : {
      duration: (0, _lib.pluckNumber)(chartAttr.animationduration, 1) * 1000
    };
    reflowChartObj.transposeAnimation = conf.transposeAnimation = (0, _lib.pluckNumber)(chartAttr.transposeanimation, reflowChartObj.transposeAnimation, enableAnimation);
    conf.transposeAnimDuration = (0, _lib.pluckNumber)(chartAttr.transposeanimduration, 0.2) * 1000;

    conf.showTooltip = (0, _lib.pluckNumber)(chartAttr.showtooltip, 1);
    conf.stack100Percent = stack100Percent = (0, _lib.pluckNumber)(chart.stack100percent, chartAttr.stack100percent, 0);
    conf.definedGroupPadding = Math.max((0, _lib.pluckNumber)(chartAttr.plotspacepercent), 0);
    conf.plotSpacePercent = Math.max((0, _lib.pluckNumber)(chartAttr.plotspacepercent, 20) % 100, 0);
    conf.maxColWidth = (0, _lib.pluckNumber)(isBar ? chartAttr.maxbarheight : chartAttr.maxcolwidth, 50);
    conf.showPercentValues = (0, _lib.pluckNumber)(chartAttr.showpercentvalues, isStacked && stack100Percent ? 1 : 0);
    conf.showPercentInToolTip = (0, _lib.pluckNumber)(chartAttr.showpercentintooltip, isStacked && stack100Percent ? 1 : 0);
    conf.plotPaddingPercent = (0, _lib.pluckNumber)(chartAttr.plotpaddingpercent);
    conf.rotateValues = (0, _lib.pluckNumber)(chartAttr.rotatevalues) ? 270 : 0;
    conf.placeValuesInside = (0, _lib.pluckNumber)(chartAttr.placevaluesinside, 0);
    /* conf.zeroPlaneColor = chart.options.chart.zeroPlaneColor;
    conf.zeroPlaneBorderColor = chart.options.chart.zeroPlaneBorderColor;
    conf.zeroPlaneShowBorder = chart.options.chart.zeroPlaneShowBorder; */
    conf.parentYAxis = parentYAxis = (0, _lib.pluck)(JSONData.parentyaxis && JSONData.parentyaxis.toLowerCase(), 'p') === 's' ? 1 : 0;
    // todo end ***************
    conf.defaultPadding = {
      left: 0.5,
      right: 0.5
    };

    dataSet.setState('dirty', true);

    if (!dataStore) {
      dataStore = dataSet.components.data = [];
    }
    // storing the configurations for z-line.
    conf.zLine = zLine = {
      step: true,
      data: [],
      dashStyle: chartAttr.connectordashed === '1' ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(chartAttr.connectordashlen, 2), (0, _lib.pluckNumber)(chartAttr.connectordashgap, 2)) : NONE,
      useForwardSteps: true,
      color: convertColor((0, _lib.pluck)(chartAttr.connectorcolor, '000000'), (0, _lib.pluck)(chartAttr.connectoralpha, 100)),
      lineWidth: lineThickness
    };
    // calculate sum
    for (i = 0; i < len; i += 1) {
      // individual set level data
      setData = setDataArr[i];
      itemValue = numberFormatter.getCleanValue(setData.value);
      issum = (0, _lib.pluckNumber)(setData.issum, 0);
      // If its vline then don't calculate
      if (setData.vline || issum) {
        delete setData._value;
        continue;
      }
      seriesSum += itemValue;
      setData._value = itemValue;
    }
    formatedSum = numberFormatter.dataLabels(seriesSum);
    // Is we have to show sum at end then create a dummy set for total
    if (showSum) {
      // converts the truty value of showSum to Boolean TRUE flag.
      showSum = true;
      len += 1;
      sumObj = {
        label: (0, _lib.getFirstValue)(chartAttr.sumlabel, 'Total'),
        // todo remove _value if not required.
        _value: seriesSum,
        value: seriesSum,
        issum: 1,
        cumulative: 1
      };
    }
    // Iterate through all level data
    // Managing the data value labels and other cosmetics inside this loop
    for (i = 0, countPoint = 0; i < len; i += 1) {
      // individual data obj
      setData = setDataArr[i];
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (!dataObj) {
        dataObj = dataStore[i] = {
          graphics: {}
        };
      }

      if (!dataObj.config) {
        config = dataStore[i].config = {};
      }
      if (!setData && showSum) {
        setData = setDataArr[i] = sumObj;
      }
      plotColor = (0, _lib.pluck)(setData.color, colorM.getPlotColor(i));
      // Managing vLines in between <set> elements
      // If its vline
      // we call the grid manager addVline function, that creates vline
      // and we stop execution here and continue the loop to next data
      if (dataObj.vline) {
        // todo need to validate with axis module and add vline.
        continue;
      }
      // get the valid value
      // parsePointValue check the its a value value of not and return
      // the valid value
      itemValue = setData._value;
      delete setData._value;
      config.issum = issum = (0, _lib.pluckNumber)(setData.issum, 0);
      cumulative = config.isCumulative = (0, _lib.pluckNumber)(setData.cumulative, 1);
      if (issum) {
        itemValue = cumulative ? total : total === lastComTotal ? total : total - lastComTotal;
        config.lastComTotal = lastComTotal;
        lastComTotal = total;
        zLine.data.push({
          y: null,
          x: countPoint - 0.5
        });
      } else {
        total += itemValue;
      }

      maxValue = Math.max(maxValue, total);
      minValue = Math.min(minValue, total);
      // store the cumulative total
      config.total = total;
      // we check showLabel in individual data
      // if its set to 0 than we do not show the particular label
      showLabel = config.showLabel = (0, _lib.pluckNumber)(setData.showlabel, chartAttr.showlabels, 1);
      // Label of the data
      // getFirstValue returns the first defined value in arguments
      // we check if showLabel is not set to 0 in data
      // then we take the label given in data, it can be given using label as well as name too
      // we give priority to label if label is not there, we check the name attribute
      dataLabel = config.dataLabel = (0, _lib.parseUnsafeString)(!showLabel ? BLANK : (0, _lib.getFirstValue)(setData.label, setData.name));

      // <set> cosmetics
      // Color of the particular data
      if (itemValue > 0) {
        setColor = (0, _lib.pluck)(setData.color, chartAttr.positivecolor, plotColor);
        if (showHoverEffect !== 0) {
          hoverColor = (0, _lib.pluck)(setData.positivehovercolor, chartAttr.positivehovercolor, chartAttr.plotfillhovercolor, chartAttr.columnhovercolor, setColor);
        }
      } else {
        setColor = (0, _lib.pluck)(setData.color, chartAttr.negativecolor, plotColor);
        if (showHoverEffect !== 0) {
          hoverColor = (0, _lib.pluck)(setData.negativehovercolor, chartAttr.negativehovercolor, chartAttr.plotfillhovercolor, chartAttr.columnhovercolor, setColor);
        }
      }
      // Setting the angle for plot fill for negative data
      if (itemValue < 0) {
        plotfillangle = 360 - plotfillAngle;
      } else {
        plotfillangle = plotfillAngle;
      }
      plotFillAlpha = (0, _lib.pluck)(setData.alpha, conf.plotFillAlpha);
      setDataDashed = (0, _lib.pluckNumber)(setData.dashed, plotBorderDash);
      setDataPlotDashLen = (0, _lib.pluckNumber)(setData.dashlen, plotDashLen);
      setDataPlotDashGap = plotDashGap = (0, _lib.pluckNumber)(setData.dashgap, plotDashGap);

      config.showValue = (0, _lib.pluckNumber)(setData.showvalue, conf.showValues);
      // todo clean the variables
      config.setValue = setValue = itemValue;
      config.setLink = (0, _lib.pluck)(setData.link);
      config.toolTipValue = toolTipValue = numberFormatter.dataLabels(setValue, parentYAxis);
      config.setDisplayValue = setDisplayValue = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)(setData.displayvalue));
      config.displayValue = (0, _lib.pluck)(setDisplayValue, toolTipValue);

      config.plotBorderDashStyle = plotBorderDashStyle = setDataDashed === 1 ? (0, _lib.getDashStyle)(setDataPlotDashLen, setDataPlotDashGap) : setDataDashed === 0 ? 'none' : initailPlotBorderDashStyle;

      config.shadow = {
        opacity: conf.showShadow ? plotFillAlpha / 100 : 0
      };

      // Setting the color Array to be applied to the bar/column.
      config.colorArr = colorArr = getColumnColor(setColor + COMMA + plotgradientcolor.replace(/,+?$/, ''), plotFillAlpha, plotFillRatio, plotfillangle, isRoundEdges, plotBorderColor,
      // todo remove the toString() by plucking string only.
      plotBorderAlpha.toString(),
      // todo remove this dirty checks and set the flag value as required.
      isBar ? 1 : 0, !!is3D);

      // Parsing the hover effects only if showhovereffect is not 0.
      if (showHoverEffect !== 0) {
        // Alpha of the data
        hoverAlpha = (0, _lib.pluck)(setData.alpha, setData.hoveralpha, JSONData.hoveralpha, chartAttr.plotfillhoveralpha, chartAttr.columnhoveralpha, plotFillAlpha);
        hoverGradientColor = (0, _lib.pluck)(setData.hovergradientcolor, JSONData.hovergradientcolor, chartAttr.plothovergradientcolor, plotgradientcolor);
        !hoverGradientColor && (hoverGradientColor = '');
        // Fill ratio of the data
        hoverRatio = (0, _lib.pluck)(setData.hoverratio, JSONData.hoverratio, setData.ratio, chartAttr.plothoverratio, plotFillRatio);
        hoverAngle = (0, _lib.pluckNumber)(360 - setData.hoverangle, 360 - JSONData.hoverangle, 360 - chartAttr.plothoverangle, plotfillangle);
        hoverBorderColor = (0, _lib.pluck)(setData.borderhovercolor, JSONData.borderhovercolor, chartAttr.plotborderhovercolor, plotBorderColor);
        hoverBorderAlpha = (0, _lib.pluck)(setData.borderhoveralpha, JSONData.borderhoveralpha, chartAttr.plotborderhoveralpha, plotBorderAlpha, plotFillAlpha);
        hoverBorderThickness = (0, _lib.pluckNumber)(setData.borderhoverthickness, JSONData.borderhoverthickness, chartAttr.plotborderhoverthickness, plotBorderThickness);
        hoverBorderDashed = (0, _lib.pluckNumber)(setData.borderhoverdashed, JSONData.borderhoverdashed, chartAttr.plotborderhoverdashed);
        hoverBorderDashGap = (0, _lib.pluckNumber)(setData.borderhoverdashgap, JSONData.borderhoverdashgap, chartAttr.plotborderhoverdashgap, plotDashLen);
        hoverBorderDashLen = (0, _lib.pluckNumber)(setData.borderhoverdashlen, JSONData.borderhoverdashlen, chartAttr.plotborderhoverdashlen, plotDashGap);
        hoverDashStyle = hoverBorderDashed ? (0, _lib.getDashStyle)(hoverBorderDashLen, hoverBorderDashGap) : plotBorderDashStyle;

        /* If no hover effects are explicitly defined and
                     * showHoverEffect is not 0 then hoverColor is set.
                     */
        if (showHoverEffect === 1 && hoverColor === plotColor) {
          hoverColor = getLightColor(hoverColor, 70);
        }

        // setting the hover color array which is always applied except when showHoverEffect is not 0.
        hoverColorArr = getColumnColor(hoverColor + ',' + hoverGradientColor, hoverAlpha, hoverRatio, hoverAngle, isRoundEdges, hoverBorderColor, hoverBorderAlpha.toString(), isBar ? 1 : 0, !!is3D);

        config.setRolloutAttr = {
          fill: !is3D ? (0, _lib.toRaphaelColor)(colorArr[0]) : [(0, _lib.toRaphaelColor)(colorArr[0]), !conf.use3DLighting],
          stroke: showplotborder && (0, _lib.toRaphaelColor)(colorArr[1]),
          'stroke-width': plotBorderThickness,
          'stroke-dasharray': plotBorderDashStyle
        };
        config.setRolloverAttr = {
          fill: !is3D ? (0, _lib.toRaphaelColor)(hoverColorArr[0]) : [(0, _lib.toRaphaelColor)(hoverColorArr[0]), !conf.use3DLighting],
          stroke: showplotborder && (0, _lib.toRaphaelColor)(hoverColorArr[1]),
          'stroke-width': hoverBorderThickness,
          'stroke-dasharray': hoverDashStyle
        };
      }
      /*
                todo: Was in the old architechture and need to be validated and included in the new architechture.
                // Used to set alpha of the shadow
                    pointShadow = {
                        opacity: setAlpha / 100,
                        inverted: isBar
                    };
                // get per-point dash-style
                    pointDashStyle = setBorderDashed ?
                        getDashStyle(setBorderDashLen, setBorderDashGap, setBorderWidth) :
                        DASH_DEF;
                */
      // todo removing this category tooltext. Needs a validation.
      // label = getValidValue(parseUnsafeString(pluck (categories[i].tooltext, categories[i].label)));

      formatedVal = config.toolTipValue;

      // Parsing tooltext against various configurations provided by the user.
      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.tooltext, JSONData.plottooltext, chartAttr.plottooltext)));
      // create the tooltext
      if (!showTooltip) {
        toolText = false;
      } else if (setTooltext !== UNDEF) {
        macroIndices = [1, 2, 3, 5, 6, 7, 20, 21, 24, 25];
        parserConfig = {
          formattedValue: formatedVal,
          label: dataLabel,
          yaxisName: yAxisName,
          xaxisName: xAxisName,
          cumulativeValue: total,
          cumulativeDataValue: numberFormatter.dataLabels(total),
          sum: formatedSum,
          unformattedSum: seriesSum
        };
        toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, setData, chartAttr, JSONData);
      } else {
        // determine the dispalay value then
        toolText = formatedVal === null ? false : dataLabel !== BLANK ? dataLabel + tooltipSepChar : '';
      }
      // create the displayvalue
      // if (!config.showValue) {
      //   displayValue = BLANK;
      // } else if (setDisplayValue !== UNDEF) {
      //   displayValue = setDisplayValue;
      // } else { // determine the dispalay value then
      //   displayValue = formatedVal;
      // }
      zLine.data.push({
        y: itemValue === null ? null : total,
        x: countPoint
      });
      countPoint += 1;

      config.originalPlotColor = plotColor;

      config.toolText = toolText;
      config.setTooltext = toolText;

      config._x = i;
      config._y = setValue;

      // if (!config.issum) {
      //   config._y = dataStore[i - 1] && dataStore[i - 1].config.total;
      // } else if (!config.isCumulative) {
      //   config._y = config.lastComTotal;
      // }
    }
    conf.maxValue = maxValue;
    conf.minValue = minValue;
    conf.connectNullData = (0, _lib.pluckNumber)(chartAttr.connectnulldata, 0);
    conf.showConnectors = (0, _lib.pluckNumber)(chartAttr.showconnectors, 1);
    // reconfiguring the category object for the axis module
    catData = JSONData.catData;
    for (i = 0; i < catData.length; i += 1) {
      catObj = catData[i];
      setDataArr.splice(catObj.index, 0, catObj.data);
    }
    dataSet.getFromEnv('xAxis').setTickValues(setDataArr);
    // No real time max min calculations are required during resize.
    dataSet.config.maxminFlag = false;
  };

  // Create pixel coordinates for the plots


  WaterFall2DDataset.prototype.createCoordinates = function createCoordinates() {
    var dataSet = this,
        dsComponents = dataSet.components,
        dsData = dsComponents.data,
        chart = dataSet.getFromEnv('chart'),
        isBar = chart.isBar,
        yAxis = dataSet.getFromEnv('yAxis'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yBase = yAxis.getAxisBase(),
        yBasePos = yAxis.getPixel(yBase),
        isVertical = xAxis.config.isVertical,
        dataObj,
        config,
        previousY,
        i,
        Px,
        Py,
        Pb,
        yVal,
        chartConfig = dataSet.getFromEnv('chartConfig'),
        xDepth = chartConfig.xDepth || 0,
        yDepth = chartConfig.yDepth || 0,
        len = dsData.length,
        components = dataSet.components,
        groupManager = dataSet.groupManager,
        stackConf = groupManager && groupManager.stackConf,
        dataStore = components.data;

    !isBar && (xDepth = -xDepth);
    isBar && (yDepth = -yDepth);

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (dataObj === UNDEF) {
        continue;
      }
      yVal = config._y;
      if (!config.issum) {
        previousY = dataStore[i - 1] && dataStore[i - 1].config.total;
        previousY && (yVal += previousY);
      } else if (!config.isCumulative) {
        previousY = config.lastComTotal;
        yVal += config.lastComTotal;
      } else {
        previousY = null;
      }

      Px = xAxis.getPixel(stackConf && stackConf[i].x || config._x) + xDepth;
      Py = yAxis.getPixel(yVal) + yDepth;
      Pb = (previousY ? yAxis.getPixel(previousY) : yBasePos) + yDepth;
      if (isVertical) {
        config._Px = Py;
        config._Py = Px;
        config._Pby = Px;
        config._Pbx = Pb;
      } else {
        config._Px = Px;
        config._Py = Py;
        config._Pby = Pb;
        config._Pbx = Px;
      }
    }
  };

  WaterFall2DDataset.prototype.getDataLimits = function getDataLimits() {
    var dataSet = this,
        dataStore = dataSet.components.data,
        conf = dataSet.config,
        i,
        config,
        len = dataStore.length,
        setValue,
        maxValue = -Infinity,
        minValue = +Infinity;

    for (i = 0; i < len; i++) {
      if (!dataStore[i]) {
        continue;
      }
      config = dataStore[i].config;
      setValue = config.total;
      if (setValue !== UNDEF) {
        maxValue = Math.max(maxValue, setValue);
        minValue = Math.min(minValue, setValue);
      }
    }

    conf.maxValue = maxValue;
    conf.minValue = minValue;
    return {
      max: conf.maxValue,
      min: conf.minValue
    };
  };

  WaterFall2DDataset.prototype.drawPlots = function drawPlots(anim) {
    var dataSet = this;
    _ColumnDataset.prototype.drawPlots.call(this, anim);
    if (dataSet.config.showConnectors) {
      dataSet.drawLine();
    } else {
      dataSet.getContainer('commonElemsGroup').hide();
    }
  };

  WaterFall2DDataset.prototype.drawLine = function drawLine() {
    var dataSet = this,
        conf = dataSet.config,
        i,
        yPos,
        xPos,
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis'),
        yBase = yAxis.getAxisBase(),
        yBasePos = yAxis.getPixel(yBase),
        lineContainer = dataSet.getContainer('commonElemsGroup'),
        groupNetHalfWidth = dataSet.getFromEnv('columnWidth') / 2,
        animationManager = dataSet.getFromEnv('animationManager'),
        zLineConf = conf.zLine,
        connectNullData = conf.connectNullData,
        data = zLineConf.data,
        set,
        y,
        x,
        ln = data.length,
        datasetGraphics = dataSet._graphics,
        seriesDashStyle = zLineConf.dashStyle,
        seriesColor = zLineConf.color,
        seriesLineWidth = zLineConf.lineWidth,
        lastXPos,
        zLineDummy = datasetGraphics.zLine,
        zLine,
        lastYPos = null,
        linePath = [],
        lastMoveCommand = [];

    yAxis.yBasePos = yBasePos;
    lineContainer.toFront().show();

    for (i = 0; i < ln; i += 1) {
      set = data[i];
      y = set.y;
      if (y === null) {
        lastMoveCommand.length = 0;
        if (connectNullData === 0) {
          lastYPos = null;
        }
      } else {
        x = (0, _lib.pluckNumber)(set.x, i);
        // Multi series related management.
        yPos = yAxis.getPixel(y);
        xPos = xAxis.getPixel(x);
        // crisp line positions
        xPos = (0, _lib.getCrispValue)(xPos, seriesLineWidth, seriesLineWidth).position;
        yPos = (0, _lib.getCrispValue)(yPos, seriesLineWidth, seriesLineWidth).position;

        if (lastYPos !== null) {
          if (lastMoveCommand.length) {
            linePath = linePath.concat(lastMoveCommand);
            lastMoveCommand.length = 0;
          }
          linePath.push(M, lastXPos, lastYPos, 'm', -groupNetHalfWidth, 0, H, xPos, 'h', groupNetHalfWidth, 'm', 0, yPos - lastYPos);
        } else {
          lastMoveCommand.push(M, xPos, yPos);
        }

        lastXPos = xPos;
        lastYPos = yPos;
      }
    }
    // If zLine is not present, create it
    zLine = animationManager.setAnimation({
      el: zLineDummy || 'path',
      attr: {
        path: linePath,
        'stroke-linecap': 'round',
        'stroke-opacity': 1,
        'stroke-dasharray': seriesDashStyle,
        'stroke': seriesColor,
        'stroke-linejoin': seriesLineWidth >= MAX_MITER_LINEJOIN ? 'round' : 'miter',
        'stroke-width': seriesLineWidth
      },
      container: lineContainer,
      component: dataSet,
      dom: 'path'
    });

    // If zline is not present previously, add to _graphics of dataset
    if (!zLineDummy) {
      dataSet.addGraphicalElement('zLine', zLine);
    }
  };

  return WaterFall2DDataset;
}(_column2['default']);

exports['default'] = WaterFall2DDataset;

/***/ }),

/***/ 827:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _columnAnimation = __webpack_require__(89);

var _columnAnimation2 = _interopRequireDefault(_columnAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  dataset: {
    'initial.dataset.waterFall2D': _columnAnimation2['default']['initial.dataset.column']
  }
};

/***/ }),

/***/ 828:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _kagiAnimation = __webpack_require__(829);

var _kagiAnimation2 = _interopRequireDefault(_kagiAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var POSITION_TOP = 'top',
    POSITION_BOTTOM = 'bottom',
    POSITION_MIDDLE = 'middle',
    POSITION_RIGHT = 'right',
    ROUND = 'round',
    UNDEF = void 0,
    EVENTARGS = 'eventArgs',
    SETROLLOVERATTR = 'setRolloverAttr',
    SETROLLOUTATTR = 'setRolloutAttr',
    defined = function defined(obj) {
  return obj !== UNDEF && obj !== null;
},
    M = 'M',
    H = 'H',
    V = 'V',
    HTP = _lib.hasTouch ? _lib.TOUCH_THRESHOLD_PIXELS : _lib.CLICK_THRESHOLD_PIXELS,
    NONE = 'none';
(0, _dependencyManager.addDep)({
  name: 'kagiAnimation',
  type: 'animationRule',
  extension: _kagiAnimation2['default']
});

var KagiDataset = function (_LineDataset) {
  _inherits(KagiDataset, _LineDataset);

  function KagiDataset() {
    _classCallCheck(this, KagiDataset);

    var _this = _possibleConstructorReturn(this, _LineDataset.call(this));

    _this.manageSpace = function () {
      // Overrides fn
    };
    _this.drawCommonElements = function () {
      // Overrides fn
    };
    return _this;
  }
  /**
   * Sets the type of the component
   * @return {string} type
   */


  KagiDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  KagiDataset.prototype.getName = function getName() {
    return 'kagi';
  };

  KagiDataset.prototype._parseShadowOptions = function _parseShadowOptions() {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        chartAttr = chart.getFromEnv('dataSource').chart;
    return {
      opacity: (0, _lib.pluckNumber)(chartAttr.showshadow, 1) ? conf.alpha / 100 : 0
    };
  };

  KagiDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    _LineDataset.prototype.configureAttributes.call(this, datasetJSON);
    var dataSetComponents,
        datasetObj = this,
        removeDataArr,
        chart = datasetObj.getFromEnv('chart'),

    // canvasWidth = chart.config.canvasWidth,
    xAxis = datasetObj.getFromEnv('xAxis'),
        temp = 0,
        data,
        catArr = [],
        series,
        JSONData,
        FCChartObj,
        valueMax,
        valueMin,
        isRallyInitialised,
        shiftCounter,
        reversalValue,
        reversalPercentage,
        rallyDashLen,
        rallyDashGap,
        declineDashLen,
        declineDashGap,
        lastPlotValue,
        setShowLabel,
        length,
        index,
        fcIndex,
        fcDataObj,
        lastShift,
        prevDataObj,
        plotValue,
        dataObj,
        nextDataValue,
        valueDifference,
        dataValue,
        isRally,
        lastLow,
        lastHigh,
        isMovingUp,
        isShift,
        checkValue,
        t,
        count = 0,
        vAlign,

    // canvasPadding,
    align;

    dataSetComponents = datasetObj.components;
    data = dataSetComponents.data;
    series = datasetObj.config;
    JSONData = datasetObj.config.JSONData.data;
    FCChartObj = chart.getFromEnv('dataSource').chart;
    valueMax = series.maxValue;
    valueMin = series.minValue;
    removeDataArr = dataSetComponents.removeDataArr || (dataSetComponents.removeDataArr = []);
    // First vertical point for shift is yet to be obtained
    isRallyInitialised = false;
    // Initialised to one to avoid zero dividing the width of the canvas
    // (as the case may be) to get the xShiftLength
    shiftCounter = 0;
    // The value which determines whether to make a horizontal shift
    // to deal with the next point
    reversalValue = (0, _lib.pluckNumber)(FCChartObj.reversalvalue, -1);
    // The percentage of the range of values, which determines whether
    // to make a horizontal shift to deal with the next point
    reversalPercentage = (0, _lib.pluckNumber)(FCChartObj.reversalpercentage, 5);

    for (index = 0; index < data.length; index += 1) {
      data[index].config.__nullCount = count;
      if (data[index].config.setValue === null) {
        removeDataArr.push(data.splice(index, 1)[0]);
        count++;
        index -= 1;
      }
    }
    if (data.length) {
      // Color of line denoting rally
      series.rallyColor = (0, _lib.pluck)(FCChartObj.rallycolor, 'FF0000');
      series.rallyAlpha = (0, _lib.pluckNumber)(FCChartObj.rallyalpha, FCChartObj.linealpha, 100);
      // color of line denoting decline
      series.declineColor = (0, _lib.pluck)(FCChartObj.declinecolor, '0000FF');
      series.declineAlpha = (0, _lib.pluckNumber)(FCChartObj.declinealpha, FCChartObj.linealpha, 100);
      // Default canvasPadding is 15.
      series.canvasPadding = (0, _lib.pluckNumber)(FCChartObj.canvaspadding, 15);
      // The maximum horizontal shift in percentage of the
      // available canvas width
      series.maxHShiftPercent = (0, _lib.pluckNumber)(FCChartObj.maxhshiftpercent, 10);
      // effectiveCanvasWidth = canvasWidth - canvasPadding * 2;
      // Thickness of line denoting rally
      series.rallyThickness = (0, _lib.pluckNumber)(FCChartObj.rallythickness, FCChartObj.linethickness, 2);
      // length of the dash
      rallyDashLen = (0, _lib.pluckNumber)(FCChartObj.rallydashlen, FCChartObj.linedashlen, 5);
      // distance between dash
      rallyDashGap = (0, _lib.pluckNumber)(FCChartObj.rallydashgap, FCChartObj.linedashgap, 4);

      // Thickness of line denoting decline
      series.declineThickness = (0, _lib.pluckNumber)(FCChartObj.declinethickness, FCChartObj.linethickness, 2);
      // length of the dash
      declineDashLen = (0, _lib.pluckNumber)(FCChartObj.declinedashlen, FCChartObj.linedashlen, 5);
      // distance between dash
      declineDashGap = (0, _lib.pluckNumber)(FCChartObj.declinedashgap, FCChartObj.linedashgap, 4);

      series.lineDashed = {
        'true': (0, _lib.pluckNumber)(FCChartObj.rallydashed, FCChartObj.linedashed, 0),
        'false': (0, _lib.pluckNumber)(FCChartObj.declinedashed, FCChartObj.linedashed, 0)
      };

      // Storing dashStyle in series to be use while drawing graph and
      series.rallyDashed = (0, _lib.pluckNumber)(FCChartObj.rallydashed, FCChartObj.linedashed, 0) ? (0, _lib.getDashStyle)(rallyDashLen, rallyDashGap) : NONE;
      series.declineDashed = (0, _lib.pluckNumber)(FCChartObj.declinedashed, FCChartObj.linedashed, 0) ? (0, _lib.getDashStyle)(declineDashLen, declineDashGap) : NONE;

      // canvasPadding to be use by Kagi chart Drawing
      series.canvasPadding = (0, _lib.pluckNumber)(FCChartObj.canvaspadding, this.canvasPadding, 15);

      // setting the reversal value
      reversalValue = reversalValue > 0 ? reversalValue : reversalPercentage * (valueMax - valueMin) / 100;

      // Initialised by the first data value
      lastPlotValue = data[0].config.setValue;
      // Local function to set anchor and value visibility of
      // unwanted points, after the first point is found to draw
      // vertical kagi line
      setShowLabel = function setShowLabel(id, _isRally) {
        // Initial data value
        var dataXValue,
            r = 1,
            data1Value = data[0].config.setValue;
        // Looping to check for unwanted points
        while (r < id) {
          // Value of point under check
          dataXValue = data[r].config.setValue;
          // If current trend is rally
          if (_isRally) {
            if (dataXValue <= data1Value) {
              data[r].config.isDefined = false;
            }
            // Else current trend is decline
          } else {
            if (dataXValue >= data1Value) {
              data[r].config.isDefined = false;
            }
          }
          r += 1;
        }
        // Setting alignment of value for the first data
        data[0].config.vAlign = _isRally ? POSITION_BOTTOM : POSITION_TOP;
        data[0].config.align = 'center';
      };

      length = JSONData.length;
      // iterating to set values of properties in data for each respective
      // point (main algorithm of KagiChart)
      // loop counter starts from 2 since data for plot 1 is unique
      for (index = 0, fcIndex = 0; fcIndex < length; fcIndex += 1, index += 1) {
        fcDataObj = JSONData[fcIndex];
        // Calculation of vLine based on hShift.
        if (fcDataObj && fcDataObj.vline) {
          continue;
        }
        dataObj = data[index] && data[index].config;
        // lastFcDataObj = JSONData[fcIndex];
        // Special handling for vLines
        if (lastShift) {
          lastShift = false;
          // vLinePosition += 0.5;
        }
        dataObj && (dataObj.isDefined = true);
        if (index && dataObj) {
          dataObj.isShift = UNDEF;

          prevDataObj = data[index - 1].config;
          dataObj.vAlign = POSITION_MIDDLE;
          dataObj.align = POSITION_RIGHT;
          dataObj.showLabel = false;
          // initialised to null each time
          plotValue = null;
          // data value of plot under current loop
          dataValue = dataObj.setValue;
          // data value of previous plot
          // lastDataValue = data[i-1].y;
          // data value of next plot
          nextDataValue = data[index + 1] && data[index + 1].config.setValue;
          valueDifference = Math.abs(lastPlotValue - dataValue);

          // if current plot is yet render the trend,then care is taken
          // to make few initial assumptions as algorithm starts with it
          if (!isRallyInitialised) {
            // if current plot is higher than the last plotted one
            // (first data) by significant amount
            if (dataValue > lastPlotValue && valueDifference > reversalValue) {
              // is assumed to be true
              isRally = true;
              // value of last low point of swing (assumed)
              lastLow = lastPlotValue;
              // none assumed
              lastHigh = null;
              // kagi rising
              isMovingUp = true;
              // first vertical point for shift is obtained
              isRallyInitialised = true;
              // call of local function to set visibility false for
              // anchors and values of unwanted points
              setShowLabel(index, isRally);
              // if current plot is lower than the last plotted one
              // (first data) by significant amount
            } else if (dataValue < lastPlotValue && valueDifference > reversalValue) {
              // is assumed to be false
              isRally = false;
              // none assumed
              lastLow = null;
              // value of last high point of swing (assumed)
              lastHigh = lastPlotValue;
              // kagi falling
              isMovingUp = false;
              // first vertical point for shift is obtained
              isRallyInitialised = true;
              // call of local function to set visibility false for
              // anchors and values of unwanted points
              setShowLabel(index, isRally);
              // else, point under loop is not significant to
              // draw the first vertical kagi line to
            } else {
              // is set to null
              isRally = null;
              // vertical shifting direction is set to null
              isMovingUp = null;
              // first vertical point for shift is yet to be obtained
              isRallyInitialised = false;
            }
            // trend property for plot 1 is set
            if (defined(prevDataObj)) {
              prevDataObj.isRally = isRally;
            }
            if (isRally !== null) {
              // to get the initial horizontal line in trend color
              // (in case data[1].value = data[2].value=... so on or not)
              data[0].config.isRally = isRally;
            }
            // else, for plot 3 and above, only trend is evaluated
          } else {
            // setting trends by concept of Kagi Chart
            if (dataValue < lastLow && isRally) {
              isRally = false;
            } else if (dataValue > lastHigh && !isRally) {
              isRally = true;
            }
            // else isRally remains unchanged
          }

          // Setting in data for the plot
          dataObj.isRally = isRally;
          // To check for having horizontal shift or not,
          // we need to use the pertinent value
          if (isMovingUp && dataValue < lastPlotValue || !isMovingUp && dataValue > lastPlotValue) {
            plotValue = lastPlotValue;
          }
          // To find if there is a horizontal shift associated
          // with this plot
          checkValue = plotValue || dataValue;
          valueDifference = Math.abs(checkValue - nextDataValue);
          // if the line is static till now
          if (isMovingUp === null) {
            isShift = null;
            // if the line is rising
          } else if (isMovingUp) {
            isShift = checkValue > nextDataValue && valueDifference >= reversalValue;
            // else if the line is falling
          } else {
            isShift = checkValue < nextDataValue && valueDifference >= reversalValue;
          }

          // To get the last extremes preceding the current point
          // and setting the vertical/horizontal
          // alignment of the value to be shown for it.
          if (prevDataObj && prevDataObj.isShift) {
            if (isMovingUp) {
              lastLow = lastPlotValue;
              vAlign = POSITION_BOTTOM;
            } else if (!isMovingUp) {
              lastHigh = lastPlotValue;
              vAlign = POSITION_TOP;
            }
            align = 'center';
            // looping to get the actual plot corresponding to the
            // maxima/minima and setting label properties for the same
            for (t = index; t > 1; t -= 1) {
              if (data[t].y == lastPlotValue) {
                data[t].vAlign = vAlign;
                data[t].align = align;
                data[t].showLabel = true;
                // extreme obtained and thus stop looping
                break;
              }
            }
          }
          // if there is a horizontal shift, then
          if (isShift) {
            // updating counter to have to total number of horizontal
            // shifts in the total plot.This is vital for calculation
            // of the length of each horizontal shifts.
            shiftCounter += 1;
            // vLinePosition += 0.5;
            lastShift = true;
            // updating the flag by reversing the boolean
            // value of the flag itself
            isMovingUp = !isMovingUp;
            // setting in data for the plot, to be used for
            // drawing the graph
            dataObj.isShift = true;
            // updating last plotting value
            lastPlotValue = checkValue;
            catArr.push(JSONData[index + dataObj.__nullCount]);
            temp = datasetObj._appendCategory(temp, index, catArr, 0);
          } else if (isMovingUp && dataValue > lastPlotValue || !isMovingUp && dataValue < lastPlotValue) {
            // updating last plotting value
            lastPlotValue = dataValue;
            // if cuurent data value is to be skipped for plotting
          } else {
            // setting the value to be plotted
            // (virtually drawing pen stays still due to this)
            plotValue = lastPlotValue;
          }
          // plotValue assigned is either defined or set to null
          dataObj.plotValue = plotValue;
          // few local variables are bundled together in an object to be
          // used later-on to work around a Catch-22 problem
          dataObj.objParams = {
            isRally: isRally,
            lastHigh: lastHigh,
            lastLow: lastLow,
            isRallyInitialised: isRallyInitialised
          };
        }
      }
      // insert if any remaining categories to be appended.
      datasetObj._appendCategory(temp, index, catArr, 1);
      // insert the categories before setting the final category.
      catArr.push(fcDataObj);
      xAxis.setTickValues(catArr);
      series.shiftCount = shiftCounter + 1;
    }
  };

  KagiDataset.prototype._appendCategory = function _appendCategory(temp, index, catArr, lineposition) {
    var i,
        catObj,
        catData,
        refIndex,
        datasetObj = this,
        catOnlyData = datasetObj.config.JSONData.catData;
    if (temp < catOnlyData.length) {
      for (i = temp; i < catOnlyData.length; i += 1, temp = i) {
        catObj = catOnlyData[i];
        catData = catObj.data;
        refIndex = catObj.index - (i + 1);
        if (refIndex < index) {
          catData.lineposition = (0, _lib.pluckNumber)(catData.lineposition, lineposition);
        } else if (refIndex > index) {
          break;
        }
        catArr.push(catData);
      }
    }
    return temp;
  };

  KagiDataset.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        xAxis = dataset.getFromEnv('xAxis'),
        conf = dataset.config,
        trackIndex = conf.trackIndex,
        dataStore = dataset.components.data,
        len = dataStore.length,
        i,
        j,
        index,
        returnValue,
        xMin,
        xMax,
        pointObjs;

    // getting new chart XY accordint to Translation of axis
    chartX += xAxis.getTranslation();

    xMin = Math.floor(Math.max(xAxis.getValue(chartX - conf.maxRadius), 0));
    xMax = Math.ceil(Math.min(xAxis.getValue(chartX + conf.maxRadius), len - 1));

    for (j = xMax; j >= xMin; j--) {
      pointObjs = trackIndex[j];
      len = pointObjs && pointObjs.length;
      // search point objects under current value
      for (i = len; i >= 0; i--) {
        index = pointObjs[i];
        returnValue = dataset.isWithinShape(dataStore[index], index, chartX, chartY);
        if (returnValue) {
          return returnValue;
        }
      }
    }
  };

  /**
   * Returns the clip path for kagi
   *
   * @param {any} type type of clip-rect
   * @memberof KagiDataset
   */


  KagiDataset.prototype.getClip = function getClip(type) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        canvas = chart.getChildren('canvas')[0],
        canvasConfig = canvas.config,
        clipRect = [canvasConfig.canvasLeft, canvasConfig.canvasTop, 0, canvasConfig.canvasTop + canvasConfig.canvasHeight];

    clipRect[2] += type === 'init' ? 0 : canvasConfig.canvasLeft + canvasConfig.canvasWidth;
    return clipRect;
  };

  /**
   * Parses the plot attributes
   *
   * @param {any} point
   * @param {any} index
   * @memberof KagiDataset
   */


  KagiDataset.prototype.parsePlotAttributes = function parsePlotAttributes(point, index) {
    var i = index,
        trackerConfig = void 0,
        dataSet = this,
        JSONData = dataSet.config.JSONData,
        conf = dataSet.config,

    // temp hardcoded.
    datasetIndex = 0,
        xAxis = dataSet.getFromEnv('xAxis'),
        xPos = void 0,
        yPos = void 0,
        toolText = void 0,
        setLink = void 0,
        setValue = void 0,
        eventArgs = void 0,
        displayValue = void 0,
        dataStore = dataSet.components.data,
        dataObj = void 0,
        setRolloutAttr = void 0,
        setRolloverAttr = void 0,
        anchorRadius = void 0,
        hoverEffects = void 0,
        anchorProps = {},
        symbol = void 0,
        config = void 0,
        visible = dataSet.getState('visible'),
        attr = void 0;

    point = point.config;
    dataObj = dataStore[i];
    config = dataObj.config;
    trackerConfig = point.trackerConfig = {};
    hoverEffects = config.hoverEffects;
    setValue = config.setValue;
    displayValue = config.displayValue;
    xPos = dataObj._xPos = xAxis.getPixel(point.plotX);
    yPos = dataObj._yPos = point.plotY;

    dataObj._index = point.plotX;
    anchorProps = config.anchorProps;
    symbol = anchorProps.symbol;
    toolText = point.finalTooltext = point.toolText;
    setLink = config.setLink;

    if (yPos !== UNDEF && !isNaN(yPos) && point.isDefined) {
      // Storing the event arguments
      eventArgs = point.eventArgs = point.eventArgs || {};

      // Storing the event arguments
      eventArgs.index = i;
      eventArgs.link = setLink;
      eventArgs.value = setValue;
      eventArgs.displayValue = displayValue;
      eventArgs.categoryLabel = config.label;
      eventArgs.toolText = toolText;
      eventArgs.id = conf.userID;
      eventArgs.datasetIndex = datasetIndex || 0;
      eventArgs.datasetName = JSONData.seriesname;
      eventArgs.visible = visible;

      // Hover consmetics
      setRolloutAttr = setRolloverAttr = {};

      if (anchorProps.imageUrl) {
        config.anchorImageLoaded = false;
      } else {
        attr = {
          polypath: [symbol[1] || 2, xPos, yPos, anchorProps.radius, anchorProps.startAngle, 0],
          fill: (0, _lib.toRaphaelColor)({
            color: anchorProps.bgColor,
            alpha: anchorProps.bgAlpha
          }),
          stroke: (0, _lib.toRaphaelColor)({
            color: anchorProps.borderColor,
            alpha: anchorProps.borderAlpha
          }),
          'stroke-width': anchorProps.borderThickness,
          visibility: !anchorProps.radius ? 'hidden' : visible
        };
        anchorRadius = Math.max(anchorProps.radius, hoverEffects && hoverEffects.anchorRadius || 0, HTP) + anchorProps.borderThickness / 2;

        trackerConfig.trackerRadius = anchorRadius;
      }

      // Parsing cosmectics to be applied when element is hovered on.
      if (hoverEffects.enabled) {
        setRolloverAttr = {
          polypath: [hoverEffects.anchorSides || 2, xPos, yPos, hoverEffects.anchorRadius, hoverEffects.startAngle, hoverEffects.dip],
          fill: (0, _lib.toRaphaelColor)({
            color: hoverEffects.anchorColor,
            alpha: hoverEffects.anchorBgAlpha
          }),
          stroke: (0, _lib.toRaphaelColor)({
            color: hoverEffects.anchorBorderColor,
            alpha: hoverEffects.anchorBorderAlpha
          }),
          'stroke-width': hoverEffects.anchorBorderThickness
        };
        setRolloutAttr = {
          polypath: [anchorProps.sides, xPos, yPos, anchorProps.radius, anchorProps.startAngle, 0],
          fill: (0, _lib.toRaphaelColor)({
            color: anchorProps.bgColor,
            alpha: anchorProps.bgAlpha
          }),
          stroke: (0, _lib.toRaphaelColor)({
            color: anchorProps.borderColor,
            alpha: anchorProps.borderAlpha
          }),
          'stroke-width': anchorProps.borderThickness
        };
        // set hover effect on each data set
        hoverEffects.attrs = {
          'hoverEnabled': hoverEffects.enabled,
          'anchorRadius': anchorProps.radius,
          'anchorHoverRadius': hoverEffects.anchorRadius
        };

        hoverEffects.attrs[SETROLLOVERATTR] = setRolloverAttr;
        hoverEffects.attrs[SETROLLOUTATTR] = setRolloutAttr;

        anchorProps.isAnchorHoverRadius = hoverEffects.attrs.anchorRadius;
      }
    }

    point.props = {
      element: {
        attr: attr
      }
    };
  };

  /**
   * Parses label attributes and position
   *
   * @param {any} dataObj
   * @param {any} index
   * @memberof KagiDataset
   */


  KagiDataset.prototype.parseLabelAttributes = function parseLabelAttributes(dataObj, index) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        SmartLabel = dataSet.getFromEnv('smartLabel'),
        style = chart.config.dataLabelStyle,
        displayValue = '',
        rotateValues = chartConfig.rotatevalues ? 270 : 0,
        canvasTop = chartConfig.canvasTop,
        canvasHeight = chartConfig.canvasHeight,
        canvasBottom = canvasTop + canvasHeight,
        GUTTER_4 = 4,
        GUTTER_2 = 2,
        valuePadding,
        bBoxObj,
        graphic,
        textHeight,
        origTextHeight,
        textY,
        textX,
        yAdjust,
        nextPoint = {},
        prevPoint = {},
        anchorProps,
        config,
        decidingDimention,
        xPos,
        yPos,
        value,
        showValue,
        anchorRadius,
        i = index,
        len = dataSet.components.data.length,
        setValue,
        attr;

    config = dataObj && dataObj.config;
    setValue = config && config.setValue;

    if (dataObj === UNDEF || setValue === UNDEF || setValue === null || config.labelSkip === true) {
      config && delete config.labelSkip;
      return;
    }

    if (index > 0) {
      prevPoint = {
        x: dataSet.components.data[i - 1]._xPos,
        y: dataSet.components.data[i - 1]._yPos
      };
    }

    if (index < len - 1) {
      nextPoint = {
        x: dataSet.components.data[i + 1]._xPos,
        y: dataSet.components.data[i + 1]._yPos
      };
    }

    anchorProps = config.anchorProps;
    graphic = dataObj.graphics;
    yPos = dataObj._yPos || dataObj.config._Py;
    xPos = dataObj._xPos || dataObj.config._Px;
    anchorRadius = graphic.element ? graphic.image && graphic.element.attr('height') * 0.5 || anchorProps.radius - 3 : 0;

    valuePadding = chartConfig.valuepadding + GUTTER_2 + anchorRadius;

    displayValue = config.displayValue;
    showValue = config.showValue;
    // Drawing label only if displayvalue is defined and not blank and setValue is not null
    if (defined(displayValue) && displayValue !== '' && value !== null && showValue) {
      attr = {
        text: displayValue,
        fill: style.color,
        'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
      };

      bBoxObj = SmartLabel.getOriSize(displayValue);

      if (rotateValues) {
        // If rotated values we use the width of
        // the text as height

        config._state = {
          // If label is already rotated then we take the width as labelWidth
          labelWidth: bBoxObj.height,
          labelHeight: bBoxObj.width
        };
        config._rotated = true;
      } else {
        config._state = {
          // If label is already rotated then we take the height as labelWidth
          labelWidth: bBoxObj.width,
          labelHeight: bBoxObj.height
        };
        config._rotated = false;
      }

      // Calculating the total text height
      textHeight = origTextHeight = rotateValues ? bBoxObj.width : bBoxObj.height;
      textHeight += valuePadding;
      yAdjust = origTextHeight * 0.5 + valuePadding;
      textY = yPos;
      textX = xPos;
      textHeight = textHeight + GUTTER_4;
      decidingDimention = Number(rotateValues) >= 1 ? bBoxObj.height : bBoxObj.width;
      config._valueBelowPoint = 0;

      // Positioning of data labels
      if (nextPoint.y > textY) {
        // nextPoint is below than current point
        if (prevPoint.y < textY) {
          // place aside anchor if not enough space is available in bottom
          textX -= valuePadding + 3 + decidingDimention * 0.5;
        } else {
          // previous point is below current point
          if (yPos - textHeight < canvasTop) {
            // place aside anchor if not enough space is available on top
            textX -= valuePadding + 3 + decidingDimention * 0.5;
            textY = canvasTop + textHeight / 2;
          } else {
            // else place vertically above anchor
            textY -= yAdjust;
          }
        }
      } else {
        // nextpoint is above the current point
        if (prevPoint.y > textY) {
          // place aside anchor if not enough space is available in bottom
          textX -= valuePadding + 3 + decidingDimention * 0.5;
        } else {
          // previous point is above current point
          if (yPos + textHeight > canvasBottom) {
            // place aside anchor if not enough space is available in bottom
            textX -= valuePadding + 3 + decidingDimention * 0.5;
            textY = canvasBottom - textHeight / 2;
          } else {
            // else place vertically below anchor
            textY += yAdjust + GUTTER_2;
            config._valueBelowPoint = 1;
          }
        }
      }

      attr.x = textX;
      attr.y = textY;
    }

    config.props = config.props || {};
    config.props.label = {
      attr: attr
    };
  };
  /**
   * Parses anchor position and cosmetics during post space management
   *
   * @returns {any}
   * @memberof KagiDataset
   */


  KagiDataset.prototype.allocatePosition = function allocatePosition() {
    var i = void 0,
        dataSet = this,
        conf = dataSet.config,
        dataSetComponents = dataSet.components,
        setDataArr = dataSetComponents.data,
        dataSetLen = setDataArr && setDataArr.length,
        xAxis = dataSet.getFromEnv('xAxis'),
        setValue = void 0,
        dataStore = dataSet.components.data,
        dataObj = void 0,
        config = void 0,
        xAxisZeroPos = xAxis.getPixel(0),
        xAxisFirstPos = xAxis.getPixel(1),
        pointDistance = xAxisFirstPos - xAxisZeroPos,
        rallyThickness = conf.rallyThickness,
        declineThickness = conf.declineThickness,
        thickness = {
      'true': rallyThickness,
      'false': declineThickness
    },
        rallyPath = void 0,
        declinePath = void 0,
        xValue = 0,
        plotX = xAxis.getPixel(xValue),
        isRally = setDataArr[0] && !!setDataArr[0].isRally,
        nextPointIsRally = void 0,
        startX = xAxisZeroPos - pointDistance / 2,
        plotY = void 0,
        crispY = void 0,
        nextPoint = void 0,
        path = void 0;

    conf.imagesLoaded = 0;
    if (!setDataArr.length) {
      return;
    }

    rallyPath = conf.rallyPath = [];
    declinePath = conf.declinePath = [];
    // Set components.data to blank array if dataStore is not present
    dataStore = dataSet.components.data = dataStore || [];

    // Special situation for first null data.
    if (!setDataArr[0].config.setValue) {
      for (i = 1; i < dataSetLen; i += 1) {
        setValue = setDataArr[i].config.setValue;
        if (setValue) {
          // Get the first valid value.
          plotY = setDataArr[i].config.plotY;
          break;
        }
      }
    } else {
      plotY = setDataArr[0].config.plotY;
    }
    isRally = !!setDataArr[0].config.isRally;
    // drawing starts with an initial half horizontal-shift
    crispY = Math.round(plotY) + thickness[isRally] % 2 / 2;
    if (isRally) {
      rallyPath.push(M, startX, crispY, H, plotX);
    } else {
      declinePath.push(M, startX, crispY, H, plotX);
    }

    (0, _lib.fcEach)(setDataArr, function (point, i) {
      point = point.config;
      dataObj = dataStore[i];
      config = dataObj.config;
      setValue = config.setValue;
      // looping to draw the plots
      nextPoint = setDataArr[i + 1] && setDataArr[i + 1].config || {};
      if (nextPoint) {
        path = [M, plotX, plotY];
        isRally = point.isRally;
        // if there is a shift corresponding to this point
        if (point.isShift) {
          plotX += pointDistance;
          plotY = point.graphY;
          path.push(H, plotX);
          path[2] = Math.round(path[2]) + thickness[isRally] % 2 / 2;
          path = path.toString();
          // draw the path
          if (isRally) {
            rallyPath.push(path);
          } else {
            declinePath.push(path);
          }
          path = [M, plotX, plotY];
        }
        // if there is a change in trend between the current and
        // the next points
        if (nextPoint.isChanged) {
          plotY = nextPoint.ty;
          path.push(V, plotY);
          path[1] = Math.round(path[1]) + thickness[isRally] % 2 / 2;
          path = path.toString();
          if (isRally) {
            rallyPath.push(path);
          } else {
            declinePath.push(path);
          }
          path = [M, plotX, plotY];
        }

        nextPointIsRally = nextPoint.isRally;
        // TODO: If path contains move to and line to at the same point line is not visible in
        //       native VML brewers need to remove this code when this issue in fixed in core.

        if (nextPoint.graphY !== path[2]) {
          path.push(V, nextPoint.graphY);
          path[1] = Math.round(path[1]) + thickness[nextPointIsRally] % 2 / 2;
          path = path.toString();
          if (nextPointIsRally) {
            rallyPath.push(path);
          } else {
            declinePath.push(path);
          }
        }
        // updating value
        plotY = nextPoint.graphY;
      }
      dataSet.parsePlotAttributes(dataObj, i);
    });

    for (i = 0; i < setDataArr.length; i++) {
      dataSet.parseLabelAttributes(dataStore[i], i);
    }
  };
  /**
   * Draw the plots of kagi chart
   *
   * @memberof KagiDataset
   */


  KagiDataset.prototype.drawPlots = function drawPlots() {
    var graphics = void 0,
        dataSet = this,
        datasetGraphics = dataSet.getGraphicalElement(),
        animationManager = dataSet.getFromEnv('animationManager'),
        conf = dataSet.config,

    // temp hardcoded.
    trackIndex = conf.trackIndex = {},
        dataSetComponents = dataSet.components,
        setDataArr = dataSetComponents.data,
        yPos = void 0,
        setElement = void 0,
        dataStore = dataSet.components.data,
        dataObj = void 0,
        hoverEffects = void 0,
        shadow = conf.shadow,
        anchorShadow = void 0,
        anchorProps = {},
        config = void 0,
        rallyThickness = conf.rallyThickness,
        declineThickness = conf.declineThickness,
        rallyAttr = {
      stroke: (0, _lib.toRaphaelColor)({
        color: conf.rallyColor,
        alpha: conf.rallyAlpha
      }),
      'stroke-linecap': ROUND,
      'stroke-linejoin': ROUND,
      'stroke-width': rallyThickness,
      'stroke-dasharray': conf.rallyDashed
    },
        declineAttr = {
      stroke: (0, _lib.toRaphaelColor)({
        color: conf.declineColor,
        alpha: conf.declineAlpha
      }),
      'stroke-linecap': ROUND,
      'stroke-linejoin': ROUND,
      'stroke-width': declineThickness,
      'stroke-dasharray': conf.declineDashed
    },
        rallyElemDummy = datasetGraphics.rallyElem,
        rallyElem = void 0,
        declineElemDummy = datasetGraphics.declineElem,
        declineElem = void 0,
        attr = void 0,
        commonElemGroup = dataSet.getContainer('commonElemsGroup'),
        plotGroup = dataSet.getContainer('plotGroup'),
        shadowGroup = dataSet.getContainer('shadowGroup'),
        imageElement = void 0;

    // save the world if no valid data is there.
    if (!setDataArr.length) {
      rallyElem && rallyElem.hide();
      declineElem && declineElem.hide();
      return;
    } else {
      rallyElem && rallyElem.show();
      declineElem && declineElem.show();
    }

    (0, _lib.fcEach)(setDataArr, function (point, i) {
      point = point.config;
      dataObj = dataStore[i];
      config = dataObj.config;
      graphics = dataObj.graphics;
      imageElement = graphics.image;
      hoverEffects = config.hoverEffects;
      yPos = dataObj._yPos;

      if (!trackIndex[point.plotX]) {
        trackIndex[point.plotX] = [];
      }
      trackIndex[point.plotX].push(i);
      dataObj._index = point.plotX;
      anchorProps = config.anchorProps;
      anchorShadow = anchorProps.shadow;

      if (yPos !== UNDEF && !isNaN(yPos) && point.isDefined) {
        if (anchorProps.imageUrl) {
          dataSet.drawAnchorImage(dataObj);
        } else {
          imageElement && imageElement.hide();
          setElement = graphics.element;
          attr = point.props.element.attr;

          // create/reuse setElement
          setElement = graphics.element = animationManager.setAnimation({
            el: setElement || 'polypath',
            attr: attr,
            container: plotGroup,
            component: dataSet,
            dom: 'anchor'
          });
          // Set properties to the data of element
          setElement.show().shadow(anchorShadow, shadowGroup).data('anchorRadius', anchorProps.radius).data('anchorHoverRadius', hoverEffects.anchorRadius).data('hoverEnabled', hoverEffects.enabled).data(EVENTARGS, point.eventArgs);
        }

        // Parsing cosmectics to be applied when element is hovered on.
        if (hoverEffects.enabled) {
          setElement && setElement.data('anchorRadius', anchorProps.radius).data('anchorHoverRadius', hoverEffects.anchorRadius).data('hoverEnabled', hoverEffects.enabled).data(SETROLLOVERATTR, hoverEffects.attrs[SETROLLOVERATTR]).data(SETROLLOUTATTR, hoverEffects.attrs[SETROLLOUTATTR]).data(EVENTARGS, point.eventArgs);
        }
      } else {
        graphics.element && graphics.element.hide();
        imageElement && imageElement.hide();
      }
    });

    // Create/reuse rally element
    rallyAttr.path = conf.rallyPath;
    rallyElem = animationManager.setAnimation({
      el: rallyElemDummy || 'path',
      attr: rallyAttr,
      container: commonElemGroup,
      component: dataSet,
      dom: 'line'
    });
    rallyElem.shadow(rallyThickness && shadow, shadowGroup);
    if (!rallyElemDummy) {
      dataSet.addGraphicalElement('rallyElem', rallyElem);
    }

    // create/reuse decline element
    declineAttr.path = conf.declinePath;
    declineElem = animationManager.setAnimation({
      el: declineElemDummy || 'path',
      attr: declineAttr,
      container: commonElemGroup,
      component: dataSet,
      dom: 'line'
    });
    declineElem.shadow(declineThickness && shadow, shadowGroup);
    if (!declineElemDummy) {
      dataSet.addGraphicalElement('declineElem', declineElem);
    }
  };

  return KagiDataset;
}(_line2['default']);

exports['default'] = KagiDataset;

/***/ }),

/***/ 829:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lineAnimation = __webpack_require__(25);

var _lineAnimation2 = _interopRequireDefault(_lineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.dataset.kagi': _lineAnimation2['default']['initial.dataset.line']
};

/***/ }),

/***/ 830:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(16);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _heatmap = __webpack_require__(831);

var _heatmap2 = _interopRequireDefault(_heatmap);

var _heatmap3 = __webpack_require__(833);

var _heatmap4 = _interopRequireDefault(_heatmap3);

var _categoryAxis = __webpack_require__(834);

var _categoryAxis2 = _interopRequireDefault(_categoryAxis);

var _multiseriesDataset = __webpack_require__(90);

var _multiseriesDataset2 = _interopRequireDefault(_multiseriesDataset);

var _colorrange = __webpack_require__(224);

var _colorrange2 = _interopRequireDefault(_colorrange);

var _legendmanager = __webpack_require__(225);

var _legendmanager2 = _interopRequireDefault(_legendmanager);

var _lib = __webpack_require__(5);

var _map = __webpack_require__(27);

var _map2 = _interopRequireDefault(_map);

var _filter = __webpack_require__(168);

var _filter2 = _interopRequireDefault(_filter);

var _indexOf = __webpack_require__(835);

var _indexOf2 = _interopRequireDefault(_indexOf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var defaultFontStr = _lib.preDefStr.defaultFontStr,
    divLineAlpha3DStr = _lib.preDefStr.divLineAlpha3DStr,
    divLineAlphaStr = _lib.preDefStr.divLineAlphaStr,
    altVGridColorStr = _lib.preDefStr.altVGridColorStr,
    altVGridAlphaStr = _lib.preDefStr.altVGridAlphaStr,
    altHGridColorStr = _lib.preDefStr.altHGridColorStr,
    altHGridAlphaStr = _lib.preDefStr.altHGridAlphaStr,
    colorStrings = _lib.preDefStr.colors,
    COLOR_000000 = colorStrings.c000000,
    UNDEFINED = void 0;

var HeatMap = function (_MSCartesian) {
  _inherits(HeatMap, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  HeatMap.getName = function getName() {
    return 'HeatMap';
  };

  function HeatMap() {
    _classCallCheck(this, HeatMap);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.tooltipsepchar = ' = ';
    _this.hasGradientLegend = true;

    _this.registerFactory('axis', _categoryAxis2['default'], ['canvas']);
    // decide and create legend after creating canvas
    _this.registerFactory('legend-decider', _legendmanager2['default'], ['canvas']);

    // create color manager after creating legend-decider
    _this.registerFactory('colormanager-decider', _colorrange2['default'], ['legend-decider']);

    // create dataset after creating colormanager-decider and vCanvas
    _this.registerFactory('dataset', _multiseriesDataset2['default'], ['colormanager-decider', 'vCanvas']);
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  HeatMap.prototype.getName = function getName() {
    return 'HeatMap';
  };

  HeatMap.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.isSingleSeries = true;
    config.friendlyName = 'Heatmap Chart';
    config.hasLegend = true;
    config.defaultDatasetType = 'heatmap';
    config.enablemousetracking = true;
  };
  /**
   * function to check if the chart specific data is proper is not
   * this fn is define for specific chart types
   * @return {boolean} if JSON data is valid or not
   */


  HeatMap.prototype._checkInvalidSpecificData = function _checkInvalidSpecificData() {
    var jsonData = this.getFromEnv('dataSource'),
        datasetsJSON = jsonData.dataset;
    if (!datasetsJSON) {
      return true;
    }
  };

  /**
   * Parse the chart attributes and store in chart's config
   * @param {Object} dataObj User input json
   */


  HeatMap.prototype.parseChartAttr = function parseChartAttr(dataObj) {
    _MSCartesian.prototype.parseChartAttr.call(this, dataObj);
    this.config.drawTrendRegion = 0;
  };

  HeatMap.prototype.configureAttributes = function configureAttributes(dataObj) {
    var iapi = this,
        chartConfig = iapi.config,
        dataSource = iapi.getFromEnv('dataSource'),
        skipConfigureIteration = iapi.config.skipConfigureIteration = {},
        rows,
        columns,
        datasetArray = dataObj.dataset,
        unifiedDataset = [],
        toolTipController;
    rows = dataSource.rows && _filter2['default'].call(dataSource.rows.row, function (item) {
      return item.id !== '';
    });
    columns = dataSource.columns && _filter2['default'].call(dataSource.columns.column, function (item) {
      return item.id !== '';
    });
    if (!rows || !columns) {
      // create unified dataset
      for (var i = 0; i < datasetArray.length; i++) {
        for (var j = 0; j < datasetArray[i].data.length; j++) {
          unifiedDataset.push(datasetArray[i].data[j]);
        }
      }
      if (!rows) {
        // get unique rows by rowid property
        rows = _filter2['default'].call(_map2['default'].call(unifiedDataset, function (item) {
          return item.rowid;
        }), function (value, index, self) {
          return _indexOf2['default'].call(self, value) === index;
        });
      }
      if (!columns) {
        // get unique columns by columnid property
        columns = _filter2['default'].call(_map2['default'].call(unifiedDataset, function (item) {
          return item.columnid;
        }), function (value, index, self) {
          return _indexOf2['default'].call(self, value) === index;
        });
      }
    }
    iapi.parseChartAttr(dataObj);

    iapi.addToEnv('chartColorRange', dataObj.colorrange || {});

    iapi.createComponent(dataObj);

    iapi._feedAxesRawData();
    skipConfigureIteration.axis = true;
    iapi.addToEnv('totalRows', rows.length);
    iapi.addToEnv('totalColumns', columns.length);

    iapi._createToolBox();
    skipConfigureIteration.toolbar = true; // Mark this as true to prevent configuration from configureChildren fn.

    iapi.configureChildren();
    // after configure chart calls its async draw
    iapi.asyncDraw();
    toolTipController = iapi.getFromEnv('toolTipController');
    toolTipController.setStyle({ 'bgColor': (0, _lib.convertColor)(chartConfig.tooltipbgcolor || 'EEE', chartConfig.tooltipbgalpha || 100),
      'rawBgColor': (chartConfig.tooltipbgcolor || 'EEE').replace(/^#?([a-f0-9]+)/ig, '#$1'),
      'fontColor': (chartConfig.tooltipcolor || chartConfig.basefontcolor || '000').replace(/^#?([a-f0-9]+)/ig, '#$1'),
      'borderColor': (0, _lib.convertColor)(chartConfig.tooltipbordercolor || '666', chartConfig.tooltipborderalpha || 100),
      'rawBorderColor': (chartConfig.tooltipbordercolor || '666').replace(/^#?([a-f0-9]+)/ig, '#$1'),
      'bgAlpha': (0, _lib.pluckNumber)(chartConfig.tooltipbgalpha, 100),
      'borderThickness': (0, _lib.pluckNumber)(chartConfig.tooltipborderthickness, 1),
      'showToolTipShadow': (0, _lib.pluckNumber)(chartConfig.showtooltipshadow || 0),
      'borderRadius': (0, _lib.pluckNumber)(chartConfig.tooltipborderradius, 0),
      'font-size': chartConfig.basefontsize || 10,
      'font-family': chartConfig.basefont || iapi.getFromEnv('style').inCanfontFamily,
      'padding': (0, _lib.pluckNumber)(chartConfig.tooltippadding || 3),
      'borderAlpha': (0, _lib.pluckNumber)(chartConfig.tooltipborderalpha, 100) });
  };

  HeatMap.prototype._postSpaceManagement = function _postSpaceManagement() {
    var iapi = this,
        config = iapi.config,
        placeAxisLabelsOnTop = config.placeAxisLabelsOnTop,
        xAxis = iapi.getChildren('xAxis')[0],
        yAxis = iapi.getChildren('yAxis')[0],
        legend = iapi.getFromEnv('legend'),
        xDepth = config.xDepth,
        canvas = iapi.getChildren('canvas')[0],
        canvasConfig = canvas.config,
        canvasBorderWidth = canvasConfig.canvasBorderWidth;

    xAxis && xAxis.setAxisDimention({
      x: config.canvasLeft,
      y: placeAxisLabelsOnTop ? config.canvasTop + (config.shift || 0) - canvasBorderWidth : config.canvasBottom + (config.shift || 0) + canvasBorderWidth,
      opposite: config.canvasTop - canvasBorderWidth,
      axisLength: config.canvasWidth
    });
    yAxis && yAxis.setAxisDimention({
      x: config.canvasLeft - canvasBorderWidth,
      y: config.canvasTop,
      opposite: config.canvasRight + canvasBorderWidth,
      axisLength: config.canvasHeight
    });

    xAxis && xAxis.shiftLabels(-xDepth, 0);
    legend && legend.postSpaceManager();
    // Setting the number of columns to be displayed based on numdisplaysets.
    iapi.config.realtimeEnabled && iapi._setRealTimeCategories && iapi._setRealTimeCategories();
    // function for adjusting value padding depending upon data and axis labels.
    // canvas.setCanvasPadding();
    iapi.setAxisDimention();
  };

  HeatMap.prototype._feedAxesRawData = function _feedAxesRawData() {
    var iapi = this,
        colorM = iapi.getFromEnv('color-manager'),
        dataObj = iapi.getFromEnv('dataSource'),
        chartAttrs = dataObj.chart,
        xAxisConf,
        yAxisConf,
        is3D = iapi.config.is3D,
        palleteString = is3D ? _lib.chartPaletteStr.chart3D : _lib.chartPaletteStr.chart2D;

    xAxisConf = {
      isVertical: false,
      isReverse: false,
      isOpposit: !!iapi.config.placeAxisLabelsOnTop,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, defaultFontStr),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#?([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.xaxisnamepadding,
      axisValuePadding: chartAttrs.labelpadding,
      axisNameFont: chartAttrs.xaxisnamefont,
      axisNameFontSize: chartAttrs.xaxisnamefontsize,
      axisNameFontColor: chartAttrs.xaxisnamefontcolor,
      axisNameFontBold: chartAttrs.xaxisnamefontbold,
      axisNameFontItalic: chartAttrs.xaxisnamefontitalic,
      axisNameBgColor: chartAttrs.xaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.xaxisnamebordercolor,
      axisNameAlpha: chartAttrs.xaxisnamealpha,
      axisNameFontAlpha: chartAttrs.xaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.xaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.xaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.xaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.xaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.xaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.xaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.xaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.xaxisnameborderdashgap,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      divLineColor: (0, _lib.pluck)(chartAttrs.vdivlinecolor, chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.vdivlinealpha, chartAttrs.divlinealpha, is3D ? colorM.getColor(divLineAlpha3DStr) : colorM.getColor(divLineAlphaStr)),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.vdivlinethickness, chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.vdivlinedashed, chartAttrs.vdivlineisdashed, chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashlen, chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashgap, chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatevgridcolor, 0),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatevgridcolor, colorM.getColor(altVGridColorStr)),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatevgridalpha, colorM.getColor(altVGridAlphaStr)),
      numDivLines: chartAttrs.numvdivlines,
      labelFont: chartAttrs.labelfont,
      labelFontSize: chartAttrs.labelfontsize,
      labelFontColor: chartAttrs.labelfontcolor,
      labelFontAlpha: chartAttrs.labelalpha,
      labelFontBold: chartAttrs.labelfontbold,
      labelFontItalic: chartAttrs.labelfontitalic,
      axisName: chartAttrs.xaxisname,
      axisMinValue: chartAttrs.xaxisminvalue,
      axisMaxValue: chartAttrs.xaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptivexmin,
      adjustDiv: chartAttrs.adjustvdiv,
      labelDisplay: chartAttrs.labeldisplay,
      showLabels: (0, _lib.pluckNumber)(chartAttrs.showxaxislabels, chartAttrs.showlabels),
      rotateLabels: chartAttrs.rotatexaxislabels,
      slantLabel: (0, _lib.pluckNumber)(chartAttrs.slantlabels, chartAttrs.slantlabel),
      labelStep: (0, _lib.pluckNumber)(chartAttrs.labelstep, chartAttrs.xaxisvaluesstep),
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showxaxisvalues, chartAttrs.showxaxisvalue),
      maxLabelHeight: chartAttrs.maxlabelheight,
      // showLimits: chartAttrs.showvlimits,
      // showDivLineValues: pluckNumber(chartAttrs.showvdivlinevalues, chartAttrs.showvdivlinevalues),
      showZeroPlane: chartAttrs.showvzeroplane,
      zeroPlaneColor: chartAttrs.vzeroplanecolor,
      zeroPlaneThickness: chartAttrs.vzeroplanethickness,
      zeroPlaneAlpha: chartAttrs.vzeroplanealpha,
      showZeroPlaneValue: chartAttrs.showvzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showxaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.xaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.xaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.xaxislinecolor, chartAttrs.axislinecolor, COLOR_000000)
    };
    yAxisConf = {
      isVertical: true,
      isReverse: false,
      isOpposit: false,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, defaultFontStr),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#?([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.yaxisnamepadding,
      axisValuePadding: chartAttrs.yaxisvaluespadding,
      axisNameFont: chartAttrs.yaxisnamefont,
      axisNameFontSize: chartAttrs.yaxisnamefontsize,
      axisNameFontColor: chartAttrs.yaxisnamefontcolor,
      axisNameFontBold: chartAttrs.yaxisnamefontbold,
      axisNameFontItalic: chartAttrs.yaxisnamefontitalic,
      axisNameBgColor: chartAttrs.yaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.yaxisnamebordercolor,
      axisNameAlpha: chartAttrs.yaxisnamealpha,
      axisNameFontAlpha: chartAttrs.yaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.yaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.yaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.yaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.yaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.yaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.yaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.yaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.yaxisnameborderdashgap,
      axisNameWidth: chartAttrs.yaxisnamewidth,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      rotateAxisName: (0, _lib.pluckNumber)(chartAttrs.rotateyaxisname, 1),
      axisName: chartAttrs.yaxisname,
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatehgridcolor, 1),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatehgridcolor, colorM.getColor(altHGridColorStr)),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatehgridalpha, colorM.getColor(altHGridAlphaStr)),
      numDivLines: chartAttrs.numdivlines,
      axisMinValue: chartAttrs.yaxisminvalue,
      axisMaxValue: chartAttrs.yaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptiveymin,
      adjustDiv: chartAttrs.adjustdiv,
      labelStep: chartAttrs.yaxisvaluesstep,
      showLabels: (0, _lib.pluckNumber)(chartAttrs.showyaxislabels, chartAttrs.showlabels),
      maxLabelWidthPercent: chartAttrs.maxlabelwidthpercent,
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue),
      divLineColor: (0, _lib.pluck)(chartAttrs.hdivlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.hdivlinealpha, colorM.getColor(divLineAlphaStr)),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.hdivlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.hdivlinedashed, chartAttrs.hdivlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.hdivlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.hdivlinedashgap, 2),
      // showLimits: chartAttrs.showlimits,
      // showDivLineValues: pluckNumber(chartAttrs.showdivlinevalues, chartAttrs.showdivlinevalue),
      showZeroPlane: chartAttrs.showzeroplane,
      zeroPlaneColor: chartAttrs.zeroplanecolor,
      zeroPlaneThickness: chartAttrs.zeroplanethickness,
      zeroPlaneAlpha: chartAttrs.zeroplanealpha,
      showZeroPlaneValue: chartAttrs.showzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showyaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.yaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.yaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.yaxislinecolor, chartAttrs.axislinecolor, COLOR_000000)
    };
    xAxisConf.vtrendlines = dataObj.vtrendlines;
    yAxisConf.trendlines = dataObj.trendlines;
    return {
      yAxisConf: [yAxisConf],
      xAxisConf: [xAxisConf]
    };
  };

  HeatMap.prototype._setCategories = function _setCategories() {
    var iapi = this,
        dataObj = iapi.getFromEnv('dataSource'),
        xAxis = iapi.getChildren('xAxis'),
        yAxis = iapi.getChildren('yAxis'),
        len,
        i,
        k,
        columnObj,
        rowObj,
        columns,
        rows,
        columnArr = [],
        rowArr = [],
        columnFlag,
        rowFlag,
        j;

    if (!dataObj.columns || !dataObj.rows) {
      dataObj.columns = {};
      dataObj.columns.column = columns = [];

      dataObj.rows = {};
      dataObj.rows.row = rows = [];

      for (k = 0; k < (dataObj.dataset && dataObj.dataset.length); k++) {
        len = dataObj.dataset && dataObj.dataset[k].data && dataObj.dataset[k].data.length;
        for (i = 0; i < len; i++) {
          columnFlag = true;
          rowFlag = true;

          for (j = 0; j < columns.length; j++) {
            if (dataObj.dataset[k].data[i].columnid == columns[j].id) {
              columnFlag = false;
            }
          }
          if (columnFlag) {
            columnObj = {
              id: dataObj.dataset[k].data[i].columnid,
              label: dataObj.dataset[k].data[i].columnid
            };
            dataObj.columns.column.push(columnObj);
          }

          for (j = 0; j < rows.length; j++) {
            if (dataObj.dataset[k].data[i].rowid == rows[j].id) {
              rowFlag = false;
            }
          }
          if (rowFlag) {
            rowObj = {
              id: dataObj.dataset[k].data[i].rowid,
              label: dataObj.dataset[k].data[i].rowid
            };
            dataObj.rows.row.push(rowObj);
          }
        }
      }
    }

    columns = dataObj.columns.column;
    rows = dataObj.rows.row;

    for (i = 0; i < (columns && columns.length); i++) {
      columns[i].label = (0, _lib.pluck)(columns[i].label, columns[i].name, columns[i].id);
      columns[i].label !== UNDEFINED && columnArr.push(columns[i]);
    }
    dataObj.columns.column = columnArr;

    for (i = 0; i < (rows && rows.length); i++) {
      rows[i].label = (0, _lib.pluck)(rows[i].label, rows[i].name, rows[i].id);
      rows[i].label !== UNDEFINED && rowArr.push(rows[i]);
    }
    dataObj.rows.row = rowArr;

    // dataObj.columns && xAxis[0].setAxisPadding(0.5, 0.5);
    dataObj.columns && xAxis[0].setTickValues(dataObj.columns.column);

    // dataObj.columns && yAxis[0].setAxisPadding(0.5, 0.5);
    dataObj.rows && yAxis[0].setTickValues(dataObj.rows.row);

    xAxis[0].setAxisConfig({
      categoryNumDivLines: dataObj.columns.column.length - 1,
      categoryDivLinesFromZero: 0,
      showAlternateGridColor: 0
    });

    yAxis[0].setAxisConfig({
      categoryNumDivLines: dataObj.rows.row.length - 1,
      categoryDivLinesFromZero: 0,
      showAlternateGridColor: 0
    });
  };

  HeatMap.prototype.getDSdef = function getDSdef() {
    return _heatmap2['default'];
  };

  HeatMap.prototype.getDSGroupdef = function getDSGroupdef() {
    return _heatmap4['default'];
  };

  return HeatMap;
}(_fusioncharts2['default']);

exports['default'] = HeatMap;

/***/ }),

/***/ 831:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _stringify = __webpack_require__(36);

var _stringify2 = _interopRequireDefault(_stringify);

var _componentInterface = __webpack_require__(7);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _heatmapAnimation = __webpack_require__(832);

var _heatmapAnimation2 = _interopRequireDefault(_heatmapAnimation);

var _schedular = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var HUNDREDSTRING = '100',
    PLOTGRADIENTCOLOR = 'plotGradientColor',
    PLOTBORDERCOLOR = 'plotBorderColor',
    COLOR_FFFFFF = 'FFFFFF',
    SHOWSHADOW = 'showShadow',
    UNDEF = void 0,
    MOUSEOVER = 'mouseOver',
    MOUSEOUT = 'mouseOut',
    NORMAL = 'normal',
    convertColor = _lib.graphics.convertColor,
    PXSTRING = 'px',
    pStr = _lib.preDefStr.pStr,
    sStr = _lib.preDefStr.sStr,
    COMMA = ',',
    BOLDSTARTTAG = '<b>',
    BOLDENDTAG = '</b>',
    BREAKSTRING = '<br />',
    getLightColor = _lib.graphics.getLightColor,
    getColumnColor = _lib.graphics.getColumnColor,
    visibleStr = 'visible',
    miterStr = _lib.preDefStr.miterStr,
    hiddenStr = _lib.preDefStr.hiddenStr,
    showHoverEffectStr = _lib.preDefStr.showHoverEffectStr,
    POSITION_START = _lib.preDefStr.POSITION_START,
    POSITION_TOP = _lib.preDefStr.POSITION_TOP,
    POSITION_END = _lib.preDefStr.POSITION_END,
    POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
    SETROLLOVERATTR = 'setRolloverAttr',
    SETROLLOUTATTR = 'setRolloutAttr',
    EVENTARGS = 'eventArgs',
    POINTER = 'pointer',
    tlLabelStr = 'tlLabel',
    blLabelStr = 'blLabel',
    trLabelStr = 'trLabel',
    brLabelStr = 'brLabel',
    ROLLOVER = 'DataPlotRollOver',
    ROLLOUT = 'DataPlotRollOut',
    DEFAULT_CURSOR = _lib.preDefStr.DEFAULT,
    defined = function defined(obj) {
  return obj !== UNDEF && obj !== null;
},

/**
 * Helper function to create a RedRaphael group.
 * @param  {Object} attr  Attributes to be applied to the group
 * @param  {Element} parentContainer         The parent container in which the group will be appended.
 * @param {Object} dataset The concerned dataset
 * @return {Element}                         The group that was created.
 */
createGroup = function createGroup(attr, parentContainer, dataset) {
  var animationManager = dataset.getFromEnv('animationManager');
  return animationManager.setAnimation({
    el: 'group',
    attr: attr,
    container: parentContainer,
    component: dataset,
    dom: 'group'
  });
},
    TRACKER_FILL = 'rgba(192,192,192,' + (_lib.isIE ? 0.002 : 0.000001) + ')',
    // invisible but clickable
HTP = _lib.hasTouch ? _lib.TOUCH_THRESHOLD_PIXELS : _lib.CLICK_THRESHOLD_PIXELS,
    pInt = function pInt(s, mag) {
  return parseInt(s, mag || 10);
},
    NONE = 'none',
    removePlot = function removePlot(plotObject) {
  /**
   * This function takes a plot object and removes all the properties.
   * Before removing the plot object the graphic elements are disposed first.
   */
  return function () {
    var objectIterator = void 0,
        graphicObject = void 0,
        graphicIterator = void 0;
    // All the properties of plotObject are removed
    for (objectIterator in plotObject) {
      // In case of graphics property remove all the graphics elements first, then remove the property.
      if (objectIterator === 'graphics') {
        graphicObject = plotObject[objectIterator];
        for (graphicIterator in graphicObject) {
          graphicObject[graphicIterator].remove();
        }
      }
      delete plotObject[objectIterator];
    }
  };
},
    _rolloverResponseSetter = function _rolloverResponseSetter(chart, data, event, onlyHoverEffect, dataset) {
  var dataGraphics = data.graphics,
      animationManager = chart.getFromEnv('animationManager'),
      elem = dataGraphics && dataGraphics.element,
      elData = elem && elem.getData();
  // Check whether the plot is in dragged state or not if
  // drag then dont fire rolloverevent
  if (elData.draged !== true) {
    animationManager.setAnimationState(MOUSEOVER);
    elem && elData.showHoverEffect !== 0 && animationManager.setAnimation({
      el: elem,
      attr: elem.getData().setRolloverAttr,
      component: dataset
    });
    !onlyHoverEffect && elem && _lib.plotEventHandler.call(elem, chart, event, ROLLOVER);
  }
},
    _rolloutResponseSetter = function _rolloutResponseSetter(chart, data, event, onlyHoverEffect, dataset) {
  var dataGraphics = data.graphics,
      animationManager = chart.getFromEnv('animationManager'),
      elem = dataGraphics && dataGraphics.element,
      elData = elem && elem.getData();
  // Check whether the plot is in draggedstate or not if drag then dont fire rolloutevent
  if (elData.draged !== true) {
    animationManager.setAnimationState(MOUSEOUT);
    elem && elData.showHoverEffect !== 0 && animationManager.setAnimation({
      el: elem,
      attr: elem.getData().setRolloutAttr,
      component: dataset
    });
    !onlyHoverEffect && elem && _lib.plotEventHandler.call(elem, chart, event, ROLLOUT);
  }
},
    mathMax = Math.max,
    mathMin = Math.min,
    mathAbs = Math.abs;
(0, _dependencyManager.addDep)({
  name: 'heatmapAnimation',
  type: 'animationRule',
  extension: _heatmapAnimation2['default']
});

var HeatMapDataset = function (_ComponentInterface) {
  _inherits(HeatMapDataset, _ComponentInterface);

  function HeatMapDataset() {
    _classCallCheck(this, HeatMapDataset);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.components = {};
    _this.graphics = {};
    _this.dataSetArray = [];
    // this.getDataLimits = null;
    return _this;
  }
  /**
   * Sets the type of the component
   * @return {string} type
   */


  HeatMapDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  HeatMapDataset.prototype.getName = function getName() {
    return 'heatMap';
  };
  /**
   * Configures the cosmetic of dataset
   * Creates the empty plotGrid array
   * Calculates the dataset min and max value
   * @param {Object} datasetJSON data array containing data information
   */


  HeatMapDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.config.JSONData = datasetJSON;

    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = dataSet.getFromEnv('chartConfig'),
        style = chartConfig.style,
        conf = dataSet.config,
        JSONData = conf.JSONData,
        setDataArr = JSONData.data,
        singleSeries = chart.config.singleseries,
        len = setDataArr && setDataArr.length,
        chartAttr = dataSet.getFromEnv('chart-attrib'),
        colorM = dataSet.getFromEnv('color-manager'),
        index = dataSet.index || dataSet.positionIndex,
        showplotborder,
        plotColor = conf.plotColor = colorM.getPlotColor(index),
        plotBorderDash = (0, _lib.pluckNumber)(JSONData.dashed, chartAttr.plotborderdashed),
        tempPlotfillAngle,
        plotDashLen,
        plotDashGap,
        isRoundEdges,
        plotfillAngle,
        plotFillAlpha,
        plotBorderAlpha,
        initailPlotBorderDashStyle,
        setData,
        setValue,
        dataObj,
        config,
        dataStore = dataSet.components.data,
        plotGrid = dataSet.components.plotGrid = [],
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        toolTipValue,
        setDisplayValue,
        isBar = chart.isBar,
        is3D = chart.config.is3D,
        enableAnimation,
        parentYAxis,
        setDataDashed,
        setDataPlotDashLen,
        setDataPlotDashGap,
        i,
        r,
        c,
        maxValue = -Infinity,
        minValue = +Infinity,
        font,
        fontSize,
        fontColor,
        fontWeight,
        fontStyle,
        totalRows = dataSet.getFromEnv('totalRows'),
        totalColumns = dataSet.getFromEnv('totalColumns');

    for (r = 0; r < totalRows; r++) {
      plotGrid.push([]);
      for (c = 0; c < totalColumns; c++) {
        plotGrid[r].push([]);
      }
    }
    dataSet.setState('visible', (0, _lib.pluckNumber)(dataSet.getState('visible'), dataSet.config.JSONData.visible, !Number(dataSet.config.JSONData.initiallyhidden), 1) === 1);
    showplotborder = conf.showplotborder = (0, _lib.pluckNumber)(chartAttr.showplotborder, is3D ? 0 : 1);
    conf.plotDashLen = plotDashLen = (0, _lib.pluckNumber)(chartAttr.plotborderdashlen, 5);
    conf.plotDashGap = plotDashGap = (0, _lib.pluckNumber)(chartAttr.plotborderdashgap, 4);
    conf.plotfillAngle = plotfillAngle = (0, _lib.pluckNumber)(360 - chartAttr.plotfillangle, isBar ? 180 : 90);
    conf.plotFillAlpha = plotFillAlpha = (0, _lib.pluck)(JSONData.alpha, chartAttr.plotfillalpha, HUNDREDSTRING);
    conf.plotColor = plotColor = (0, _lib.pluck)(JSONData.color, plotColor);
    conf.isRoundEdges = isRoundEdges = (0, _lib.pluckNumber)(chartAttr.useroundedges, 0);
    conf.plotRadius = (0, _lib.pluckNumber)(chartAttr.useRoundEdges, conf.isRoundEdges ? 1 : 0);
    conf.plotFillRatio = (0, _lib.pluck)(JSONData.ratio, chartAttr.plotfillratio);
    conf.plotgradientcolor = (0, _lib.getDefinedColor)(chartAttr.plotgradientcolor, colorM.getColor(PLOTGRADIENTCOLOR));
    // !usePlotGradientColor && (plotgradientcolor = BLANKSTRING);
    conf.plotBorderAlpha = plotBorderAlpha = showplotborder ? (0, _lib.pluck)(chartAttr.plotborderalpha, plotFillAlpha, HUNDREDSTRING) : 0;
    conf.plotBorderColor = (0, _lib.pluck)(chartAttr.plotbordercolor, is3D ? COLOR_FFFFFF : colorM.getColor(PLOTBORDERCOLOR));
    conf.plotBorderThickness = (0, _lib.pluckNumber)(chartAttr.plotborderthickness, 1);
    conf.plotBorderDashStyle = initailPlotBorderDashStyle = plotBorderDash ? (0, _lib.getDashStyle)(plotDashLen, plotDashGap) : NONE;
    conf.showValues = (0, _lib.pluckNumber)(JSONData.showvalues, chartAttr.showvalues, 1);
    conf.valuePadding = (0, _lib.pluckNumber)(chartAttr.valuepadding, 2);
    conf.enableAnimation = enableAnimation = (0, _lib.pluckNumber)(chartAttr.animation, chartAttr.defaultanimation, 1);
    conf.animation = !enableAnimation ? false : {
      duration: (0, _lib.pluckNumber)(chartAttr.animationduration, 1) * 1000
    };
    conf.transposeAnimation = (0, _lib.pluckNumber)(chartAttr.transposeanimation, enableAnimation);
    conf.transposeAnimDuration = (0, _lib.pluckNumber)(chartAttr.transposeanimduration, 0.2) * 1000;

    conf.showShadow = isRoundEdges || is3D ? (0, _lib.pluckNumber)(chartAttr.showshadow, 1) : (0, _lib.pluckNumber)(chartAttr.showshadow, colorM.getColor(SHOWSHADOW));
    conf.showHoverEffect = (0, _lib.pluckNumber)(chartAttr.plothovereffect, chartAttr.showhovereffect, UNDEF);
    conf.showTooltip = (0, _lib.pluckNumber)(chartAttr.showtooltip, 1);
    conf.definedGroupPadding = Math.max((0, _lib.pluckNumber)(chartAttr.plotspacepercent), 0);
    conf.plotSpacePercent = Math.max((0, _lib.pluckNumber)(chartAttr.plotspacepercent, 20) % 100, 0);
    conf.maxColWidth = (0, _lib.pluckNumber)(isBar ? chartAttr.maxbarheight : chartAttr.maxcolwidth, 50);
    conf.plotPaddingPercent = (0, _lib.pluckNumber)(chartAttr.plotpaddingpercent);
    conf.rotateValues = (0, _lib.pluckNumber)(chartAttr.rotatevalues) ? 270 : 0;
    conf.placeValuesInside = (0, _lib.pluckNumber)(chartAttr.placevaluesinside, 0);
    conf.defaultPadding = {
      left: 0.5,
      right: 0.5,
      top: 0.5,
      bottom: 0.5
    };

    font = style.inCanfontFamily;
    fontSize = pInt(style.inCanfontSize, 10);
    fontColor = style.inCancolor;
    fontWeight = NORMAL;
    fontStyle = NORMAL;

    conf.tlLabelStyle = {
      fontFamily: (0, _lib.pluck)(chartAttr.tlfont, font),
      fontSize: (0, _lib.pluckNumber)(chartAttr.tlfontsize, fontSize) + PXSTRING,
      color: convertColor((0, _lib.pluck)(chartAttr.tlfontcolor, fontColor), 100),
      fontWeight: fontWeight,
      fontStyle: fontStyle
    };

    (0, _lib.setLineHeight)(conf.tlLabelStyle);

    conf.trLabelStyle = {
      fontFamily: (0, _lib.pluck)(chartAttr.trfont, font),
      fontSize: (0, _lib.pluckNumber)(chartAttr.trfontsize, fontSize) + PXSTRING,
      color: convertColor((0, _lib.pluck)(chartAttr.trfontcolor, fontColor), 100),
      fontWeight: fontWeight,
      fontStyle: fontStyle
    };

    conf.brLabelStyle = {
      fontFamily: (0, _lib.pluck)(chartAttr.brfont, font),
      fontSize: (0, _lib.pluckNumber)(chartAttr.brfontsize, fontSize) + PXSTRING,
      color: convertColor((0, _lib.pluck)(chartAttr.brfontcolor, fontColor), 100),
      fontWeight: fontWeight,
      fontStyle: fontStyle
    };

    conf.blLabelStyle = {
      fontFamily: (0, _lib.pluck)(chartAttr.blfont, font),
      fontSize: (0, _lib.pluckNumber)(chartAttr.blfontsize, fontSize) + PXSTRING,
      color: convertColor((0, _lib.pluck)(chartAttr.blfontcolor, fontColor), 100),
      fontWeight: fontWeight,
      fontStyle: fontStyle
    };

    conf.use3DLighting = (0, _lib.pluckNumber)(chartAttr.use3dlighting, 1);
    conf.parentYAxis = parentYAxis = (0, _lib.pluck)(JSONData.parentyaxis && JSONData.parentyaxis.toLowerCase(), pStr) === sStr ? 1 : 0;
    if (!dataStore) {
      dataStore = dataSet.components.data = [];
    }

    // Parsing the attributes and values at set level.
    for (i = 0; i < len; i++) {
      setData = setDataArr && setDataArr[i];
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (!dataObj) {
        dataObj = dataStore[i] = {
          graphics: {}
        };
      }

      if (!dataObj.config) {
        config = dataStore[i].config = {};
      }

      config.showValue = (0, _lib.pluckNumber)(setData.showvalue, conf.showValues);
      config.setValue = setValue = numberFormatter.getCleanValue(setData.value);
      config.setLink = (0, _lib.pluck)(setData.link);
      config.toolTipValue = toolTipValue = numberFormatter.dataLabels(setValue, parentYAxis);
      config.setDisplayValue = setDisplayValue = (0, _lib.parseUnsafeString)(setData.displayvalue);
      config.displayValue = (0, _lib.pluck)(setDisplayValue, toolTipValue);
      setDataDashed = (0, _lib.pluckNumber)(setData.dashed);
      setDataPlotDashLen = (0, _lib.pluckNumber)(setData.dashlen, plotDashLen);
      setDataPlotDashGap = plotDashGap = (0, _lib.pluckNumber)(setData.dashgap, plotDashGap);

      maxValue = Math.max(maxValue, setValue);
      minValue = Math.min(minValue, setValue);

      config.plotBorderDashStyle = setDataDashed === 1 ? (0, _lib.getDashStyle)(setDataPlotDashLen, setDataPlotDashGap) : setDataDashed === 0 ? NONE : initailPlotBorderDashStyle;
      if (singleSeries) {
        plotColor = colorM.getPlotColor(i);
        plotColor = (0, _lib.pluck)(setData.color, plotColor);
        // plotFillRatio = pluck(setData.ratio, conf.plotFillRatio);
      } else {
        plotColor = (0, _lib.pluck)(setData.color, conf.plotColor);
      }
      config.plotFillAlpha = plotFillAlpha = (0, _lib.pluck)(setData.alpha, conf.plotFillAlpha);

      // Setting the angle for plot fill for negative data
      if (setValue < 0 && !isRoundEdges) {
        tempPlotfillAngle = plotfillAngle;
        plotfillAngle = isBar ? 180 - plotfillAngle : 360 - plotfillAngle;
      }
      config.colorArr = getColumnColor(plotColor + COMMA + conf.plotgradientcolor, plotFillAlpha, conf.plotFillRatio, plotfillAngle, isRoundEdges, conf.plotBorderColor, plotBorderAlpha.toString(), isBar ? 1 : 0, !!is3D);

      tempPlotfillAngle && (plotfillAngle = tempPlotfillAngle);
      conf.plotfillAngle = plotfillAngle;
    }

    conf.maxValue = maxValue;
    conf.minValue = minValue;

    dataSet._setConfigure();
    dataSet.setState('dirty', true);
  };
  /**
   * Attaches legendUpdate event listener to dataset which decides whether to
   * show/hide particular data in dataset.
   * Sets the color configuration for each data objects present in dataset.
   */


  HeatMapDataset.prototype._setConfigure = function _setConfigure() {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        JSONData = dataSet.config.JSONData,
        setDataArr = JSONData.data,
        len = setDataArr && setDataArr.length,
        chartAttr = dataSet.getFromEnv('chart-attrib'),
        colorM = dataSet.getFromEnv('color-manager'),
        index = dataSet.index || dataSet.positionIndex,
        showplotborder = conf.showplotborder,
        plotColor = conf.plotColor = colorM.getPlotColor(index),
        showTooltip = (0, _lib.pluckNumber)(chartAttr.showtooltip, 1),
        yAxisName = (0, _lib.parseUnsafeString)(chartAttr.yaxisname),
        xAxisName = (0, _lib.parseUnsafeString)(chartAttr.xaxisname),
        tooltipSepChar = (0, _lib.parseUnsafeString)((0, _lib.pluck)(chartAttr.tooltipsepchar, ': ')),
        usePlotGradientColor = (0, _lib.pluckNumber)(chartAttr.useplotgradientcolor, 1),
        formatedVal,
        parserConfig,
        setTooltext,
        macroIndices,
        toolText,
        plotDashLen = conf.plotDashLen,
        plotDashGap = conf.plotDashGap,
        plotBorderThickness = conf.plotBorderThickness,
        isRoundEdges = conf.isRoundEdges,
        showHoverEffect = conf.showHoverEffect,
        plotfillAngle = conf.plotfillAngle,
        plotFillAlpha = conf.plotFillAlpha,
        plotFillRatio = conf.plotFillRatio,
        plotBorderAlpha = conf.plotBorderAlpha,
        plotBorderColor = conf.plotBorderColor,
        plotBorderDashStyle,
        setData,
        setValue,
        dataObj,
        config,
        colorRange = dataSet.getFromEnv('chartColorRange'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis'),
        column,
        row,
        mapByPercent = conf.mapByPercent = (0, _lib.pluckNumber)(colorRange.mapbypercent, 0),
        mapByCategory = conf.mapByCategory = (0, _lib.pluckNumber)(chartAttr.mapbycategory, 0),
        useColorGradient = colorRange && (0, _lib.pluckNumber)(colorRange.gradient),
        hoverColor,
        hoverAlpha,
        hoverGradientColor,
        hoverRatio,
        hoverAngle,
        hoverBorderColor,
        hoverBorderAlpha,
        hoverBorderThickness,
        hoverBorderDashed,
        hoverBorderDashGap,
        hoverBorderDashLen,
        hoverDashStyle,
        hoverColorArr,
        dataStore = dataSet.components.data,
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        setDisplayValue,
        isBar = chart.isBar,
        is3D = chart.config.is3D,
        parentYAxis,
        i,
        maxValue = conf.maxValue,
        minValue = conf.minValue,
        heatRange,
        colorObj,
        tlType = (0, _lib.getValidValue)(chartAttr.tltype, _lib.BLANK),
        trType = (0, _lib.getValidValue)(chartAttr.trtype, _lib.BLANK),
        blType = (0, _lib.getValidValue)(chartAttr.bltype, _lib.BLANK),
        brType = (0, _lib.getValidValue)(chartAttr.brtype, _lib.BLANK),
        tlLabel,
        trLabel,
        blLabel,
        brLabel,
        tlTypeToolText = _lib.BLANK,
        trTypeToolText = _lib.BLANK,
        blTypeToolText = _lib.BLANK,
        brTypeToolText = _lib.BLANK,
        percentValue,
        toolTextValue,
        value,
        minMaxArray,
        minMaxArrayLen,
        colorManager = chart.getFromEnv('colorManager');

    heatRange = maxValue - minValue;
    // listen to event fired by legends and decide what to do
    dataSet.addExtEventListener('legendUpdate', function (e, d) {
      if (d.component === 'legend') {
        if (d.legendItem.hasState('hidden')) {
          dataSet.show(d.legendItem, e);
        } else {
          dataSet.hide(d.legendItem, e);
        }
      } else {
        minMaxArray = d.maxMinArray;
        minMaxArrayLen = minMaxArray.length;
        for (i = 0; i < minMaxArrayLen; i++) {
          dataSet.updatePlot(minMaxArray[i].min, minMaxArray[i].max);
        }
      }
    }, colorManager);

    if (!useColorGradient || mapByCategory) {
      conf.colorMap = [];

      for (i = 0; i < colorRange.color.length; i++) {
        conf.colorMap[i] = {
          config: colorRange.color[i],
          dataSet: dataSet
        };
        conf.colorMap[i].config.visible = true;
      }
    }

    for (i = 0; i < len; i++) {
      setData = setDataArr && setDataArr[i];
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;
      /* @TODO-
      * Heatmap percentage calculation is done for each dataset individually and shown for ease.
      * But ideally percentage calculation must be done considering all the datasets.
      * A heatmap group manager should query each dataset for their local min and max values and
      * calculate overall range. Then, the group must inform all the dataset the range and the dataset must
      * calculate the percentage values for each data and then draw itself.
      */
      if (mapByPercent) {
        config.percentValue = percentValue = setData.value && Math.round((setData.value - minValue) / heatRange * 10000) / 100;
      } else {
        config.percentValue = UNDEF;
      }

      config.value = value = mapByCategory /* || !useColorGradient */ ? setData.colorrangelabel || setData.categoryid : mapByPercent ? percentValue : config.setValue;

      colorObj = colorManager.getColor(value);
      dataObj.legendItemIndex = colorObj.seriesIndex;
      colorObj && !colorObj.code && (colorObj.code = 'ffffff');

      if (colorObj && colorObj.outOfRange) {
        config.visible = false;
        config.displayValue = _lib.BLANKSTRING;
        continue;
      }
      config.visible = true;

      plotColor = (0, _lib.pluck)(setData.color, colorObj && colorObj.code);
      config.color = convertColor(plotColor, (0, _lib.pluck)(setData.alpha, conf.plotFillAlpha));

      // Parsing the hover effects only if showhovereffect is not 0.
      if (showHoverEffect !== 0) {
        hoverColor = (0, _lib.pluck)(setData.hovercolor, JSONData.hovercolor, chartAttr.plotfillhovercolor, chartAttr.columnhovercolor, plotColor);
        hoverAlpha = (0, _lib.pluck)(setData.hoveralpha, JSONData.hoveralpha, chartAttr.plotfillhoveralpha, chartAttr.columnhoveralpha, '25');
        hoverGradientColor = (0, _lib.pluck)(setData.hovergradientcolor, JSONData.hovergradientcolor, chartAttr.plothovergradientcolor, !usePlotGradientColor && _lib.BLANKSTRING);
        !hoverGradientColor && (hoverGradientColor = _lib.BLANKSTRING);
        hoverRatio = (0, _lib.pluck)(setData.hoverratio, JSONData.hoverratio, chartAttr.plothoverratio, plotFillRatio);
        hoverAngle = (0, _lib.pluckNumber)(360 - setData.hoverangle, 360 - JSONData.hoverangle, 360 - chartAttr.plothoverangle, plotfillAngle);
        hoverBorderColor = (0, _lib.pluck)(setData.borderhovercolor, JSONData.borderhovercolor, chartAttr.plotborderhovercolor, plotBorderColor);
        hoverBorderAlpha = (0, _lib.pluck)(setData.borderhoveralpha, JSONData.borderhoveralpha, chartAttr.plotborderhoveralpha, plotBorderAlpha, plotFillAlpha);
        hoverBorderThickness = (0, _lib.pluckNumber)(setData.borderhoverthickness, JSONData.borderhoverthickness, chartAttr.plotborderhoverthickness, plotBorderThickness);
        hoverBorderDashed = (0, _lib.pluckNumber)(setData.borderhoverdashed, JSONData.borderhoverdashed, chartAttr.plotborderhoverdashed);
        hoverBorderDashGap = (0, _lib.pluckNumber)(setData.borderhoverdashgap, JSONData.borderhoverdashgap, chartAttr.plotborderhoverdashgap, plotDashLen);
        hoverBorderDashLen = (0, _lib.pluckNumber)(setData.borderhoverdashlen, JSONData.borderhoverdashlen, chartAttr.plotborderhoverdashlen, plotDashGap);
        hoverDashStyle = hoverBorderDashed ? (0, _lib.getDashStyle)(hoverBorderDashLen, hoverBorderDashGap) : conf.plotBorderDashStyle;

        /* If no hover effects are explicitly defined and
                     * showHoverEffect is not 0 then hoverColor is set.
                     */
        if (showHoverEffect == 1 && hoverColor === plotColor) {
          hoverColor = getLightColor(hoverColor, 70);
        }

        // setting the hover color array which is always applied except when showHoverEffect is not 0.
        hoverColorArr = getColumnColor(hoverColor, hoverAlpha, hoverRatio, hoverAngle, isRoundEdges, hoverBorderColor, hoverBorderAlpha.toString(), isBar ? 1 : 0, !!is3D);

        config.setRolloutAttr = {
          fill: (0, _lib.toRaphaelColor)(config.color),
          stroke: showplotborder && (0, _lib.toRaphaelColor)(hoverColorArr[1]) || TRACKER_FILL,
          'stroke-width': plotBorderThickness,
          'stroke-dasharray': plotBorderDashStyle
        };
        config.setRolloverAttr = {
          fill: (0, _lib.toRaphaelColor)(hoverColorArr[0]),
          stroke: showplotborder && (0, _lib.toRaphaelColor)(hoverColorArr[1]) || TRACKER_FILL,
          'stroke-width': hoverBorderThickness,
          'stroke-dasharray': hoverDashStyle
        };
      }

      mapByPercent && (percentValue = numberFormatter.percentValue(percentValue));

      config.setValue = setValue = numberFormatter.getCleanValue(setData.value);
      config.toolTipValue = numberFormatter.dataLabels(setValue, parentYAxis);
      formatedVal = config.toolTipValue;
      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.tooltext, JSONData.plottooltext, chartAttr.plottooltext)));

      config.tlLabel = tlLabel = (0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.tllabel, setData.ltlabel));
      config.trLabel = trLabel = (0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.trlabel, setData.rtlabel));
      config.blLabel = blLabel = (0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.bllabel, setData.lblabel));
      config.brLabel = brLabel = (0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.brlabel, setData.rblabel));

      setDisplayValue = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)(setData.displayvalue));
      toolTextValue = mapByCategory ? setDisplayValue : (0, _lib.pluck)(setData.displayvalue, formatedVal);

      config.displayValue = (0, _lib.pluck)(setDisplayValue, percentValue, config.toolTipValue);

      if (tlType !== _lib.BLANK) {
        tlTypeToolText = BOLDSTARTTAG + tlType + tooltipSepChar + BOLDENDTAG;
      }
      if (trType !== _lib.BLANK) {
        trTypeToolText = BOLDSTARTTAG + trType + tooltipSepChar + BOLDENDTAG;
      }
      if (blType !== _lib.BLANK) {
        blTypeToolText = BOLDSTARTTAG + blType + tooltipSepChar + BOLDENDTAG;
      }
      if (brType !== _lib.BLANK) {
        brTypeToolText = BOLDSTARTTAG + brType + tooltipSepChar + BOLDENDTAG;
      }

      column = xAxis.getCategoryFromId(setDataArr[i].columnid.toLowerCase());
      row = yAxis.getCategoryFromId(setDataArr[i].rowid.toLowerCase());

      // create the tooltext
      if (!showTooltip) {
        config.toolText = false;
      } else {
        if (formatedVal === null) {
          toolText = false;
        } else if (setTooltext !== UNDEF) {
          macroIndices = [1, 2, 5, 6, 7, 14, 93, 94, 95, 96, 97, 98, 112, 113, 114, 115, 116, 117];
          parserConfig = {
            formattedValue: formatedVal,
            value: setData.value,
            yaxisName: yAxisName,
            xaxisName: xAxisName,
            displayValue: setDisplayValue,
            percentValue: mapByPercent ? percentValue : _lib.BLANK,
            tlLabel: tlLabel,
            trLabel: trLabel,
            blLabel: blLabel,
            brLabel: brLabel,
            rowLabel: row.tickObj && row.tickObj.label,
            columnLabel: column.tickObj && column.tickObj.label,
            percentDataValue: mapByPercent ? percentValue : _lib.BLANK,
            trtype: trType,
            tltype: tlType,
            brType: brType,
            blType: blType,
            colorRangeLabel: config.colorRangeLabel
          };
          toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, setData, chartAttr, parserConfig);
        } else {
          toolText = (mapByPercent ? BOLDSTARTTAG + 'Value' + tooltipSepChar + BOLDENDTAG + formatedVal + BREAKSTRING + BOLDSTARTTAG + 'Percentage' + tooltipSepChar + BOLDENDTAG + percentValue : toolTextValue) + (
          // Now we add special labels in toolTip
          tlLabel !== _lib.BLANK ? BREAKSTRING + (tlTypeToolText + tlLabel) : _lib.BLANK) + (trLabel !== _lib.BLANK ? BREAKSTRING + trTypeToolText + trLabel : _lib.BLANK) + (blLabel !== _lib.BLANK ? BREAKSTRING + blTypeToolText + blLabel : _lib.BLANK) + (brLabel !== _lib.BLANK ? BREAKSTRING + brTypeToolText + brLabel : _lib.BLANK);
        }
        config.toolText = toolText;
        config.setTooltext = toolText;
      }
    }
  };
  /**
   * Hides the data objects according to the legend item
   * @param {Object} item - legend item
   */


  HeatMapDataset.prototype.hide = function hide(item) {
    var dataset = this,
        entityComponents = dataset.components.data,
        chart = dataset.getFromEnv('chart'),
        animationManager = dataset.getFromEnv('animationManager'),
        colorRange = chart.getChildren('colorRange')[0],
        i,
        len,
        config,
        legendItemColor,
        colorCode;

    legendItemColor = item.config.datasetObj.code;

    for (i = 0, len = entityComponents.length; i < len; i++) {
      colorCode = colorRange.getColorObj(entityComponents[i].config.value).code;
      config = entityComponents[i].config;

      if (legendItemColor === colorCode) {
        entityComponents[i].graphics.element && animationManager.setAnimation({
          el: entityComponents[i].graphics.element,
          attr: {
            'fill-opacity': 0,
            'stroke-width': 0
          },
          component: dataset
        });

        // animFlagHide = false;

        entityComponents[i].graphics.hotElement && entityComponents[i].graphics.hotElement.hide();
        entityComponents[i].graphics.valEle && entityComponents[i].graphics.valEle.hide();

        entityComponents[i].graphics.tlLabel && entityComponents[i].graphics.tlLabel.hide();
        entityComponents[i].graphics.trLabel && entityComponents[i].graphics.trLabel.hide();
        entityComponents[i].graphics.blLabel && entityComponents[i].graphics.blLabel.hide();
        entityComponents[i].graphics.brLabel && entityComponents[i].graphics.brLabel.hide();
        config.visible = false;
        entityComponents[i].visible = false;
      }
    }
    item.setLegendState('hidden');
  };
  /**
   * Shows the data objects according to the legend item
   * @param {Object} item - legend item
   */


  HeatMapDataset.prototype.show = function show(item) {
    var dataset = this,
        entityComponents = dataset.components.data,
        conf = dataset.config,
        chart = dataset.getFromEnv('chart'),
        animationManager = dataset.getFromEnv('animationManager'),
        config,
        plotFillAlpha,
        colorRange = chart.getChildren('colorRange')[0],
        i,
        len,
        legendItemColor,
        colorCode;

    legendItemColor = item.config.datasetObj.code;

    for (i = 0, len = entityComponents.length; i < len; i++) {
      config = entityComponents[i].config;
      plotFillAlpha = config.plotFillAlpha / 100;
      colorCode = colorRange.getColorObj(entityComponents[i].config.value).code;

      if (legendItemColor === colorCode) {
        entityComponents[i].graphics.element && animationManager.setAnimation({
          el: entityComponents[i].graphics.element,
          attr: {
            'visibility': visibleStr
          },
          component: dataset
        });
        entityComponents[i].graphics.element && animationManager.setAnimation({
          el: entityComponents[i].graphics.element,
          component: dataset,
          attr: {
            'fill-opacity': plotFillAlpha,
            'stroke-width': conf.plotBorderThickness
          }
        });

        // animFlagShow = false;

        entityComponents[i].graphics.hotElement && entityComponents[i].graphics.hotElement.show();
        entityComponents[i].graphics.valEle && entityComponents[i].graphics.valEle.show();

        entityComponents[i].graphics.tlLabel && entityComponents[i].graphics.tlLabel.show();
        entityComponents[i].graphics.trLabel && entityComponents[i].graphics.trLabel.show();
        entityComponents[i].graphics.blLabel && entityComponents[i].graphics.blLabel.show();
        entityComponents[i].graphics.brLabel && entityComponents[i].graphics.brLabel.show();
        config.visible = true;
        entityComponents[i].visible = true;
      }
    }
    item && item.removeLegendState('hidden');
  };
  /**
   * updates the plot range when gradient legend is moved
   */


  HeatMapDataset.prototype.updatePlot = function updatePlot() {
    var dataset = this,
        minValue = arguments[0],
        maxValue = arguments[1],
        conf = dataset.config,
        animationManager = dataset.getFromEnv('animationManager'),
        config,
        plotFillAlpha,
        entityComponents = dataset.components.data,
        i,
        len,
        value;

    for (i = 0, len = entityComponents.length; i < len; i++) {
      config = entityComponents[i].config;
      plotFillAlpha = config.plotFillAlpha / 100;

      value = entityComponents[i].config.value;

      if (value < minValue || value > maxValue) {
        if (config.visible) {
          entityComponents[i].graphics.element && animationManager.setAnimation({
            el: entityComponents[i].graphics.element,
            attr: {
              'fill-opacity': 0,
              'stroke-width': 0
            },
            component: dataset
          });

          entityComponents[i].graphics.hotElement && entityComponents[i].graphics.hotElement.hide();
          entityComponents[i].graphics.valEle && entityComponents[i].graphics.valEle.hide();

          entityComponents[i].graphics.tlLabel && entityComponents[i].graphics.tlLabel.hide();
          entityComponents[i].graphics.trLabel && entityComponents[i].graphics.trLabel.hide();
          entityComponents[i].graphics.blLabel && entityComponents[i].graphics.blLabel.hide();
          entityComponents[i].graphics.brLabel && entityComponents[i].graphics.brLabel.hide();
          config.visible = false;
          entityComponents[i].visible = false;
        }
      } else {
        if (!config.visible) {
          // entityComponents[i].graphics.element && animationManager.registerAnimation([{
          //   animType: animType,
          //   data: [{
          //     el: entityComponents[i].graphics.element,
          //     attrs: {
          //       'fill-opacity': plotFillAlpha,
          //       'stroke-width': conf.plotBorderThickness
          //     }
          //   }]
          // }], 'plot');
          entityComponents[i].graphics.element && animationManager.setAnimation({
            el: entityComponents[i].graphics.element,
            attr: {
              'fill-opacity': plotFillAlpha,
              'stroke-width': conf.plotBorderThickness
            },
            component: dataset
          });

          entityComponents[i].graphics.hotElement && entityComponents[i].graphics.hotElement.show();
          entityComponents[i].graphics.valEle && entityComponents[i].graphics.valEle.show();

          entityComponents[i].graphics.tlLabel && entityComponents[i].graphics.tlLabel.show();
          entityComponents[i].graphics.trLabel && entityComponents[i].graphics.trLabel.show();
          entityComponents[i].graphics.blLabel && entityComponents[i].graphics.blLabel.show();
          entityComponents[i].graphics.brLabel && entityComponents[i].graphics.brLabel.show();
          config.visible = true;
          entityComponents[i].visible = true;
        }
      }
    }
  };

  HeatMapDataset.prototype._checkPointObj = function _checkPointObj(pX, pY, chartX, chartY) {
    var dataset = this,
        plotGrid = dataset.components.plotGrid,
        pointObj,
        chartConfig = dataset.getFromEnv('chartConfig'),
        viewPortConfig = chartConfig.viewPortConfig,
        x = viewPortConfig.x,
        scaleX = viewPortConfig.scaleX,
        plotBorderThickness = chartConfig.plotborderthickness,
        showPlotBorder = chartConfig.showplotborder,
        halfPlotBorderThickness,
        dx,
        dy,
        hovered;

    pointObj = plotGrid[pY] && plotGrid[pY][pX];
    plotBorderThickness = showPlotBorder ? plotBorderThickness : 0;
    halfPlotBorderThickness = plotBorderThickness / 2;

    halfPlotBorderThickness = halfPlotBorderThickness % 2 === 0 ? halfPlotBorderThickness + 1 : Math.round(halfPlotBorderThickness);

    if (pointObj && pointObj.config && pointObj.config.visible) {
      dx = chartX - (pointObj._xPos - x * scaleX) + halfPlotBorderThickness;
      dy = chartY - pointObj._yPos + halfPlotBorderThickness;

      hovered = dx >= 0 && dx <= pointObj._width + plotBorderThickness && dy >= 0 && dy <= pointObj._height + plotBorderThickness;

      if (hovered) {
        return {
          pointIndex: pointObj._index,
          hovered: hovered,
          pointObj: pointObj
        };
      }
    }
  };
  /**
   *  function to return the hovered data object
   */


  HeatMapDataset.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        chartConfig = dataset.getFromEnv('chartConfig'),
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),
        height = chartConfig.canvasHeight / dataset.getFromEnv('totalRows'),
        x,
        y,
        pX,
        pY;
    chartX += xAxis.getTranslation();
    chartY += yAxis.getTranslation();
    y = yAxis.getValue(chartY + height / 2);
    pY = Math.floor(y);

    x = xAxis.getValue(chartX);
    pX = Math.round(x);

    if (pX - x > 0) {
      return y - pY > 0.5 ? dataset._checkPointObj(pX, pY, chartX, chartY) || dataset._checkPointObj(pX - 1, pY, chartX, chartY) : dataset._checkPointObj(pX, pY - 1, chartX, chartY) || dataset._checkPointObj(pX, pY, chartX, chartY);
    } else {
      return y - pY > 0.5 ? dataset._checkPointObj(pX + 1, pY, chartX, chartY) || dataset._checkPointObj(pX, pY, chartX, chartY) : dataset._checkPointObj(pX, pY - 1, chartX, chartY) || dataset._checkPointObj(pX + 1, pY, chartX, chartY) || dataset._checkPointObj(pX, pY, chartX, chartY);
    }
  };

  /**
   * Parses the plot attributes
   *
   * @param {any} dataObj
   * @param {any} index
   * @returns {any}
   * @memberof HeatMapDataset
   */


  HeatMapDataset.prototype.parsePlotAttributes = function parsePlotAttributes(dataObj, index) {
    var dataSet = this,
        JSONData = dataSet.config.JSONData,
        conf = dataSet.config,
        setDataArr = JSONData.data,
        attr,
        i = index,
        visible = dataSet.getState('visible'),
        chart = dataSet.getFromEnv('chart'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis'),
        xPos,
        yPos,
        chartConfig = dataSet.getFromEnv('chartConfig'),
        showTooltip = chartConfig.showtooltip,
        columnWidth,
        height,
        toolText,
        dataStore = dataSet.components.data,
        setLink,
        setValue,
        displayValue,
        config,
        yBase = yAxis.getAxisBase(),
        yBasePos = yAxis.yBasePos = yAxis.getPixel(yBase),
        heightBase = 0,
        plotBorderThickness = conf.plotBorderThickness,
        plotRadius = conf.plotRadius,
        colorArr,
        plotBorderDashStyle,
        legendActive = chart.getFromEnv('legend') && chart.getFromEnv('legend').config.isActive,
        plotGrid = dataSet.components.plotGrid,
        width,
        column,
        row,
        trackerConfig;

    width = chartConfig.canvasWidth / dataSet.getFromEnv('totalColumns');
    height = chartConfig.canvasHeight / dataSet.getFromEnv('totalRows');

    trackerConfig = dataObj.trackerConfig = {};
    config = dataObj && dataObj.config;
    setValue = config.setValue;
    column = xAxis.getCategoryFromId(setDataArr[i].columnid.toLowerCase());
    row = yAxis.getCategoryFromId(setDataArr[i].rowid.toLowerCase());
    if (column.index !== 0 && !column.index || row.index !== 0 && !row.index) {
      return;
    }
    if (!conf.mapByCategory && setValue === null) {
      return;
    }

    setLink = config.setLink;
    colorArr = config.colorArr;

    // Creating the data structure if not present for storing the graphics elements.
    if (!dataObj.graphics) {
      dataStore[i].graphics = {};
    }

    displayValue = config.displayValue;

    xPos = xAxis.getPixel(column.index) - width / 2;

    yPos = yAxis.getPixel(row.index) - height / 2;

    columnWidth = width;

    // Setting the final tooltext.
    toolText = config.toolText;
    toolText && (config.finalTooltext = toolText);

    // Setting the event arguments.
    trackerConfig.eventArgs = {
      index: i,
      link: setLink,
      value: config.percentValue || setValue,
      displayValue: displayValue,
      columnId: column.tickObj.id,
      rowId: row.tickObj.id,
      tlLabel: config.tlLabel,
      trLabel: config.trLabel,
      blLabel: config.blLabel,
      brLabel: config.brLabel,
      // categoryLabel: categories[i].label,
      toolText: !toolText ? '' : toolText,
      id: _lib.BLANKSTRING,
      datasetIndex: legendActive ? dataObj.datasetIndex : UNDEF,
      datasetName: legendActive ? dataObj.datasetName : UNDEF,
      visible: visible
    };

    yBasePos = yPos;
    heightBase = height;

    // Setting the attributes for plot drawing.
    attr = {
      x: xPos,
      y: yBasePos,
      width: columnWidth,
      height: heightBase || 1,
      r: plotRadius,
      ishot: !showTooltip,
      fill: config.color,
      stroke: (0, _lib.toRaphaelColor)(colorArr[1]),
      'stroke-width': plotBorderThickness,
      'stroke-dasharray': plotBorderDashStyle,
      'fill-opacity': config.plotFillAlpha / 100,
      'stroke-linejoin': miterStr,
      'visibility': config.visible ? visibleStr : hiddenStr,
      cursor: setLink ? POINTER : _lib.BLANKSTRING
    };

    // todo- remove _ to make it public
    dataObj._xPos = xPos;
    dataObj._yPos = yPos;
    dataObj._height = height;
    dataObj._width = columnWidth;
    dataObj._index = i;
    plotGrid[row.index][column.index] = dataObj;
    /*
    * If the data plots are not present then they are created, else only attributes are set for the
    * existing plots.
    */
    if (!dataObj.graphics.element) {
      attr['fill-opacity'] = config.plotFillAlpha / 100;
      attr['stroke-width'] = plotBorderThickness;
    } else {
      attr = {
        x: xPos,
        y: yPos,
        width: columnWidth,
        height: height || 1
      };
      attr.ishot = !showTooltip;
      attr.fill = config.color;
      attr.stroke = (0, _lib.toRaphaelColor)(colorArr[1]);
      attr['fill-opacity'] = config.visible ? config.plotFillAlpha / 100 : 0;
      attr['stroke-width'] = config.visible ? plotBorderThickness : 0;
      attr['stroke-dasharray'] = plotBorderDashStyle;
      attr['stroke-linejoin'] = miterStr;
      attr.visibility = config.visible ? visibleStr : hiddenStr;
      attr.cursor = setLink ? POINTER : _lib.BLANKSTRING;
    }

    if (setLink || showTooltip) {
      // Fix for touch devices.
      if (height < HTP) {
        yPos -= (HTP - height) / 2;
        height = HTP;
      }

      // Setting attributes for the tooltip.
      trackerConfig.attr = {
        x: xPos,
        y: yPos,
        width: columnWidth,
        height: height,
        r: plotRadius,
        cursor: setLink ? POINTER : _lib.BLANKSTRING,
        stroke: TRACKER_FILL,
        'stroke-width': plotBorderThickness,
        fill: TRACKER_FILL,
        ishot: true,
        'visibility': config.visible ? visibleStr : hiddenStr
      };
    }

    config.props = {
      element: {
        attr: attr
      }
    };
  };

  /**
   * Parses and allocate plot cosmetics and position
   *
   * @memberof HeatMapDataset
   */


  HeatMapDataset.prototype.allocatePosition = function allocatePosition() {
    var dataSet = this,
        JSONData = dataSet.config.JSONData,
        setDataArr = JSONData.data,
        len,
        i,
        dataStore = dataSet.components.data,
        dataObj;

    len = setDataArr && setDataArr.length;

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      dataSet.parsePlotAttributes(dataObj, i);
      // dataSet.parseLabelAttributes(dataObj, i);
    }
  };
  /**
   * draws the plot according to the configuration
   */


  HeatMapDataset.prototype.drawPlots = function drawPlots() {
    var dataSet = this,
        JSONData = dataSet.config.JSONData,
        conf = dataSet.config,
        setDataArr = JSONData.data,
        len,
        i,
        animationManager = dataSet.getFromEnv('animationManager'),
        visible = dataSet.getState('visible'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis'),
        crispBox,
        chartConfig = dataSet.getFromEnv('chartConfig'),
        dataStore = dataSet.components.data,
        dataObj,
        setElement,
        setValue,
        config,
        state,
        showShadow = conf.showShadow,
        container = dataSet.getContainer('plotGroup'),
        shadowContainer = dataSet.getContainer('shadowGroup'),
        column,
        row,
        elemIdStore = [],
        elemId,
        removeDataArr = dataSet.components.removeDataArr || [],
        removeDataArrLen = removeDataArr.length,
        showHoverEffect = conf.showHoverEffect,
        trackerConfig;

    len = setDataArr && setDataArr.length;

    // Create plot elements.
    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      trackerConfig = dataObj.trackerConfig;
      config = dataObj && dataObj.config;
      state = !dataObj.graphics.element ? 'appearing' : visible ? 'updating' : 'hiding';
      setValue = config.setValue;
      column = xAxis.getCategoryFromId(setDataArr[i].columnid.toLowerCase());
      row = yAxis.getCategoryFromId(setDataArr[i].rowid.toLowerCase());
      if (column.index !== 0 && !column.index || row.index !== 0 && !row.index) {
        continue;
      }

      if ((!column.tickObj || !row.tickObj || config.value === _lib.BLANKSTRING) && dataObj.graphics) {
        dataObj.graphics.element && animationManager.setAnimation({
          el: dataObj.graphics.element,
          callback: removePlot(dataObj),
          component: dataSet
        });
      }

      if (!conf.mapByCategory && setValue === null && dataObj.graphics) {
        dataObj.graphics.element && dataObj.graphics.element.hide();
        dataObj.graphics.hotElement && dataObj.graphics.hotElement.hide();
        continue;
      }

      elemId = column.index.toString() + row.index.toString();

      elemIdStore.push(elemId);

      dataObj.graphics.valEle && dataObj.graphics.valEle.hide();
      dataObj.graphics.tlLabel && dataObj.graphics.tlLabel.hide();
      dataObj.graphics.trLabel && dataObj.graphics.trLabel.hide();
      dataObj.graphics.blLabel && dataObj.graphics.blLabel.hide();
      dataObj.graphics.brLabel && dataObj.graphics.brLabel.hide();

      /*
      * If the data plots are not present then they are created, else only attributes are set for the
      * existing plots.
      */
      if (!dataObj.graphics.element) {
        setElement = dataObj.graphics.element = animationManager.setAnimation({
          el: 'rect',
          component: dataSet,
          attr: config.props.element.attr,
          dom: 'rect',
          container: container
        });

        config.elemCreated = true;
      } else {
        setElement = dataObj.graphics.element;
        config.elemCreated = false;

        animationManager.setAnimation({
          el: setElement,
          state: state,
          attr: config.props.element.attr,
          component: dataSet
        });
      }

      // The shadow element is set for the dataplots.
      setElement.shadow({ opacity: showShadow }, shadowContainer).data('BBox', crispBox);

      chartConfig.enablemousetracking && setElement.data(EVENTARGS, trackerConfig.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, config.setRolloverAttr || {}).data(SETROLLOUTATTR, config.setRolloutAttr || {});
    }

    dataSet.drawn ? dataSet.drawLabel() : dataSet.addJob('labelJob', dataSet.drawLabel.bind(dataSet), _schedular.priorityList.label);
    dataSet.drawn = true;

    removeDataArrLen && dataSet.removeDataElems();
  };
  /**
   * Draws the data labels if any
   */


  HeatMapDataset.prototype.drawLabel = function drawLabel() {
    var dataSet = this,
        chartConf = dataSet.getFromEnv('chartConfig'),
        smartLabel = dataSet.getFromEnv('smartLabel'),
        animationManager = dataSet.getFromEnv('animationManager'),
        style = chartConf.dataLabelStyle,
        conf = dataSet.config,
        state,
        visible = dataSet.getState('visible'),
        JSONData = dataSet.config.JSONData,
        setDataArr = JSONData.data || [],
        len = setDataArr.length,
        components = dataSet.components,
        dataStore = components.data,
        dataObj,
        i,
        displayValue,
        graphic,
        textY,
        textX,
        yPos,
        xPos,
        attr,
        dataLabelContainer = dataSet.getContainer('labelGroup'),
        tlLabelContainer = dataSet.graphics.tlLabelContainer,
        blLabelContainer = dataSet.graphics.blLabelContainer,
        trLabelContainer = dataSet.graphics.trLabelContainer,
        brLabelContainer = dataSet.graphics.brLabelContainer,
        tlStyle,
        trStyle,
        blStyle,
        brStyle,
        tlCss,
        trCss,
        blCss,
        brCss,
        graphicEle,
        pointW,
        pointH,
        pointX,
        pointY,
        smartTextObj,
        tlLabel,
        trLabel,
        blLabel,
        brLabel,
        isTLLabel,
        isTRLabel,
        isBLLabel,
        isBRLabel,
        maxWidth,
        maxHeight,
        config,
        setValue,
        MAX_PERCENT_SPACE = 0.9,
        POINT_FIVE = 0.5,
        GUTTER_4 = 4;

    animationManager.setAnimation({
      el: dataLabelContainer,
      attr: {
        opacity: 1
      },
      component: dataSet,
      label: 'text'
    });

    if (!tlLabelContainer) {
      tlLabelContainer = dataSet.graphics.tlLabelContainer = createGroup({ name: tlLabelStr }, dataLabelContainer, dataSet);
    }

    if (!blLabelContainer) {
      blLabelContainer = dataSet.graphics.blLabelContainer = createGroup({ name: blLabelStr }, dataLabelContainer, dataSet);
    }

    if (!trLabelContainer) {
      trLabelContainer = dataSet.graphics.trLabelContainer = createGroup({ name: trLabelStr }, dataLabelContainer, dataSet);
    }

    if (!brLabelContainer) {
      brLabelContainer = dataSet.graphics.brLabelContainer = createGroup({ name: brLabelStr }, dataLabelContainer, dataSet);
    }

    tlStyle = conf.tlLabelStyle;
    trStyle = conf.trLabelStyle;
    blStyle = conf.blLabelStyle;
    brStyle = conf.brLabelStyle;

    tlCss = {
      fontFamily: tlStyle.fontFamily,
      fontSize: tlStyle.fontSize,
      lineHeight: tlStyle.lineHeight,
      fontWeight: tlStyle.fontWeight,
      fontStyle: tlStyle.fontStyle
    };
    trCss = {
      fontFamily: trStyle.fontFamily,
      fontSize: trStyle.fontSize,
      lineHeight: trStyle.lineHeight,
      fontWeight: trStyle.fontWeight,
      fontStyle: trStyle.fontStyle
    };
    blCss = {
      fontFamily: blStyle.fontFamily,
      fontSize: blStyle.fontSize,
      lineHeight: blStyle.lineHeight,
      fontWeight: blStyle.fontWeight,
      fontStyle: blStyle.fontStyle
    };
    brCss = {
      fontFamily: brStyle.fontFamily,
      fontSize: brStyle.fontSize,
      lineHeight: brStyle.lineHeight,
      fontWeight: brStyle.fontWeight,
      fontStyle: brStyle.fontStyle
    };
    smartLabel.useEllipsesOnOverflow(chartConf.useEllipsesWhenOverflow);
    smartLabel.setStyle(style);

    tlLabelContainer.css(tlCss);
    blLabelContainer.css(blCss);
    trLabelContainer.css(trCss);
    brLabelContainer.css(brCss);

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      // Condition arises when user has removed data in real time update
      if (dataObj === UNDEF) {
        continue;
      }
      graphic = dataObj.graphics;
      state = !dataObj.graphics.valEle ? 'appearing' : visible ? 'updating' : 'hiding';

      // Condition arises when feedData enters less number of data in a dataset compared to the other.
      if (!graphic) {
        continue;
      }

      config = dataObj && dataObj.config;
      setValue = config.setValue;

      if (!conf.mapByCategory && setValue === null) {
        dataObj.graphics.valEle && dataObj.graphics.valEle.hide();
        dataObj.graphics.tlLabel && dataObj.graphics.tlLabel.hide();
        dataObj.graphics.trLabel && dataObj.graphics.trLabel.hide();
        dataObj.graphics.blLabel && dataObj.graphics.blLabel.hide();
        dataObj.graphics.brLabel && dataObj.graphics.brLabel.hide();
        continue;
      }

      displayValue = config.displayValue;

      graphicEle = dataObj.graphics.element;

      if (!graphicEle) {
        continue;
      }

      pointW = dataObj._width;
      pointH = dataObj._height;
      pointX = dataObj._xPos;
      pointY = dataObj._yPos;

      // Setting style for smartLabel
      smartLabel.setStyle(style);

      // Drawing of displayValue
      if (defined(displayValue) && displayValue !== _lib.BLANK && config.showValue) {
        // First render the value text
        // Get the displayValue text according to the
        smartTextObj = smartLabel.getSmartText(displayValue, pointW, pointH, false);
        displayValue = smartTextObj.text;

        textY = pointY + pointH * 0.5;
        textX = pointX + pointW * 0.5;

        if (!dataObj.graphics.valEle) {
          attr = {
            text: displayValue,
            title: smartTextObj.tooltext || _lib.BLANKSTRING,
            visibility: config.visible ? visibleStr : hiddenStr,
            fill: style.color,
            direction: config.textDirection,
            x: textX,
            y: textY,
            'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
          };
          dataObj.graphics.valEle = animationManager.setAnimation({
            el: 'text',
            state: state,
            container: dataLabelContainer,
            component: dataSet,
            dom: 'text',
            attr: attr
          });
        } else {
          animationManager.setAnimation({
            el: dataObj.graphics.valEle,
            state: state,
            attr: {
              x: textX,
              y: textY,
              text: displayValue,
              title: smartTextObj.tooltext || _lib.BLANKSTRING,
              visibility: config.visible ? visibleStr : hiddenStr,
              fill: style.color,
              direction: config.textDirection,
              'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
            },
            component: dataSet
          });
        }

        config.visible && dataObj.graphics.valEle.show();

        tlLabel = config.tlLabel;
        trLabel = config.trLabel;
        blLabel = config.blLabel;
        brLabel = config.brLabel;

        isTLLabel = defined(tlLabel) && tlLabel !== _lib.BLANK;
        isTRLabel = defined(trLabel) && trLabel !== _lib.BLANK;
        isBLLabel = defined(blLabel) && blLabel !== _lib.BLANK;
        isBRLabel = defined(brLabel) && brLabel !== _lib.BLANK;

        maxWidth = pointW * (isTLLabel && isTRLabel ? POINT_FIVE : MAX_PERCENT_SPACE);
        maxHeight = (pointH - (smartTextObj && smartTextObj.height || 0)) * 0.5;
        // For top labels
        yPos = pointY + GUTTER_4;

        if (isTLLabel) {
          // Setting style for smartLabel
          smartLabel.setStyle(tlStyle);
          smartTextObj = smartLabel.getSmartText(tlLabel, maxWidth, maxHeight, false);
          displayValue = smartTextObj.text;
          // Get the x and y position of the dataValue
          xPos = pointX;

          if (!dataObj.graphics.tlLabel) {
            attr = {
              text: displayValue,
              title: smartTextObj.tooltext || _lib.BLANKSTRING,
              visibility: config.visible ? visibleStr : hiddenStr,
              fill: tlStyle.color,
              'text-anchor': POSITION_START,
              'vertical-align': POSITION_TOP,
              direction: config.textDirection,
              x: xPos + GUTTER_4,
              y: yPos,
              'text-bound': [tlStyle.backgroundColor, tlStyle.borderColor, tlStyle.borderThickness, tlStyle.borderPadding, tlStyle.borderRadius, tlStyle.borderDash]
            };
            dataObj.graphics.tlLabel = animationManager.setAnimation({
              el: 'text',
              component: dataSet,
              attr: attr,
              container: tlLabelContainer
            });
          } else {
            animationManager.setAnimation({
              el: dataObj.graphics.tlLabel,
              attr: {
                x: xPos + GUTTER_4,
                y: yPos,
                text: displayValue,
                title: smartTextObj.tooltext || _lib.BLANKSTRING,
                visibility: config.visible ? visibleStr : hiddenStr,
                fill: tlStyle.color,
                'text-anchor': POSITION_START,
                'vertical-align': POSITION_TOP,
                direction: config.textDirection,
                'text-bound': [tlStyle.backgroundColor, tlStyle.borderColor, tlStyle.borderThickness, tlStyle.borderPadding, tlStyle.borderRadius, tlStyle.borderDash]
              },
              component: dataSet
            });
          }
          config.visible && dataObj.graphics.tlLabel.show();
        } else {
          if (dataObj.graphics.tlLabel) {
            dataObj.graphics.tlLabel.remove();
            delete dataObj.graphics.tlLabel;
          }
        }

        if (isTRLabel) {
          // Setting style for smartRabel
          smartLabel.setStyle(trStyle);
          smartTextObj = smartLabel.getSmartText(trLabel, maxWidth, maxHeight, false);
          displayValue = smartTextObj.text;
          // Get the x and y position of the dataValue
          xPos = pointX + pointW;
          if (!dataObj.graphics.trLabel) {
            attr = {
              text: displayValue,
              title: smartTextObj.tooltext || _lib.BLANKSTRING,
              visibility: config.visible ? visibleStr : hiddenStr,
              fill: trStyle.color,
              'text-anchor': POSITION_END,
              'vertical-align': POSITION_TOP,
              direction: config.textDirection,
              x: xPos - GUTTER_4,
              y: yPos,
              'text-bound': [trStyle.backgroundColor, trStyle.borderColor, trStyle.borderThickness, trStyle.borderPadding, trStyle.borderRadius, trStyle.borderDash]
            };
            dataObj.graphics.trLabel = animationManager.setAnimation({
              el: 'text',
              component: dataSet,
              attr: attr,
              container: trLabelContainer
            });
          } else {
            animationManager.setAnimation({
              el: dataObj.graphics.trLabel,
              attr: {
                x: xPos - GUTTER_4,
                y: yPos,
                text: displayValue,
                title: smartTextObj.tooltext || _lib.BLANKSTRING,
                visibility: config.visible ? visibleStr : hiddenStr,
                fill: trStyle.color,
                'text-anchor': POSITION_END,
                'vertical-align': POSITION_TOP,
                direction: config.textDirection,
                'text-bound': [trStyle.backgroundColor, trStyle.borderColor, trStyle.borderThickness, trStyle.borderPadding, trStyle.borderRadius, trStyle.borderDash]
              },
              component: dataSet
            });
          }
          config.visible && dataObj.graphics.trLabel.show();
        } else {
          if (dataObj.graphics.trLabel) {
            dataObj.graphics.trLabel.remove();
            delete dataObj.graphics.trLabel;
          }
        }

        // For top labels
        yPos = pointY + pointH - GUTTER_4;

        if (isBLLabel) {
          // Setting style for smartRabel
          smartLabel.setStyle(blStyle);
          smartTextObj = smartLabel.getSmartText(blLabel, maxWidth, maxHeight, false);
          displayValue = smartTextObj.text;
          // Get the x and y position of the dataValue
          xPos = pointX;
          if (!dataObj.graphics.blLabel) {
            attr = {
              text: displayValue,
              title: smartTextObj.tooltext || _lib.BLANKSTRING,
              visibility: config.visible ? visibleStr : hiddenStr,
              fill: blStyle.color,
              'text-anchor': POSITION_START,
              'vertical-align': POSITION_BOTTOM,
              direction: config.textDirection,
              x: xPos + GUTTER_4,
              y: yPos,
              'text-bound': [blStyle.backgroundColor, blStyle.borderColor, blStyle.borderThickness, blStyle.borderPadding, blStyle.borderRadius, blStyle.borderDash]
            };
            dataObj.graphics.blLabel = animationManager.setAnimation({
              el: 'text',
              component: dataSet,
              container: blLabelContainer,
              attr: attr
            });
          } else {
            animationManager.setAnimation({
              el: dataObj.graphics.blLabel,
              component: dataSet,
              attr: {
                x: xPos + GUTTER_4,
                y: yPos,
                text: displayValue,
                title: smartTextObj.tooltext || _lib.BLANKSTRING,
                visibility: config.visible ? visibleStr : hiddenStr,
                fill: blStyle.color,
                'text-anchor': POSITION_START,
                'vertical-align': POSITION_BOTTOM,
                direction: config.textDirection,
                'text-bound': [blStyle.backgroundColor, blStyle.borderColor, blStyle.borderThickness, blStyle.borderPadding, blStyle.borderRadius, blStyle.borderDash]
              }
            });
          }
          config.visible && dataObj.graphics.blLabel.show();
        } else {
          if (dataObj.graphics.blLabel) {
            dataObj.graphics.blLabel.remove();
            delete dataObj.graphics.blLabel;
          }
        }

        if (isBRLabel) {
          // Setting style for smartRabel
          smartLabel.setStyle(blStyle);
          smartTextObj = smartLabel.getSmartText(brLabel, maxWidth, maxHeight, false);
          displayValue = smartTextObj.text;
          // Get the x and y position of the dataValue
          xPos = pointX + pointW - GUTTER_4;
          if (!dataObj.graphics.brLabel) {
            attr = {
              text: displayValue,
              title: smartTextObj.tooltext || _lib.BLANKSTRING,
              visibility: config.visible ? visibleStr : hiddenStr,
              fill: brStyle.color,
              'text-anchor': POSITION_END,
              'vertical-align': POSITION_BOTTOM,
              direction: config.textDirection,
              x: xPos,
              y: yPos,
              'text-bound': [brStyle.backgroundColor, brStyle.borderColor, brStyle.borderThickness, brStyle.borderPadding, brStyle.borderRadius, brStyle.borderDash]
            };
            dataObj.graphics.brLabel = animationManager.setAnimation({
              el: 'text',
              component: dataSet,
              attr: attr,
              container: brLabelContainer
            });
          } else {
            animationManager.setAnimation({
              el: dataObj.graphics.brLabel,
              attr: {
                x: xPos,
                y: yPos,
                text: displayValue,
                title: smartTextObj.tooltext || _lib.BLANKSTRING,
                visibility: config.visible ? visibleStr : hiddenStr,
                fill: brStyle.color,
                'text-anchor': POSITION_END,
                'vertical-align': POSITION_BOTTOM,
                direction: config.textDirection,
                'text-bound': [brStyle.backgroundColor, brStyle.borderColor, brStyle.borderThickness, brStyle.borderPadding, brStyle.borderRadius, brStyle.borderDash]
              },
              component: dataSet
            });
          }
          config.visible && dataObj.graphics.brLabel.show();
        } else {
          if (dataObj.graphics.brLabel) {
            dataObj.graphics.brLabel.remove();
            delete dataObj.graphics.brLabel;
          }
        }
      } else {
        if (dataObj.graphics.valEle) {
          dataObj.graphics.valEle.remove();
          delete dataObj.graphics.valEle;
        }

        if (dataObj.graphics.tlLabel) {
          dataObj.graphics.tlLabel.remove();
          delete dataObj.graphics.tlLabel;
        }

        if (dataObj.graphics.trLabel) {
          dataObj.graphics.trLabel.remove();
          delete dataObj.graphics.trLabel;
        }

        if (dataObj.graphics.blLabel) {
          dataObj.graphics.blLabel.remove();
          delete dataObj.graphics.blLabel;
        }

        if (dataObj.graphics.brLabel) {
          dataObj.graphics.brLabel.remove();
          delete dataObj.graphics.brLabel;
        }
      }
    }

    dataSet.labelDrawn = true;
  };
  /**
   * Function to remove data elements
   */


  HeatMapDataset.prototype.removeDataElems = function removeDataElems() {
    var dataSet = this,
        components = dataSet.components,
        removeDataArr = components.removeDataArr,
        pool = components.pool || (components.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        len = removeDataArr.length,
        removeData,
        ele,
        graphics,
        i;

    for (i = 0; i < len; i++) {
      removeData = removeDataArr[0];
      removeDataArr.splice(0, 1);
      // In case of non existing data plot continue;
      if (!removeData || !removeData.graphics) {
        continue;
      }

      graphics = removeData.graphics;
      for (ele in graphics) {
        // Stopping any previous animation.
        graphics[ele].stop();
        graphics[ele].hide();
      }

      // Storing the graphic elements for reuse.
      removeData.graphics.element && (pool.element = pool.element.concat(removeData.graphics.element));
      removeData.graphics.hotElement && (pool.hotElement = pool.hotElement.concat(removeData.graphics.hotElement));
      removeData.graphics.label && (pool.label = pool.label.concat(removeData.graphics.label));
    }
    components.pool = pool;
  };
  /**
   * @returns {number} axis value padding
   */


  HeatMapDataset.prototype.getAxisValuePadding = function getAxisValuePadding() {
    return this.config.defaultPadding;
  };

  /**
   * Function to get the maximum and minimum from dataset
   * @return {Object}     contains max, min value
   */


  HeatMapDataset.prototype.getDataLimits = function getDataLimits() {
    var dataSet = this,
        dataStore = dataSet.components.data,
        conf = dataSet.config,
        i,
        config,
        len = dataStore.length,
        setValue,
        maxValue = -Infinity,
        minValue = +Infinity;

    for (i = 0; i < len; i++) {
      if (!dataStore[i]) {
        continue;
      }
      config = dataStore[i].config;
      setValue = config.setValue;
      if (setValue !== UNDEF && setValue !== null) {
        maxValue = mathMax(maxValue, setValue);
        minValue = mathMin(minValue, setValue);
      }
    }

    conf.maxValue = maxValue;
    conf.minValue = minValue;
    return {
      max: conf.maxValue,
      min: conf.minValue
    };
  };
  /**
   * function to Remove data plots if the number of current data plots/categories
   * is more than the existing ones.
   * @param  {Object} datasetJSON JSON for dataset configurations
   */


  HeatMapDataset.prototype.trimData = function trimData(datasetJSON) {
    if (!this.config.JSONData) {
      return;
    }
    var dataSet = this,
        config = dataSet.config,
        context = config && config.context,
        prevCatlen = context && context.prevCatlen,
        xAxis = dataSet.getFromEnv('xAxis'),
        currCatLen = xAxis.getTicksLen(),
        catDiff = prevCatlen - currCatLen,
        prevData = config.JSONData,
        prevDataLength = prevData.data && prevData.data.length,
        currDataLength = datasetJSON.data && datasetJSON.data.length || 0,
        dataDiff = prevDataLength - currDataLength,
        diff = void 0,
        startIndex = void 0;

    if (catDiff > dataDiff) {
      diff = catDiff;
      startIndex = currCatLen;
    } else {
      diff = dataDiff;
      startIndex = currDataLength;
    }

    // Removing data plots if the number of current data plots/categories
    // is more than the existing ones.
    if (diff > 0) {
      this.removeData(startIndex, diff, false);
    }
  };
  /**
   * Function for drawing 2D columns.
   * This function is called every time for each dataset when they are initially drawn or shown/hidden from
   * the drawGraph() function.
   */


  HeatMapDataset.prototype.draw = function draw() {
    var dataSet = this,
        conf = dataSet.config,
        visible = dataSet.getState('visible'),
        xAxis = dataSet.getFromEnv('xAxis'),
        xAxisZeroPos = xAxis.getPixel(0),
        xAxisFirstPos = xAxis.getPixel(1),
        groupMaxWidth = dataSet.getFromEnv('groupMaxWidth'),
        drawn = conf.drawn,
        isContextChanged = dataSet._contextChanged();

    if (!groupMaxWidth) {
      groupMaxWidth = mathAbs(xAxisFirstPos - xAxisZeroPos);
      dataSet.addToEnv('groupMaxWidth', groupMaxWidth);
    }

    if (!dataSet.getState('removed') && !dataSet.getState('dirty') && !(isContextChanged && visible)) {
      return;
    }

    !drawn && dataSet.createContainer();

    if (!xAxis.getState('scrolling')) {
      dataSet.createCoordinates();
    }

    // Draw all the graphic elements
    dataSet.drawPlots();
    // dataSet.updatePlot(conf.minValue, conf.maxValue);

    dataSet.childrenSyncDraw();
  };
  /**
   * function to check if the context of dataset is chanegd or not
   * if changed then it will return staus true. It is for further infomormation to redraw a dataset
   * @return {boolean} status of context change
   */


  HeatMapDataset.prototype._contextChanged = function _contextChanged() {
    if (!this.config.context) {
      this.config.context = {};
    }
    var dataset = this,
        context = dataset.config.context,
        oldShift = context.shift,
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),
        stringifiedOldLimits = context.axisLimit,
        stringifiedNewLimits = void 0,
        status = false,
        newAxisLimit = {
      yAxis: {
        limit: yAxis.getVisibleConfig()
      },
      xAxis: {
        limit: xAxis.getVisibleConfig()
      }
    };
    newAxisLimit.yAxis.limitPixel = {
      min: yAxis.getPixel(newAxisLimit.yAxis.limit.minValue),
      max: yAxis.getPixel(newAxisLimit.yAxis.limit.maxValue)
    };
    newAxisLimit.xAxis.limitPixel = {
      min: xAxis.getPixel(newAxisLimit.xAxis.limit.minValue),
      max: xAxis.getPixel(newAxisLimit.xAxis.limit.maxValue)
    };

    stringifiedNewLimits = (0, _stringify2['default'])(newAxisLimit);

    if (stringifiedOldLimits !== stringifiedNewLimits) {
      context.axisLimit = stringifiedNewLimits;
      status = true;
    }
    if (oldShift !== dataset.getFromEnv('shift')) {
      context.shift = dataset.getFromEnv('shift');
      status = true;
    }
    if (context.prevColNum !== dataset.getFromEnv('numOfColumns')) {
      context.prevColNum = dataset.getFromEnv('numOfColumns');
      status = true;
    }

    if (context.prevCatlen !== xAxis.getTicksLen()) {
      context.prevCatlen = xAxis.getTicksLen();
      status = true;
    }
    if (this.getFromEnv('chart').isRealTime) {
      return true;
    }
    return status;
  };

  HeatMapDataset.prototype.createContainer = function createContainer() {
    var dataset = this,
        dsType = dataset.getType(),
        groupName = dataset.groupName,
        chart = dataset.getFromEnv('chart'),
        parent = dataset.getLinkedParent(),
        group = groupName || dataset.dsGroup || dsType,
        parentContainer,
        parentShadowContainer;

    !parent.getChildContainer(group + 'VcanvasGroup') && (group = 'default');
    parentContainer = parent.getChildContainer(group + 'VcanvasGroup');
    parentShadowContainer = parent.getChildContainer(group + 'ShadowVcanvasGroup');

    !dataset.getContainer('shadowGroup') && dataset.addContainer('shadowGroup', createGroup({ name: 'shadow-group' }, parentShadowContainer, dataset));

    !dataset.getContainer('errorShadowGroup') && dataset.addContainer('errorShadowGroup', createGroup({ name: 'error-shadow-group' }, parentShadowContainer, dataset));

    !dataset.getContainer('commonElemsGroup') && dataset.addContainer('commonElemsGroup', createGroup({ name: 'common-elems-group' }, parentContainer, dataset));

    !dataset.getContainer('plotGroup') && dataset.addContainer('plotGroup', createGroup({ name: 'plot-group' }, parentContainer, dataset));

    !dataset.getContainer('errorPlotGroup') && dataset.addContainer('errorPlotGroup', createGroup({ name: 'error-plot-group' }, parentContainer, dataset));
    chart.hasAnchor && dataset.getContainer('errorPlotGroup').insertBefore(dataset.getContainer('plotGroup'));
    !dataset.getContainer('labelGroup') && dataset.addContainer('labelGroup', createGroup({
      name: 'label-group',
      'class': 'fusioncharts-datalabels'
    }, parent.getChildContainer('vcanvasLabelGroup'), dataset));
  };
  /**
   * Create pixel coordinates for the plots
   */


  HeatMapDataset.prototype.createCoordinates = function createCoordinates() {
    var dataSet = this,
        dsComponents = dataSet.components,
        dsData = dsComponents.data,
        chart = dataSet.getFromEnv('chart'),
        isBar = chart.isBar,
        yAxis = dataSet.getFromEnv('yAxis'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yBase = yAxis.getAxisBase(),
        yBasePos = yAxis.getPixel(yBase),
        isVertical = xAxis.config.isVertical,
        dataObj,
        config,
        previousY,
        i,
        Px,
        Py,
        Pb,
        xDepth = chart.config.xDepth || 0,
        yDepth = chart.config.yDepth || 0,
        len = dsData.length,
        components = dataSet.components,
        groupManager = dataSet.getLinkedParent(),
        stackConf = groupManager.getstackConf && groupManager.getstackConf(),
        dataStore = components.data;

    !isBar && (xDepth = -xDepth);
    isBar && (yDepth = -yDepth);

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (dataObj === UNDEF) {
        continue;
      }
      previousY = config._b;
      Px = xAxis.getPixel(stackConf && stackConf[i].x || config._x) + xDepth;
      Py = yAxis.getPixel(config._y) + yDepth;
      Pb = (previousY ? yAxis.getPixel(previousY) : yBasePos) + yDepth;

      if (isVertical) {
        config._Px = Py;
        config._Py = Px;
        config._Pby = Px;
        config._Pbx = Pb;
      } else {
        config._Px = Px;
        config._Py = Py;
        config._Pby = Pb;
        config._Pbx = Px;
      }
      if (dataSet.getLineShift) {
        config._Py += dataSet.getLineShift('y');
      }
    }
  };
  /**
   * Helper function of _firePlotEvent which decides single/consolidated tooltip
   * @param {number} plotIndex      plot index
   * @param {Object} e              reference of the original mouse event
   * @param {Object} datasets            column datasets
   */


  HeatMapDataset.prototype._decideTooltipType = function _decideTooltipType(plotIndex, e) {
    var dataset = this,
        group = dataset.getLinkedParent(),
        chart = dataset.getFromEnv('chart'),
        drawTrendRegion = chart.config.drawTrendRegion,
        components = dataset.components,
        toolTipController = dataset.getFromEnv('toolTipController'),
        dataStore = components.dataRT || components.data,
        data = dataStore[plotIndex],
        toolText = data && (data.config.finalTooltext || data.config.toolText),
        element = data && (data.graphics.element || dataset.graphics.sharedAnchor.element),
        currentToolTip = dataset.config.currentToolTip,
        originalEvent = e.originalEvent;

    if (drawTrendRegion && element) {
      dataset.config.currentToolTip = group._drawTooltip(plotIndex, dataset.config.index, originalEvent, currentToolTip);
    } else if (toolText && !drawTrendRegion) {
      if (currentToolTip) {
        toolTipController.draw(originalEvent, toolText, currentToolTip);
      } else {
        currentToolTip = dataset.config.currentToolTip = toolTipController.draw(originalEvent, toolText);
      }
    }
  };
  /**
   * This method handles all mouse events of an dataset.
   * @param {string} eventType    name of the event
   * @param {number} plotIndex    index of the plot where this event has been occured
   * @param {Event}  e            reference of the original mouse event
   * @param {Event}  datasets     column dataset
   */


  HeatMapDataset.prototype._firePlotEvent = function _firePlotEvent(eventType, plotIndex, e) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        components = dataset.components,
        toolTipController = dataset.getFromEnv('toolTipController'),
        dataStore = components.dataRT || components.data,
        data = dataStore[plotIndex],
        setElement = data.graphics.element,
        toolTip = dataset.config.currentToolTip,

    // originalEvent = e.originalEvent,
    style = chart.getFromEnv('paper').canvas.style,
        config,
        setLink;

    if (setElement) {
      config = data.config;
      setLink = config.setLink;
      switch (eventType) {
        case 'mouseover':
          dataset._decideTooltipType(plotIndex, e);
          _rolloverResponseSetter(chart, data, e, UNDEF, dataset);
          setLink && (style.cursor = POINTER);
          break;
        case 'mouseout':
          toolTipController.hide(toolTip);
          _rolloutResponseSetter(chart, data, e, UNDEF, dataset);
          setLink && (style.cursor = DEFAULT_CURSOR);
          break;
        case 'click':
          _lib.plotEventHandler.call(setElement, chart, e);
          break;
        case 'mousemove':
          dataset._decideTooltipType(plotIndex, e);
      }
    }
  };
  /**
   * Function to remove a data with a given index.
   * @param {number}  index     from which index data would be removed
   * @param {number}  stretch   delete count
   * @param {boolean} draw      whether draw or not
   */


  HeatMapDataset.prototype.removeData = function removeData(index, stretch, draw) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        components = dataSet.components,
        dataStore = components.data,
        removeDataArr = components.removeDataArr || (components.removeDataArr = []),
        conf = dataSet.config,
        i,
        config,
        len,
        maxminFlag = dataSet.maxminFlag;

    stretch === UNDEF && (stretch = 1);
    index = index || 0;

    // Storing the direction of input data for the type of animation to be done during remove.
    if (index + stretch === dataStore.length || !chart.isRealTime) {
      dataSet.endPosition = true;
    } else if (index === 0 || index === UNDEF) {
      dataSet.endPosition = false;
    }
    components.removeDataArr = removeDataArr = removeDataArr.concat(dataStore.splice(index, stretch));
    len = removeDataArr.length;

    for (i = len - 1; i >= 0; i--) {
      if (!removeDataArr[i]) {
        removeDataArr.splice(i, 1);
        continue;
      }
      config = removeDataArr[i].config;
      if (config.setValue === conf.maxValue || config.setValue === conf.minValue) {
        maxminFlag = dataSet.maxminFlag = true;
      }
      // Update the x position for this removed elements outside of the canvas
      config._x -= stretch;
      if (maxminFlag) {
        break;
      }
    }
    dataSet.removeDataLen = len;
    dataSet.resetCatPos && dataSet.resetCatPos();
    maxminFlag && dataSet.getDataLimits && dataSet.getDataLimits();
    draw && dataSet.asyncDraw();
  };

  return HeatMapDataset;
}(_componentInterface2['default']);

exports['default'] = HeatMapDataset;

/***/ }),

/***/ 832:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.heatMap': function initialDatasetHeatMap() {
    return {
      'rect.appearing': function rectAppearing() {
        return [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          slot: 'plot'
        }];
      },
      'text.appearing': function textAppearing() {
        return [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          slot: 'final'
        }];
      },
      '*': null
    };
  }
};

/***/ }),

/***/ 833:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(7);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var HeatMapGroup = function (_ComponentInterface) {
  _inherits(HeatMapGroup, _ComponentInterface);

  /**
   * constructor function this class
   */
  function HeatMapGroup() {
    _classCallCheck(this, HeatMapGroup);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.setState('visible', true);
    _this.getDataLimits = null;
    return _this;
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */


  HeatMapGroup.prototype.getType = function getType() {
    return 'group';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  HeatMapGroup.prototype.getName = function getName() {
    return 'heatMapGroup';
  };

  /**
   * Create child containers
   */


  HeatMapGroup.prototype.createContainer = function createContainer() {
    var manager = this,
        key = void 0,
        parent = manager.getLinkedParent(),
        animationManager = manager.getFromEnv('animationManager'),
        pContainer = void 0,
        parentChildContainers = parent.getChildContainer();

    for (key in parentChildContainers) {
      pContainer = parentChildContainers[key];

      !manager.getChildContainer(key) && manager.addChildContainer(key, animationManager.setAnimation({
        el: 'group',
        attr: { name: 'manager-' + key },
        container: pContainer,
        component: manager,
        label: 'group'
      }));
    }
  };

  HeatMapGroup.prototype.getLimits = function getLimits(allVisible) {
    var manager = this,
        min = +Infinity,
        max = -Infinity,
        maxminObj = void 0,
        numOfColumns = 0,
        getMaxMin = function getMaxMin(_maxminObj) {
      max = Math.max(max, _maxminObj.max);
      min = Math.min(min, _maxminObj.min);
    };

    manager._mapChildren(function (child) {
      if (child.getState('removed') || child.getState('visible') === false) {
        if (allVisible) {
          maxminObj = child.getDataLimits(allVisible);
          getMaxMin(maxminObj);
        }
        return;
      }
      numOfColumns++;
      maxminObj = child.getDataLimits(allVisible);
      getMaxMin(maxminObj);
    });
    if (!numOfColumns) {
      manager.setState('visible', false);
    } else {
      manager.setState('visible', true);
    }
    if (!this.config.range) {
      this.config.range = {};
      this.config.range.min = this.config.dataMin;
      this.config.range.max = this.config.dataMax;
    }
    return { max: max, min: min };
  };
  /**
   * function call sync draw of its children
   */


  HeatMapGroup.prototype.draw = function draw() {
    var manager = this,
        range = manager.getLimits(true);
    manager.addToEnv('datasetMinValue', range.min);
    manager.addToEnv('datasetMaxValue', range.max);
    this.createContainer();
  };

  HeatMapGroup.prototype.getAxisValuePadding = function getAxisValuePadding() {
    var paddingObj = {},
        axisPaddingLeft = -Infinity,
        axisPaddingRight = -Infinity,
        axisPaddingTop = -Infinity,
        axisPaddingBottom = -Infinity;
    this._mapChildren(function (child) {
      if (child.getState('removed')) {
        return;
      }
      paddingObj = child.getAxisValuePadding && child.getAxisValuePadding() || {};
      axisPaddingLeft = Math.max(axisPaddingLeft, paddingObj.left || -Infinity);
      axisPaddingRight = Math.max(axisPaddingRight, paddingObj.right || -Infinity);
      axisPaddingTop = Math.max(axisPaddingTop, paddingObj.top || -Infinity);
      axisPaddingBottom = Math.max(axisPaddingBottom, paddingObj.bottom || -Infinity);
    });
    if (axisPaddingLeft === -Infinity) {
      axisPaddingLeft = 0;
    }
    if (axisPaddingRight === -Infinity) {
      axisPaddingRight = 0;
    }
    if (axisPaddingTop === -Infinity) {
      axisPaddingTop = 0;
    }
    if (axisPaddingBottom === -Infinity) {
      axisPaddingBottom = 0;
    }
    if (!this.config.padding) {
      this.config.padding = {};
      this.config.padding.left = axisPaddingLeft;
      this.config.padding.right = axisPaddingRight;
      this.config.padding.top = axisPaddingTop;
      this.config.padding.bottom = axisPaddingBottom;
    }
    return {
      left: axisPaddingLeft,
      right: axisPaddingRight,
      top: axisPaddingTop,
      bottom: axisPaddingBottom
    };
  };

  return HeatMapGroup;
}(_componentInterface2['default']);

exports['default'] = HeatMapGroup;

/***/ }),

/***/ 834:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var canvas = chart.getChildren('canvas')[0],
      axisRefVisualCartesian = canvas.getChildren('axisRefVisualCartesian')[0],
      zoomObj = {
    zoomable: true,
    pannable: true
  },
      config = chart._feedAxesRawData(),
      yAxis = void 0,
      xAxis = void 0,
      redraw = function redraw() {
    return axisRefVisualCartesian.asyncDraw();
  };

  (0, _lib.componentFactory)(chart, _category2['default'], 'yAxis', 1, config.yAxisConf);
  (0, _lib.componentFactory)(chart, _category2['default'], 'xAxis', 1, config.xAxisConf);

  yAxis = chart.getChildren('yAxis')[0];
  xAxis = chart.getChildren('xAxis')[0];
  yAxis.setLinkedItem('canvas', canvas);
  xAxis.setLinkedItem('canvas', canvas);
  axisRefVisualCartesian.setLinkedItem(yAxis.getId(), yAxis);
  axisRefVisualCartesian.setLinkedItem(xAxis.getId(), xAxis);

  axisRefVisualCartesian.addExtEventListener('visiblerangeset', redraw, xAxis);
  axisRefVisualCartesian.addExtEventListener('visiblerangeset', redraw, yAxis);

  canvas.attachAxis(xAxis, false, chart.zoomX ? zoomObj : {});
  canvas.attachAxis(yAxis, true, chart.zoomY ? zoomObj : {});

  chart._setCategories();
};

var _lib = __webpack_require__(5);

var _category = __webpack_require__(88);

var _category2 = _interopRequireDefault(_category);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 835:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(836);
module.exports = __webpack_require__(41)('Array').indexOf;


/***/ }),

/***/ 836:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(20);
var $indexOf = __webpack_require__(306)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(99)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ 837:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(17);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _multiaxisAxis = __webpack_require__(838);

var _multiaxisAxis2 = _interopRequireDefault(_multiaxisAxis);

var _multiaxisVcanvas = __webpack_require__(866);

var _multiaxisVcanvas2 = _interopRequireDefault(_multiaxisVcanvas);

var _multiaxisDataset = __webpack_require__(867);

var _multiaxisDataset2 = _interopRequireDefault(_multiaxisDataset);

var _forEach = __webpack_require__(37);

var _forEach2 = _interopRequireDefault(_forEach);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var defaultFontStr = _lib.preDefStr.defaultFontStr,
    divLineAlphaStr = _lib.preDefStr.divLineAlphaStr,
    altVGridColorStr = _lib.preDefStr.altVGridColorStr,
    altVGridAlphaStr = _lib.preDefStr.altVGridAlphaStr,
    COLOR_000000 = _lib.preDefStr.colors.c000000,
    POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
    divLineAlpha3DStr = _lib.preDefStr.divLineAlpha3DStr;

/**
 * Class for MultiAxisLine chartAPI
 */

var MultiAxisLine = function (_AreaBase) {
  _inherits(MultiAxisLine, _AreaBase);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MultiAxisLine.getName = function getName() {
    return 'MultiAxisLine';
  };

  /**
   * Constructor function of MultiAxisLine chartAPI
   */


  function MultiAxisLine() {
    _classCallCheck(this, MultiAxisLine);

    var _this = _possibleConstructorReturn(this, _AreaBase.call(this));

    var iapi = _this;
    iapi.friendlyName = 'Multi-axis Line Chart';
    iapi.defaultPlotShadow = 1;
    iapi.axisPaddingLeft = 0;
    iapi.axisPaddingRight = 0;
    _this.registerFactory('axis', _multiaxisAxis2['default'], ['canvas']);
    _this.registerFactory('vCanvas', _multiaxisVcanvas2['default'], ['axis']);
    _this.registerFactory('dataset', _multiaxisDataset2['default'], ['vCanvas']);
    return _this;
  }
  /**
   * This sets default configuration
   * @memberof MultiAxisLine
   */


  MultiAxisLine.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _AreaBase.prototype.__setDefaultConfig && _AreaBase.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.defaultDatasetType = 'multiaxisline';
    config.defaultcrosslinethickness = 1;
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  MultiAxisLine.prototype.getName = function getName() {
    return 'MultiAxisLine';
  };
  /**
   * function to check if the chart specific data is proper is not
   * this fn is define for specific chart types
   * @return {boolean} if JSON data is valid or not
   */


  MultiAxisLine.prototype._checkInvalidSpecificData = function _checkInvalidSpecificData() {
    var jsonData = this.getFromEnv('dataSource'),
        datasetsJSON = jsonData.axis,
        categories = jsonData.categories;
    if (!datasetsJSON || !categories) {
      return true;
    }
  };

  /**
   * Function to configure the axis
   * @return {Object} configurations of axes
   */


  MultiAxisLine.prototype._feedAxesRawData = function _feedAxesRawData() {
    var iapi = this,
        chartConfig = iapi.config,
        colorM = iapi.getFromEnv('color-manager'),
        numberFormatter = iapi.getFromEnv('number-formatter'),
        dataObj = iapi.getFromEnv('dataSource'),
        chartAttrs = dataObj.chart,
        xAxisConf,
        yAxisConf,
        is3D = iapi.config.is3D,
        palleteString = is3D ? _lib.chartPaletteStr.chart3D : _lib.chartPaletteStr.chart2D,
        axes,
        i,
        len,
        isOpposit,
        axisJson,
        plotColor,
        leftAxes,
        rightAxes,
        axisHEXColor,
        gridLineWidth,
        tickWidth,
        axisLineThickness,
        yAxisConfigure = [],
        setAxisConfig = {},
        xAxisConfigure = [],
        j,
        jlen;

    xAxisConf = {
      isVertical: false,
      isReverse: false,
      isOpposit: false,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, defaultFontStr),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.xaxisnamepadding,
      axisValuePadding: chartAttrs.labelpadding,
      axisNameFont: chartAttrs.xaxisnamefont,
      axisNameFontSize: chartAttrs.xaxisnamefontsize,
      axisNameFontColor: chartAttrs.xaxisnamefontcolor,
      axisNameFontBold: chartAttrs.xaxisnamefontbold,
      axisNameFontItalic: chartAttrs.xaxisnamefontitalic,
      axisNameBgColor: chartAttrs.xaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.xaxisnamebordercolor,
      axisNameAlpha: chartAttrs.xaxisnamealpha,
      axisNameFontAlpha: chartAttrs.xaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.xaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.xaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.xaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.xaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.xaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.xaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.xaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.xaxisnameborderdashgap,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      divLineColor: (0, _lib.pluck)(chartAttrs.vdivlinecolor, chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.vdivlinealpha, chartAttrs.divlinealpha, is3D ? colorM.getColor(divLineAlpha3DStr) : colorM.getColor(divLineAlphaStr)),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.vdivlinethickness, chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.vdivlinedashed, chartAttrs.vdivlineisdashed, chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashlen, chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashgap, chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatevgridcolor, 0),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatevgridcolor, colorM.getColor(altVGridColorStr)),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatevgridalpha, colorM.getColor(altVGridAlphaStr)),
      numDivLines: chartAttrs.numvdivlines,
      labelFont: chartAttrs.labelfont,
      labelFontSize: chartAttrs.labelfontsize,
      labelFontColor: chartAttrs.labelfontcolor,
      labelFontBold: chartAttrs.labelfontbold,
      labelFontItalic: chartAttrs.labelfontitalic,
      labelFontAlpha: chartAttrs.labelalpha,
      maxLabelHeight: chartAttrs.maxlabelheight,
      axisName: chartAttrs.xaxisname,
      axisMinValue: chartAttrs.xaxisminvalue,
      axisMaxValue: chartAttrs.xaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptivexmin,
      adjustDiv: chartAttrs.adjustvdiv,
      labelDisplay: chartAttrs.labeldisplay,
      showLabels: chartAttrs.showlabels,
      rotateLabels: chartAttrs.rotatelabels,
      slantLabel: (0, _lib.pluckNumber)(chartAttrs.slantlabels, chartAttrs.slantlabel),
      labelStep: (0, _lib.pluckNumber)(chartAttrs.labelstep, chartAttrs.xaxisvaluesstep),
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showxaxisvalues, chartAttrs.showxaxisvalue),
      showLimits: chartAttrs.showvlimits,
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showvdivlinevalues, chartAttrs.showvdivlinevalues),
      showZeroPlane: chartAttrs.showvzeroplane,
      zeroPlaneColor: chartAttrs.vzeroplanecolor,
      zeroPlaneThickness: chartAttrs.vzeroplanethickness,
      zeroPlaneAlpha: chartAttrs.vzeroplanealpha,
      showZeroPlaneValue: chartAttrs.showvzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showxaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.xaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.xaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.xaxislinecolor, chartAttrs.axislinecolor, COLOR_000000)
    };
    xAxisConfigure.push(xAxisConf);
    yAxisConf = {
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, defaultFontStr),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      showAlternateGridColor: 0,
      axisNameFont: chartAttrs.yaxisnamefont,
      axisNameFontSize: chartAttrs.yaxisnamefontsize,
      axisNameFontColor: chartAttrs.yaxisnamefontcolor,
      axisNameFontBold: chartAttrs.yaxisnamefontbold,
      axisNameFontItalic: chartAttrs.yaxisnamefontitalic,
      axisNameBgColor: chartAttrs.yaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.yaxisnamebordercolor,
      axisNameAlpha: chartAttrs.yaxisnamealpha,
      axisNameFontAlpha: chartAttrs.yaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.yaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.yaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.yaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.yaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.yaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.yaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.yaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.yaxisnameborderdashgap
    };

    leftAxes = {
      'side': 'l',
      axesConf: []
    };
    rightAxes = {
      'side': 'r',
      axesConf: []
    };

    axes = dataObj.axis || [];
    for (i = 0, len = axes.length; i < len; i++) {
      setAxisConfig = {};
      axisJson = axes[i];
      setAxisConfig.checkBoxChecked = false;
      for (j = 0, jlen = axisJson.dataset ? axisJson.dataset.length : 0; j < jlen; j += 1) {
        if (Number(axisJson.dataset[j].visible) !== 0) {
          setAxisConfig.checkBoxChecked = true;
        }
      }
      // showAxis = pluckNumber(axisJson.showaxis, 1);
      plotColor = colorM.getPlotColor(i);
      axisHEXColor = (0, _lib.pluck)(axisJson.color, chartAttrs.axiscolor, plotColor);
      gridLineWidth = (0, _lib.pluckNumber)(axisJson.divlinethickness, chartAttrs.divlinethickness, 1);
      tickWidth = (0, _lib.pluckNumber)(axisJson.tickwidth, chartAttrs.axistickwidth, 2);
      axisLineThickness = (0, _lib.pluckNumber)(axisJson.axislinethickness, chartAttrs.axislinethickness, 2);
      isOpposit = !(0, _lib.pluckNumber)(axisJson.axisonleft, 1);

      yAxisConf.isVertical = true;
      yAxisConf.isReverse = true;
      yAxisConf.isOpposit = isOpposit;
      // add axis configuration
      yAxisConf.labelStep = (0, _lib.pluckNumber)(axisJson.yaxisvaluesstep, axisJson.yaxisvaluestep, chartAttrs.yaxisvaluesstep, chartAttrs.yaxisvaluestep);
      yAxisConf.axisMaxValue = axisJson.maxvalue;
      // yAxisConf.tickWidth = tickWidth;
      yAxisConf.axisMinValue = axisJson.minvalue;
      yAxisConf.setAdaptiveMin = (0, _lib.pluckNumber)(axisJson.setadaptiveymin, chartAttrs.setadaptiveymin);
      yAxisConf.numDivLines = (0, _lib.pluckNumber)(axisJson.numdivlines, chartAttrs.numdivlines, 4);
      yAxisConf.adjustDiv = (0, _lib.pluckNumber)(axisJson.adjustdiv, chartAttrs.adjustdiv);
      yAxisConf.showAxisValues = (0, _lib.pluckNumber)(axisJson.showyaxisvalues, axisJson.showyaxisvalue, chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue, 1);
      yAxisConf.showLimits = (0, _lib.pluckNumber)(axisJson.showlimits, chartAttrs.showyaxislimits, chartAttrs.showlimits, yAxisConf.showAxisValues);
      yAxisConf.showDivLineValues = (0, _lib.pluckNumber)(axisJson.showdivlinevalue, chartAttrs.showdivlinevalues, axisJson.showdivlinevalues, yAxisConf.showAxisValues);
      yAxisConf.showZeroPlane = (0, _lib.pluckNumber)(axisJson.showzeroplane, chartAttrs.showzeroplane);
      yAxisConf.showZeroPlaneValue = (0, _lib.pluckNumber)(axisJson.showzeroplanevalue, chartAttrs.showzeroplanevalue);
      yAxisConf.zeroPlaneColor = axisJson.zeroplanecolor;
      yAxisConf.zeroPlaneThickness = (0, _lib.pluckNumber)(axisJson.zeroplanethickness, axisJson.divlinethickness, chartConfig.zeroplanethickness, 2);
      yAxisConf.zeroPlaneAlpha = (0, _lib.pluckNumber)(axisJson.zeroplanealpha, axisJson.divlinealpha, chartConfig.zeroplanealpha);
      yAxisConf.showZeroPlaneOnTop = chartConfig.showzeroplaneontop;
      yAxisConf.divLineColor = (0, _lib.pluck)(axisJson.divlinecolor, axisHEXColor);
      yAxisConf.divLineAlpha = (0, _lib.pluckNumber)(axisJson.divlinealpha, chartAttrs.divlinealpha, colorM.getColor(divLineAlphaStr), 100);
      yAxisConf.divLineThickness = gridLineWidth;
      yAxisConf.divLineIsDashed = Boolean((0, _lib.pluckNumber)(axisJson.divlinedashed, axisJson.divlineisdashed, chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0));
      yAxisConf.divLineDashLen = (0, _lib.pluckNumber)(axisJson.divlinedashlen, chartAttrs.divlinedashlen, 4);
      yAxisConf.divLineDashGap = (0, _lib.pluckNumber)(axisJson.divlinedashgap, chartAttrs.divlinedashgap, 2);

      yAxisConf.showAxisLine = 1;
      yAxisConf.axisLineThickness = axisLineThickness;
      yAxisConf.axisLineAlpha = 100;
      yAxisConf.axisLineColor = axisHEXColor;
      yAxisConf.tickLength = tickWidth;
      yAxisConf.tickColor = axisHEXColor;
      yAxisConf.tickAlpha = 100;
      yAxisConf.tickWidth = axisLineThickness;
      yAxisConf.axisName = axisJson.title;
      yAxisConf.rotateAxisName = 1;
      yAxisConf.axisNameAlignCanvas = true;
      yAxisConf.drawAxisNameFromBottom = true;

      (0, _lib.extend2)(setAxisConfig, yAxisConf);
      numberFormatter.parseMLAxisConf(axisJson, i);
      if ((0, _lib.pluckNumber)(axisJson.showaxis) === 0) {
        (0, _lib.extend2)(setAxisConfig, {
          axisIndex: i,
          drawAxisLineWRTCanvas: false,
          drawLabels: false,
          drawPlotlines: false,
          drawAxisLine: false,
          drawPlotBands: false,
          drawAxisName: false,
          drawTrendLines: false,
          drawTrendLabels: false,
          drawTick: false,
          drawTickMinor: false,
          showAxis: 0
        });
      } else {
        (0, _lib.extend2)(setAxisConfig, {
          axisIndex: i,
          drawAxisLineWRTCanvas: false,
          drawLabels: true,
          drawPlotlines: true,
          drawAxisLine: true,
          drawPlotBands: true,
          drawAxisName: true,
          drawTrendLines: true,
          drawTrendLabels: true,
          drawTick: true,
          drawTickMinor: true,
          showAxis: 1
        });
      }
      if (isOpposit) {
        rightAxes.axesConf.push(setAxisConfig);
      } else {
        leftAxes.axesConf.push(setAxisConfig);
      }
    }
    leftAxes.axesConf.length && yAxisConfigure.push(leftAxes);
    rightAxes.axesConf.length && yAxisConfigure.push(rightAxes);
    return { xAxisConfigure: xAxisConfigure, yAxisConfigure: yAxisConfigure };
  };
  /**
   * Managing axis and legend space management after the actual space management
   */


  MultiAxisLine.prototype._postSpaceManagement = function _postSpaceManagement() {
    var iapi = this,
        legend = iapi.getFromEnv('legend'),
        showlegend = iapi.config.showLegend,
        axisSelectorUI = iapi.getChildren('yAxisSelectorUI'),
        canvas = iapi.getChildren('canvas')[0];

    iapi.setAxisDimention();
    _forEach2['default'].call(axisSelectorUI, function (comp) {
      comp.setAxisDimention();
    });
    // function for adjusting value padding depending upon data and axis labels.
    canvas.setCanvasPadding();
    iapi.setAxisDimention();
    showlegend && legend.postSpaceManager();
  };
  /**
   * Sets dimension of Axis components
   */


  MultiAxisLine.prototype.setAxisDimention = function setAxisDimention() {
    var iapi = this,
        config = iapi.config,
        xAxis = iapi.getChildren('xAxis')[0],
        xDepth = config.xDepth,
        canvas = iapi.getChildren('canvas')[0],
        canvasConfig = canvas.config,
        canvasBorderWidth = canvasConfig.canvasBorderWidth,
        canvasPadding = canvasConfig.canvasPadding,
        canvasPaddingLeft = canvasConfig.canvasPaddingLeft,
        canvasPaddingRight = canvasConfig.canvasPaddingRight;
    xAxis && xAxis.setAxisDimention({
      x: config.canvasLeft + (xDepth || 0) + Math.max(canvasPaddingLeft, canvasPadding),
      y: config.canvasBottom + (config.shift || 0) + canvasBorderWidth,
      opposite: config.canvasTop - canvasBorderWidth,
      axisLength: config.canvasWidth - (xDepth || 0) - Math.max(canvasPaddingLeft, canvasPadding) - Math.max(canvasPaddingRight, canvasPadding)
    });
  };

  /**
   * Managing the space of all the components of the chart including all the axiss
   */


  MultiAxisLine.prototype._spaceManager = function _spaceManager() {
    // todo marge _allocateSpace and _spacemanager
    var spaceForActionBar,
        actionBarSpace,
        availableWidth,
        availableHeight,
        iapi = this,
        canvas = iapi.getChildren('canvas')[0],
        config = iapi.config,
        showLegend = config.showLegend,

    // axesArr = config.axesArr,
    // components = iapi.components,
    legendPosition = config.legendPosition,

    // axis = config.axisDataSetMap,
    xAxis = iapi.getChildren('xAxis'),

    // yAxis = iapi.getChildren('yAxis'),
    axisSelectorUI = iapi.getChildren('yAxisSelectorUI'),
        hasLegend = config.hasLegend,
        yDepth = config.yDepth,
        legend = iapi.getFromEnv('legend'),

    // axesPadding = config.axesPadding,
    rightPadding = 0,
        leftPadding = 0,

    // length = yAxis.length,
    length = axisSelectorUI.length || 0,

    // yAxisObj,
    i,
        yAxisSpaceUsed,

    // axesMap,
    // leftAxes,
    // rightAxes,
    allotedSpace,

    // mappedAxis,
    is3D = iapi.config.is3D,
        chartAttrs = iapi.getFromEnv('dataSource').chart,
        showBorder = (0, _lib.pluckNumber)(chartAttrs.showborder, is3D ? 0 : 1),
        canvasBorderWidth = iapi.getChildren('canvas')[0].config.canvasBorderWidth,
        chartBorderWidth = config.borderWidth = showBorder ? (0, _lib.pluckNumber)(chartAttrs.borderthickness, 1) : 0,
        canvasMarginTop = config.canvasMarginTop,
        canvasMarginBottom = config.canvasMarginBottom,
        canvasMarginLeft = config.canvasMarginLeft,
        canvasMarginRight = config.canvasMarginRight,
        minCanvasHeight = config.minCanvasHeight,
        minCanvasWidth = config.minCanvasWidth,
        height = config.height,
        width = config.width,
        diff,
        heightAdjust = false,
        widthAdjust = false,
        top,
        bottom,
        left,
        right,
        currentCanvasHeight,
        currentCanvasWidth,
        origCanvasTopMargin = config.origCanvasTopMargin,
        origCanvasBottomMargin = config.origCanvasBottomMargin,
        origCanvasLeftMargin = config.origCanvasLeftMargin,
        origCanvasRightMargin = config.origCanvasRightMargin,
        sum;
    //* ***** Manage space
    iapi._allocateSpace({
      top: chartBorderWidth,
      bottom: chartBorderWidth,
      left: chartBorderWidth,
      right: chartBorderWidth
    });

    iapi._allocateSpace({
      left: config.canvasMarginLeft,
      right: config.canvasMarginRight
    });
    //* ***** Manage space
    if (legendPosition === 'right') {
      allotedSpace = config.canvasWidth * 0.3;
    } else {
      allotedSpace = config.canvasHeight * 0.3;
    }
    // No space is allocated for legend drawing in single series charts
    hasLegend !== false && xAxis && showLegend && iapi._allocateSpace(legend._manageLegendPosition(allotedSpace));

    // @todo uncomment this code
    for (i = 0; i < length; i++) {
      yAxisSpaceUsed = axisSelectorUI[i].placeAxis(config.canvasWidth);
      rightPadding += yAxisSpaceUsed.rightPadding;
      leftPadding += yAxisSpaceUsed.leftPadding;
      iapi._allocateSpace(yAxisSpaceUsed.dimension);
    }
    spaceForActionBar = config.availableHeight * 0.225;
    actionBarSpace = iapi._manageActionBarSpace && iapi._manageActionBarSpace(spaceForActionBar) || {};
    iapi._allocateSpace(actionBarSpace);

    availableHeight = legendPosition === POSITION_BOTTOM ? config.canvasHeight * 0.6 : config.canvasWidth * 0.6;
    iapi._manageChartMenuBar(availableHeight);
    availableWidth = config.canvasWidth * 0.7;
    if (availableWidth > rightPadding + leftPadding) {
      iapi._allocateSpace({
        'left': leftPadding,
        'right': rightPadding
      });
    }
    availableHeight = config.canvasHeight * 0.6;
    xAxis[0] && iapi._allocateSpace(xAxis[0].placeAxis(availableHeight));
    // alocate the space for datasets
    availableHeight = config.canvasHeight * 0.325;
    iapi._getDSspace && iapi._allocateSpace(iapi._getDSspace(availableHeight));

    if (yDepth) {
      iapi._allocateSpace({
        bottom: yDepth
      });
      // shift = xDepth + canvasBasePadding + canvasBaseDepth;
    }

    iapi._allocateSpace({
      top: canvasBorderWidth,
      bottom: canvasBorderWidth,
      left: canvasBorderWidth,
      right: canvasBorderWidth
    });
    // Allocate space for canvas margin only if the margin is less than the margin entered by the user.
    top = canvasMarginTop > config.canvasTop ? canvasMarginTop - config.canvasTop : 0;
    bottom = canvasMarginBottom > height - config.canvasBottom ? canvasMarginBottom + config.canvasBottom - height : 0;
    left = canvasMarginLeft > config.canvasLeft ? canvasMarginLeft - config.canvasLeft : 0;
    right = canvasMarginRight > width - config.canvasRight ? canvasMarginRight + config.canvasRight - width : 0;

    iapi._allocateSpace({
      top: top,
      bottom: bottom,
      left: left,
      right: right
    });
    // Forcing canvas height to its minimum
    if (heightAdjust) {
      sum = origCanvasTopMargin + origCanvasBottomMargin;
      currentCanvasHeight = config.canvasHeight;
      if (currentCanvasHeight > minCanvasHeight) {
        diff = currentCanvasHeight - minCanvasHeight;
        top = diff * origCanvasTopMargin / sum;
        bottom = diff * origCanvasBottomMargin / sum;
      }
      iapi._allocateSpace({
        top: top,
        bottom: bottom
      });
    }

    // Forcing canvas width to its minimum
    if (widthAdjust) {
      sum = origCanvasLeftMargin + origCanvasRightMargin;
      currentCanvasWidth = config.canvasWidth;
      if (currentCanvasWidth > minCanvasWidth) {
        diff = currentCanvasWidth - minCanvasWidth;
        left = diff * origCanvasLeftMargin / sum;
        right = diff * origCanvasRightMargin / sum;
      }
      iapi._allocateSpace({
        left: left,
        right: right
      });
    }

    config.actualCanvasMarginTop = top;
    config.actualCanvasMarginLeft = left;
    config.actualCanvasMarginRight = right;
    config.actualCanvasMarginBottom = bottom;

    canvas.setDimension({
      top: config.canvasTop,
      left: config.canvasLeft,
      width: config.canvasWidth,
      height: config.canvasHeight
    });
  };

  /**
   * Function to parse some additional parameters of the chart
   * @param  {Object} dataObj contains json data of the chart
   */


  MultiAxisLine.prototype.configure = function configure(dataObj) {
    _AreaBase.prototype.configure.call(this, dataObj);
    var iapi = this,
        conf = iapi.config,
        chartAttr = iapi.getFromEnv('dataSource').chart;

    conf.axesPadding = 5;
    conf.allowAxisShift = (0, _lib.pluckNumber)(chartAttr.allowaxisshift, 1);
    conf.allowSelection = (0, _lib.pluckNumber)(chartAttr.allowselection, 1);
    conf.checkBoxColor = (0, _lib.pluck)(chartAttr.checkboxcolor, '#2196f3');
    conf.axisConfigured = true;
  };

  return MultiAxisLine;
}(_fusioncharts2['default']);

exports['default'] = MultiAxisLine;

/***/ }),

/***/ 838:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var canvas = chart.getChildren('canvas')[0],
      axisRefVisualCartesian = canvas.getChildren('axisRefVisualCartesian')[0],
      configure = void 0,
      xAxis = void 0,
      redraw = function redraw() {
    return axisRefVisualCartesian.asyncDraw();
  };
  configure = chart._feedAxesRawData();
  _axisSelectorUi2['default'].resetAxisCount();
  (0, _lib.componentFactory)(chart, _axisSelectorUi2['default'], 'yAxisSelectorUI', configure.yAxisConfigure && configure.yAxisConfigure.length, configure.yAxisConfigure);
  (0, _lib.componentFactory)(chart, _category2['default'], 'xAxis', 1, configure.xAxisConfigure);
  xAxis = chart.getChildren('xAxis')[0];
  xAxis.setLinkedItem('canvas', canvas);
  axisRefVisualCartesian.setLinkedItem(xAxis.getId(), xAxis);
  axisRefVisualCartesian.addExtEventListener('visiblerangeset', redraw, xAxis);
  canvas.attachAxis(xAxis, false);
  canvas.setPrimaryAxis('xAxis', xAxis);
  chart._setCategories();
};

var _lib = __webpack_require__(5);

var _category = __webpack_require__(88);

var _category2 = _interopRequireDefault(_category);

var _axisSelectorUi = __webpack_require__(839);

var _axisSelectorUi2 = _interopRequireDefault(_axisSelectorUi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 839:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(7);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _lib = __webpack_require__(5);

var _numeric = __webpack_require__(69);

var _numeric2 = _interopRequireDefault(_numeric);

var _map = __webpack_require__(840);

var _map2 = _interopRequireDefault(_map);

var _from = __webpack_require__(863);

var _from2 = _interopRequireDefault(_from);

var _forEach = __webpack_require__(37);

var _forEach2 = _interopRequireDefault(_forEach);

var _map3 = __webpack_require__(27);

var _map4 = _interopRequireDefault(_map3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var BLANKSTRING = '',
    swap = function swap(a, b, map) {
  var e1 = [a, map.get(a)],
      e2 = [b, map.get(b)],
      mapArray = (0, _from2['default'])(map.entries()),
      newMapArray = _map4['default'].call(mapArray, function (_ref) {
    var key = _ref[0],
        value = _ref[1];

    if (key === a) {
      return e2;
    } else if (key === b) {
      return e1;
    } else {
      return [key, value];
    }
  });
  return new _map2['default'](newMapArray);
},
    factoryAxis = function factoryAxis(parent) {
  var axesConf = parent.config.axesConf,
      axes = void 0,
      axisMapById = void 0,
      activeAxis = void 0,
      exsitingAxisMapById = parent.config.axisMapById,
      existingAxes = exsitingAxisMapById && (0, _from2['default'])(exsitingAxisMapById.keys()) || [],
      info = void 0,
      firstAxis = true,
      canvas = parent.getFromEnv('chart').getChildren('canvas')[0],
      axisRefVisualCartesian = canvas.getChildren('axisRefVisualCartesian')[0],
      redraw = function redraw() {
    return axisRefVisualCartesian.asyncDraw();
  },
      removeId = function removeId(id) {
    var index = existingAxes.indexOf(id);
    index !== -1 && existingAxes.splice(index, 1);
  },
      removeInfo = function removeInfo(_existingAxes, _axisMapById) {
    var key = void 0,
        _info = void 0,
        i = void 0;
    for (i = _existingAxes.length - 1; i > -1; i--) {
      key = _existingAxes[i];
      _info = _axisMapById.get(key);
      _info.checkbox && _info.checkbox.hide();
      _info.axis && _info.axis.hide();
      _axisMapById['delete'](key);
    }
  };

  (0, _lib.componentFactory)(parent, _numeric2['default'], 'yAxis', axesConf.length, axesConf);

  axes = (parent.getChildren('yAxis') || []).slice(0);
  axisMapById = parent.config.axisMapById = new _map2['default']();
  _forEach2['default'].call(axes.reverse(), function (axis) {
    if (axis.getState('removed') || axis.config.showaxis === 0) {
      return;
    }
    var axisId = axis.getId();
    info = {};
    info.axis = axis;
    axisMapById.set(axisId, info);
    if (axis.config.showaxis === 0) {
      axis.hide();
    } else {
      axis.show();
    }
    canvas.attachAxis(axis, true);
    firstAxis && (parent.config.besideCanvas = axisId);
    firstAxis = false;
    if (!axisCount) {
      activeAxis = axis;
    }
    axis.setLinkedItem('canvas', canvas);
    axisRefVisualCartesian.setLinkedItem(axis.getId(), axis);
    axisRefVisualCartesian.addExtEventListener('visiblerangeset', redraw, axis);
    axisCount++;
    removeId(axisId);
  });
  activeAxis && canvas.setPrimaryAxis('yAxis', activeAxis);
  removeInfo(existingAxes, exsitingAxisMapById);
},
    axisCount = 0,
    cbIdCount = 0;
/**
 * This module handles the customized UI for axis in multiaxis charts
 */

var AxisSelectorUI = function (_ComponentInterface) {
  _inherits(AxisSelectorUI, _ComponentInterface);

  /**
   * constructor fn
   */
  function AxisSelectorUI() {
    _classCallCheck(this, AxisSelectorUI);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.registerFactory('axis', factoryAxis);
    return _this;
  }
  /**
   * reset axis count
   */


  AxisSelectorUI.resetAxisCount = function resetAxisCount() {
    axisCount = 0;
  };
  /**
   * function to configure this component by given configuration
   * @param {Object} conf configuration object
   */


  AxisSelectorUI.prototype.configureAttributes = function configureAttributes() {
    var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var axisSelectorUI = this,
        config = axisSelectorUI.config;
    config.axesConf = conf.axesConf || [];
    config.checkboxesConf = conf.checkboxesConf || [];
    config.side = conf.side;
  };
  /**
   * function to allocate and calculate total required space
   * @param {Number} availableWidth avialable width to allocated
   */


  AxisSelectorUI.prototype.placeAxis = function placeAxis(availableWidth) {
    var axisSelectorUI = this,
        conf = axisSelectorUI.config,
        side = conf.side,
        axisMapById = axisSelectorUI.getAxesDetails(),
        axesPadding = axisSelectorUI.getFromEnv('chartConfig').axesPadding,
        rightPadding = 0,
        leftPadding = 0,
        dim = void 0,
        dimension = {
      right: 0,
      left: 0
    };

    axisMapById.forEach(function (info) {
      var value = info.value || (info.value = {}),
          axis = info.axis;
      if (axis.getState('removed') || axis.config.showaxis === 0) {
        return;
      }
      dim = axis.placeAxis(availableWidth * 0.7);
      if (side === 'r') {
        availableWidth -= value.width = dim.right;
        dimension.right += dim.right;
        rightPadding += axesPadding;
      } else {
        availableWidth -= value.width = dim.left;
        dimension.left += dim.left;
        leftPadding += axesPadding;
      }
    });

    return { dimension: dimension, rightPadding: rightPadding, leftPadding: leftPadding };
  };
  /**
   * calculate post space management related calculation
   */


  AxisSelectorUI.prototype.setAxisDimention = function setAxisDimention() {
    var axisSelectorUI = this,
        conf = axisSelectorUI.config,
        axisMapById = axisSelectorUI.getAxesDetails(),
        chart = axisSelectorUI.getFromEnv('chart'),
        axesPadding = axisSelectorUI.getFromEnv('chartConfig').axesPadding,
        canvasConfig = chart.getChildren('canvas')[0].config,
        canvasBorderWidth = canvasConfig.canvasBorderWidth,
        canvasPaddingTop = canvasConfig.canvasPaddingTop,
        canvasPaddingBottom = canvasConfig.canvasPaddingBottom,
        canvasLeft = canvasConfig.canvasLeft,
        canvasTop = canvasConfig.canvasTop,
        canvasHeight = canvasConfig.canvasHeight,
        canvasRight = canvasLeft + canvasConfig.canvasWidth,
        isRight = conf.side === 'r',
        oppositePos = conf.side === 'r' ? canvasLeft - canvasBorderWidth : canvasRight + canvasBorderWidth,
        padding = 0;

    axisMapById.forEach(function (info) {
      var value = info.value || (info.value = {}),
          axis = info.axis;
      if (axis.config.showaxis === 0 || axis.getState('removed')) {
        return;
      }

      if (isRight) {
        value.x = canvasRight + canvasBorderWidth + padding + axesPadding;
      } else {
        value.x = canvasLeft - canvasBorderWidth - padding - axesPadding;
      }
      value.y = canvasTop + canvasPaddingTop;
      value.height = canvasHeight - canvasPaddingTop - canvasPaddingBottom;
      value.opposite = oppositePos;
      padding += value.width + axesPadding;

      axis.setAxisDimention({
        x: value.x,
        y: value.y,
        opposite: value.opposite,
        axisLength: value.height
      });
    });
  };
  /**
   * function to draw hot elements of axes.
   * It helps to interact with axes
   */


  AxisSelectorUI.prototype.drawHotElements = function drawHotElements() {
    var axisSelectorUI = this,
        conf = axisSelectorUI.config,
        isRight = conf.side === 'r',
        chartConfig = axisSelectorUI.getFromEnv('chartConfig'),
        allowAxisShift = chartConfig.allowAxisShift,
        chart = axisSelectorUI.getFromEnv('chart'),
        paper = axisSelectorUI.getFromEnv('paper'),
        trackerContainer = chart.getChildContainer('trackerGroup'),
        axisMapById = conf.axisMapById,
        axisHotElements = axisSelectorUI.getGraphicalElement('axisHotElement') || [],
        canvas = chart.getChildren('canvas')[0],
        k = void 0,
        length = void 0,
        counter = -1,
        attr = {
      cursor: 'col-resize',
      stroke: _lib.TRACKER_FILL,
      fill: _lib.TRACKER_FILL,
      ishot: true,
      visibility: true
    };

    if (allowAxisShift) {
      axisMapById.forEach(function (info, key) {
        var hotElement = void 0,
            value = info.value;
        attr.x = value.x + (isRight ? 0 : -value.width);
        attr.y = value.y;
        attr.width = value.width;
        attr.height = value.height;
        // Creating the hot element if not created
        if (!(hotElement = axisHotElements[++counter])) {
          hotElement = axisSelectorUI.addGraphicalElement('axisHotElement', paper.rect(trackerContainer), true);
          if (_lib.hasTouch) {
            hotElement.touchstart(axisSelectorUI._resuffelAxis);
          } else {
            hotElement.mousedown(axisSelectorUI._resuffelAxis);
          }
        }
        hotElement.attr(attr).data('axisDetails', {
          axisSelectorUI: axisSelectorUI,
          canvas: canvas,
          axisId: key
        });
      });
    }

    for (k = counter + 1, length = axisHotElements.length; k < length; k++) {
      axisSelectorUI.removeGraphicalElement(axisHotElements[k]);
    }
  };
  /**
   * function to draw checkboxes
   */


  AxisSelectorUI.prototype.drawCheckBoxes = function drawCheckBoxes() {
    var axisSelectorUI = this,
        conf = axisSelectorUI.config,
        chartId = axisSelectorUI.getFromEnv('chartInstance').id,
        chartConfig = axisSelectorUI.getFromEnv('chartConfig'),
        allowSelection = chartConfig.allowSelection,
        chart = axisSelectorUI.getFromEnv('chart'),
        checkBoxContainer = chart.getChildContainer('buttonGroup'),
        toolBoxAPI = axisSelectorUI.getFromEnv('toolBoxAPI'),
        tb = axisSelectorUI.getFromEnv('toolbox'),
        CheckboxSymbol = toolBoxAPI.CheckboxSymbol,
        isRight = conf.side === 'r',
        axisMapById = conf.axisMapById,
        checkboxTopPadding = 4;

    if (allowSelection) {
      axisMapById.forEach(function (info, key) {
        var value = info.value,
            currCheckBox = info.checkbox,
            axis = info.axis,
            padding = isRight ? info.axis.getAxisConfig('axisNamePadding') : -value.width;

        if (!currCheckBox) {
          currCheckBox = info.checkbox = new CheckboxSymbol();
          currCheckBox.configure(BLANKSTRING, true, cbIdCount++, tb.pId, chartId);
          currCheckBox.config.conf = tb.getDefaultConfiguration();
          currCheckBox.attachEventHandlers({
            click: {
              fn: axisSelectorUI._dolegendInteraction,
              args: [key, chart]
            }
          });
        }
        currCheckBox.draw(value.x + padding, value.y + value.height + checkboxTopPadding, {
          parentLayer: checkBoxContainer
        });

        currCheckBox.config.node.attr({
          stroke: (0, _lib.toRaphaelColor)({
            color: chartConfig.checkBoxColor,
            alpha: 100,
            'stroke-width': [1, 2]
          })
        });
        if (axis.config.checkBoxChecked) {
          currCheckBox.check();
        } else {
          currCheckBox.uncheck();
        }
      });
    }
  };
  /**
   * function to handle draw job
   */


  AxisSelectorUI.prototype.draw = function draw() {
    this.drawHotElements();
    this.drawCheckBoxes();
  };
  /**
   * Function to swap axis on click
   */


  AxisSelectorUI.prototype._resuffelAxis = function _resuffelAxis() {
    var data = this.data('axisDetails'),
        axisSelectorUI = data.axisSelectorUI,
        conf = axisSelectorUI.config,
        canvas = data.canvas,
        axisId = data.axisId,
        axesDetails = axisSelectorUI.getAxesDetails();
    if (conf.besideCanvas !== axisId) {
      axesDetails = axisSelectorUI.config.axisMapById = swap(conf.besideCanvas, axisId, axesDetails);
    }
    conf.besideCanvas = axisId;
    canvas.setPrimaryAxis('yAxis', axesDetails.get(axisId).axis);
    axisSelectorUI.setAxisDimention();

    // before drawing, we need to parse all the labels position again
    axisSelectorUI.setPosition();
    axisSelectorUI.syncDraw();
    canvas.getChildren('axisRefVisualCartesian')[0].draw(true);
  };
  /**
   * Function to manipulate legends on checkbox click
   * @param {number} axisIndex The index of the axis against which the checkbox is clicked
   * @param {Object} chart the chart object
   */


  AxisSelectorUI.prototype._dolegendInteraction = function _dolegendInteraction(axisId, chart) {
    var checkbox = this,
        datasets = [],

    // legend = iapi.getChildren('legend'),
    obj,
        dataset;

    chart.iterateComponents(function (child) {
      if (child.getType() === 'dataset') {
        datasets.push(child);
      }
    });

    for (obj in datasets) {
      if (datasets.hasOwnProperty(obj)) {
        dataset = datasets[obj];
        if (dataset.getFromEnv('yAxis').getId() === axisId) {
          if (!dataset.getState('visible') && checkbox.config.checked) {
            dataset.config.legendInteractivity = true;
            dataset.show();
          } else if (dataset.getState('visible') && !checkbox.config.checked) {
            dataset.config.legendInteractivity = true;
            dataset.hide();
          }
        }
      }
    }
    // legend.drawLegend();
  };
  /**
   * Function to change the state of the checkbox when legend is clicked
   * @param {Object} e The evet object
   */


  AxisSelectorUI.prototype.manipulateCheckBox = function manipulateCheckBox(e) {
    var axisSelectorUI = this,
        data = e.data,
        clickedDS = data.dataset,
        axisId = clickedDS.getFromEnv('yAxis').getId(),
        vCanvas = clickedDS.getLinkedParent(),
        allDS = vCanvas.getChildren().dataset,
        state = data.state,
        checkboxUncheck = true,
        i,
        len,
        dataset,
        info,
        axisMapById = axisSelectorUI.getAxesDetails();

    if (!(info = axisMapById.get(axisId))) {
      return;
    }
    if (state === 'hide') {
      for (i = 0, len = allDS.length; i < len; i++) {
        dataset = allDS[i];
        if (dataset.getState('visible')) {
          checkboxUncheck = false;
        }
      }
      if (checkboxUncheck) {
        info.checkbox && info.checkbox.uncheck();
      }
    } else {
      info.checkbox && info.checkbox.check();
    }
  };
  /**
   * return axis components
   * @return {Object} axesMap
   */


  AxisSelectorUI.prototype.getAxesDetails = function getAxesDetails() {
    return this.config.axisMapById;
  };
  /**
   * return type of this component
   */


  AxisSelectorUI.prototype.getType = function getType() {
    return 'customAxisUI';
  };
  /**
   * return name of this component
   */


  AxisSelectorUI.prototype.getName = function getName() {
    return 'multiAxisSelectorUI';
  };
  /**
   * function to return axes attached to this comp.
   * This API is for external invocation whre the axes
   * is required from the outside components.
   * @return {Array} - axes
   */


  AxisSelectorUI.prototype.getAxes = function getAxes() {
    return (0, _from2['default'])(this.config.axisMapById.values()).map(function (elem) {
      return elem.axis;
    });
  };

  return AxisSelectorUI;
}(_componentInterface2['default']);

exports['default'] = AxisSelectorUI;

/***/ }),

/***/ 840:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(841);
__webpack_require__(373);
__webpack_require__(847);
__webpack_require__(849);
__webpack_require__(856);
__webpack_require__(859);
__webpack_require__(861);
module.exports = __webpack_require__(48).Map;


/***/ }),

/***/ 841:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(234);
var test = {};
test[__webpack_require__(24)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(78)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),

/***/ 842:
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(167);
var defined = __webpack_require__(166);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ 843:
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ 844:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(374);
var descriptor = __webpack_require__(118);
var setToStringTag = __webpack_require__(236);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(76)(IteratorPrototype, __webpack_require__(24)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ 845:
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(60);
var anObject = __webpack_require__(77);
var getKeys = __webpack_require__(203);

module.exports = __webpack_require__(61) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ 846:
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(63);
var toObject = __webpack_require__(79);
var IE_PROTO = __webpack_require__(205)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ 847:
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(848);
var getKeys = __webpack_require__(203);
var redefine = __webpack_require__(78);
var global = __webpack_require__(39);
var hide = __webpack_require__(76);
var Iterators = __webpack_require__(112);
var wks = __webpack_require__(24);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ 848:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(122);
var step = __webpack_require__(375);
var Iterators = __webpack_require__(112);
var toIObject = __webpack_require__(133);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(235)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ 849:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(850);
var validate = __webpack_require__(382);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(852)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),

/***/ 850:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(60).f;
var create = __webpack_require__(374);
var redefineAll = __webpack_require__(376);
var ctx = __webpack_require__(64);
var anInstance = __webpack_require__(377);
var forOf = __webpack_require__(145);
var $iterDefine = __webpack_require__(235);
var step = __webpack_require__(375);
var setSpecies = __webpack_require__(851);
var DESCRIPTORS = __webpack_require__(61);
var fastKey = __webpack_require__(381).fastKey;
var validate = __webpack_require__(382);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ 851:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(39);
var dP = __webpack_require__(60);
var DESCRIPTORS = __webpack_require__(61);
var SPECIES = __webpack_require__(24)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ 852:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(39);
var $export = __webpack_require__(20);
var redefine = __webpack_require__(78);
var redefineAll = __webpack_require__(376);
var meta = __webpack_require__(381);
var forOf = __webpack_require__(145);
var anInstance = __webpack_require__(377);
var isObject = __webpack_require__(40);
var fails = __webpack_require__(62);
var $iterDetect = __webpack_require__(383);
var setToStringTag = __webpack_require__(236);
var inheritIfRequired = __webpack_require__(853);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ 853:
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(40);
var setPrototypeOf = __webpack_require__(854).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ 854:
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(40);
var anObject = __webpack_require__(77);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(64)(Function.call, __webpack_require__(855).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ 855:
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(308);
var createDesc = __webpack_require__(118);
var toIObject = __webpack_require__(133);
var toPrimitive = __webpack_require__(254);
var has = __webpack_require__(63);
var IE8_DOM_DEFINE = __webpack_require__(252);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(61) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ 856:
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(20);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(857)('Map') });


/***/ }),

/***/ 857:
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(234);
var from = __webpack_require__(858);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),

/***/ 858:
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(145);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),

/***/ 859:
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(860)('Map');


/***/ }),

/***/ 860:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(20);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),

/***/ 861:
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(862)('Map');


/***/ }),

/***/ 862:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(20);
var aFunction = __webpack_require__(165);
var ctx = __webpack_require__(64);
var forOf = __webpack_require__(145);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),

/***/ 863:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(373);
__webpack_require__(864);
module.exports = __webpack_require__(48).Array.from;


/***/ }),

/***/ 864:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(64);
var $export = __webpack_require__(20);
var toObject = __webpack_require__(79);
var call = __webpack_require__(378);
var isArrayIter = __webpack_require__(379);
var toLength = __webpack_require__(65);
var createProperty = __webpack_require__(865);
var getIterFn = __webpack_require__(380);

$export($export.S + $export.F * !__webpack_require__(383)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ 865:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(60);
var createDesc = __webpack_require__(118);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ 866:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var canvas = chart.getChildren('canvas')[0],
      jsonData = chart.getFromEnv('dataSource'),
      axisSelectorUI = chart.getChildren('yAxisSelectorUI'),
      axisY = jsonData.axis,
      vCanvas = void 0,
      axes = void 0,
      xAxis = [],
      yAxis = [],
      vC = void 0,
      i = void 0,
      k = void 0,
      j = void 0;

  axes = chart.getChildren('xAxis');
  for (k = 0; k < (axes && axes.length); k++) {
    if (!axes[k].getState('removed')) {
      xAxis.push(axes[k]);
    }
  }
  axisSelectorUI.forEach(function (comp) {
    axes = comp.getChildren('yAxis');
    for (k = 0; k < (axes && axes.length); k++) {
      if (!axes[k].getState('removed')) {
        yAxis.push(axes[k]);
      }
    }
  });

  (0, _lib.componentFactory)(canvas, _vcanvas2['default'], 'vCanvas', xAxis.length * yAxis.length);
  vCanvas = canvas.getChildren('vCanvas');
  for (i = 0, k = 0; i < (xAxis && xAxis.length); i++) {
    for (j = 0; j < (yAxis && yAxis.length); j++, k++) {
      vC = vCanvas[k];
      vC.configure();
      vC.xAxis(xAxis[i]).yAxis(yAxis[j]).canvas(canvas);
      vC.addToEnv('axisData', axisY[k]);
      vC.addToEnv('vCanvas', vCanvas[k]);
    }
  }
};

var _vcanvas = __webpack_require__(312);

var _vcanvas2 = _interopRequireDefault(_vcanvas);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 867:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var datasetsJSON = void 0,
      prevLength = 0,
      length = void 0,
      indices = void 0,
      vC = void 0,
      children = chart.getChildren(),
      yAxisSelectorUI = children.yAxisSelectorUI,
      canvas = children.canvas[0],
      vCanvas = canvas.getChildren('vCanvas');

  for (var i = 0, len = vCanvas.length; i < len; i++) {
    vC = vCanvas[i];
    if (vC.getState('removed')) {
      continue;
    }
    datasetsJSON = vC.getFromEnv('axisData').dataset;
    // vC.addToEnv('axisData', axis);
    if (datasetsJSON) {
      length = datasetsJSON.length;
      indices = _map2['default'].call(_fill2['default'].call(Array(length), i * prevLength), function (n, j) {
        return n + j;
      });
      (0, _lib.datasetFactory)(vC, _multiaxisline2['default'], 'dataset', length, datasetsJSON, indices);
      prevLength = length;
      children = vC.getChildren('dataset');
      // Adding event listeners to each dataset
      children.forEach(function (dataset) {
        dataset.addEventListener('datasetVisibilityChanged', function (e) {
          yAxisSelectorUI.forEach(function (comp) {
            comp.manipulateCheckBox(e);
          });
        });
      });
    }
  }
};

var _lib = __webpack_require__(5);

var _multiaxisline = __webpack_require__(868);

var _multiaxisline2 = _interopRequireDefault(_multiaxisline);

var _fill = __webpack_require__(139);

var _fill2 = _interopRequireDefault(_fill);

var _map = __webpack_require__(27);

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 868:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _multiaxisAnimation = __webpack_require__(869);

var _multiaxisAnimation2 = _interopRequireDefault(_multiaxisAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


(0, _dependencyManager.addDep)({
  name: 'multiAxislineAnimation',
  type: 'animationRule',
  extension: _multiaxisAnimation2['default']
});
/**
 * Class for MultiAxisLine chartAPI
 */

var MultiAxisDataset = function (_Line) {
  _inherits(MultiAxisDataset, _Line);

  function MultiAxisDataset() {
    _classCallCheck(this, MultiAxisDataset);

    return _possibleConstructorReturn(this, _Line.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  MultiAxisDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  MultiAxisDataset.prototype.getName = function getName() {
    return 'multiAxis';
  };
  /**
   * Function to configure the data given by the user at the dataset level
   * @param {Object} datasetJSON JSON for dataset configurations
   * @return {boolean} False if no datasetJSON present
   */


  MultiAxisDataset.prototype.configure = function configure(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.config.JSONData = datasetJSON;

    var dataSet = this,

    // chart = dataSet.chart,
    jsonData = dataSet.config.JSONData,
        dataSetConfig = dataSet.config,

    // conf = dataSet.getFromEnv('chartConfig'),
    // components = chart.components,
    // chartJSON = chart.jsonData,
    // axes = chartJSON.axis,
    chartAttr = dataSet.getFromEnv('chart-attrib'),
        axis = dataSet.getFromEnv('axisData'),

    // singleSeries = chart.config.singleseries,
    // Line = FusionCharts.get(COMPONENT, [DATASET, LINE]).prototype,
    // yAxis,
    lineDashStyle,
        lineDashed;

    _Line.prototype.configure.call(this, datasetJSON);
    // yAxis = components.yAxis[dataSet.axisIndex];
    // dataSet.yAxis = yAxis;

    dataSetConfig.linethickness = (0, _lib.pluckNumber)(jsonData.linethickness, axis.linethickness, chartAttr.linethickness, 2);
    dataSetConfig.lineDashLen = (0, _lib.pluckNumber)(jsonData.linedashlen, axis.linedashlen, chartAttr.linedashlen, 5);
    dataSetConfig.lineDashGap = (0, _lib.pluckNumber)(jsonData.linedashgap, axis.linedashgap, chartAttr.linedashgap, 4);
    dataSetConfig.alpha = (0, _lib.pluckNumber)(jsonData.alpha, axis.linealpha, chartAttr.linealpha, _lib.HUNDREDSTRING);
    dataSetConfig.linecolor = (0, _lib.pluck)(jsonData.color, axis.linecolor, axis.color, chartAttr.linecolor, dataSetConfig.plotColor);

    dataSetConfig.legendSymbolColor = dataSet.getName() === 'line' ? dataSetConfig.lineColor : dataSetConfig.plotFillColor;
    lineDashed = (0, _lib.pluckNumber)(jsonData.dashed, axis.linedashed, chartAttr.linedashed);
    lineDashStyle = (0, _lib.getDashStyle)(dataSetConfig.lineDashLen, dataSetConfig.lineDashGap);
    dataSetConfig.anchorBorderColor = (0, _lib.pluck)(jsonData.anchorbordercolor, chartAttr.anchorbordercolor, dataSetConfig.lineColor, dataSetConfig.plotColor);
    dataSetConfig.lineDashStyle = lineDashed ? lineDashStyle : 'none';
    _Line.prototype._setConfigure.call(this);
    // (chart.config.hasLegend !== false) && dataSet._addLegend();
  };

  return MultiAxisDataset;
}(_line2['default']);

exports['default'] = MultiAxisDataset;

/***/ }),

/***/ 869:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lineAnimation = __webpack_require__(25);

var _lineAnimation2 = _interopRequireDefault(_lineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.dataset.multiAxis': _lineAnimation2['default']['initial.dataset.line']
};

/***/ }),

/***/ 870:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(71);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _boxandwhisker2d = __webpack_require__(871);

var _boxandwhisker2d2 = _interopRequireDefault(_boxandwhisker2d);

var _boxandwhisker = __webpack_require__(875);

var _boxandwhisker2 = _interopRequireDefault(_boxandwhisker);

var _lib = __webpack_require__(5);

var _boxandwhiskerDataset = __webpack_require__(876);

var _boxandwhiskerDataset2 = _interopRequireDefault(_boxandwhiskerDataset);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


_lib.setAttribDefs && (0, _lib.setAttribDefs)({
  whiskerslimitswidthratio: {
    type: _lib.attrTypeNum,
    pAttr: 'whiskerslimitswidthratio'
  },
  outliersupperrangeratio: {
    type: _lib.attrTypeNum,
    pAttr: 'outliersupperrangeratio'
  },
  outlierslowerrangeratio: {
    type: _lib.attrTypeNum,
    pAttr: 'outlierslowerrangeratio'
  },
  showalloutliers: {
    type: _lib.attrTypeNum,
    pAttr: 'showalloutliers'
  },
  showmean: {
    type: _lib.attrTypeNum,
    pAttr: 'showmean'
  },
  showsd: {
    type: _lib.attrTypeNum,
    pAttr: 'showsd'
  },
  showmd: {
    type: _lib.attrTypeNum,
    pAttr: 'showmd'
  },
  showqd: {
    type: _lib.attrTypeNum,
    pAttr: 'showqd'
  },
  showminvalues: {
    type: _lib.attrTypeNum,
    pAttr: 'showminvalues'
  },
  showmaxvalues: {
    type: _lib.attrTypeNum,
    pAttr: 'showmaxvalues'
  },
  showq1values: {
    type: _lib.attrTypeNum,
    pAttr: 'showq1values'
  },
  showq3values: {
    type: _lib.attrTypeNum,
    pAttr: 'showq3values'
  },
  showmedianvalues: {
    type: _lib.attrTypeNum,
    pAttr: 'showmedianvalues'
  }
});
var UNDEF = void 0,
    POLYGON = _lib.preDefStr.POLYGON,
    COLOR_000000 = _lib.preDefStr.colors.c000000;
/**
 * class for Marimekko chartAPI
 */

var BoxAndWhisker2D = function (_MSStackedColumn2D) {
  _inherits(BoxAndWhisker2D, _MSStackedColumn2D);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  BoxAndWhisker2D.getName = function getName() {
    return 'BoxAndWhisker2D';
  };
  /**
   * Provides the name of the chart
   * @return {string} The name of the chart extension
   */


  BoxAndWhisker2D.prototype.getName = function getName() {
    return 'BoxAndWhisker2D';
  };
  /**
   * Constructor funtion for Marimekko chartAPI
   */


  function BoxAndWhisker2D() {
    _classCallCheck(this, BoxAndWhisker2D);

    var _this = _possibleConstructorReturn(this, _MSStackedColumn2D.call(this));

    var iapi = _this;
    iapi.maxColWidth = +Infinity;
    iapi.useErrorAnimation = 1;
    iapi.avoidCrispError = 0;
    iapi.plotSpacePercent = 20;
    iapi.useplotgradientcolor = 1;
    iapi.fireGroupEvent = true;
    _this.registerFactory('dataset', _boxandwhiskerDataset2['default'], ['vCanvas']);
    return _this;
  }

  /**
   * Set default chart configuration
   */


  BoxAndWhisker2D.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSStackedColumn2D.prototype.__setDefaultConfig && _MSStackedColumn2D.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.decimals = 2;
    config.friendlyName = 'Box and Whisker iapi';
    config.defaultDatasetType = 'boxandwhisker2d';
    config.showplotborder = 1;
    config.plotborderdashlen = 5;
    config.plotborderdashgap = 4;
    config.plotfillalpha = _lib.HUNDREDSTRING;
    config.useroundedges = 0;
    config.plotborderthickness = 1;
    config.showvalues = 1;
    config.valuepadding = 2;
    config.decimals = 2;
    config.showtooltip = 1;
    config.maxcolwidth = 50;
    config.rotatevalues = 0;
    config.use3dlighting = 1;
    config.whiskerslimitswidthratio = 40;
    config.outliersupperrangeratio = 0;
    config.outlierslowerrangeratio = 0;
    config.showalloutliers = 0;
    config.showmean = 0;
    config.showsd = 0;
    config.showmd = 0;
    config.showqd = 0;
    config.showminvalues = 1;
    config.showmaxvalues = 1;
    config.showq1values = 0;
    config.showq3values = 0;
    config.showmedianvalues = 1;
    config.tooltipsepchar = ': ';

    // default attributes of line
    config.anchorborderthickness = 1;
    config.anchorimageurl = UNDEF;
    config.anchorimagepadding = 1;
    config.anchorsides = 1;
    config.anchoralpha = UNDEF;
    config.anchorbgalpha = _lib.HUNDREDSTRING;
    config.anchorimagealpha = _lib.HUNDREDSTRING;
    config.anchorimagescale = 100;
    config.anchorstartangle = 90;
    config.anchorshadow = 0;
    config.anchorbgcolor = UNDEF;
    config.anchorbordercolor = UNDEF;
    config.anchorradius = 3;
    config.linedashlen = 5;
    config.linedashgap = 4;
    config.linedashed = UNDEF;
    config.linealpha = _lib.HUNDREDSTRING;
    config.linethickness = 2;
    config.drawfullareaborder = 1;
    config.connectnulldata = 0;
  };

  /**
   * Function to return the custom json data for the mean, meadian, etc (line dataset) of boxAndWhisker
   * @return {Object} The custom JSON Data
   */


  BoxAndWhisker2D.prototype._getLineJSONdata = function _getLineJSONdata() {
    var iapi = this,
        bwCalc = iapi.getChildren('BoxAndWhiskerStatisticalCalc')[0],
        jsonData = iapi.getFromEnv('dataSource'),
        chartAttrs = jsonData.chart,
        datasets = jsonData.dataset,
        len = datasets.length,
        showMean,
        dataset,
        data,
        dataLen,
        setData,
        derivedDS = [],
        currDerivedDS,
        requiredSubDs = [],
        derivedDataValue = [],
        currDerivedDataVal,
        subDSLen,
        currSubDS,
        showSD,
        showQD,
        showMD,
        outliers,
        outliersArr,
        valueMin,
        valueMax,
        value,
        fn = function fn(val) {
      value = Number(val);

      var _extent = (0, _lib.extent)(bwCalc.values);

      valueMin = _extent[0];
      valueMax = _extent[1];

      (value < valueMin || value > valueMax) && outliersArr.push({
        value: value,
        index: j,
        anchorbgcolor: setData.outliericoncolor,
        anchorradius: setData.outliericonradius,
        anchoralpha: setData.outliericonalpha,
        anchorbgalpha: setData.outliericonalpha,
        anchorsides: setData.outliericonsides,
        dip: setData.outliericonshape
      });
    },
        j,
        k,
        i;

    // Deciding for which which all datasets we need which all sub-datasets
    for (i = 0; i < len; i++) {
      dataset = datasets[i];
      currSubDS = requiredSubDs[i] = {};
      currDerivedDataVal = derivedDataValue[i] = {
        showMean: {
          seriesname: 'Mean',
          showvalues: 0,
          anchorbgcolor: (0, _lib.pluck)(dataset.meaniconcolor, chartAttrs.meaniconcolor, COLOR_000000),
          anchorbordercolor: COLOR_000000,
          anchorradius: (0, _lib.pluckNumber)(dataset.meaniconradius, chartAttrs.meaniconradius, 5),
          anchoralpha: (0, _lib.pluck)(dataset.alpha, dataset.meaniconalpha, chartAttrs.meaniconalpha),
          anchorbgalpha: (0, _lib.pluck)(dataset.meaniconalpha, chartAttrs.meaniconalpha, 100),
          linethickness: (0, _lib.pluck)(dataset.linethickness, chartAttrs.linethickness, 1),
          anchorsides: (0, _lib.pluck)(dataset.meaniconsides, chartAttrs.meaniconsides, 3),
          showline: !(0, _lib.pluckNumber)(dataset.drawmeanconnector, chartAttrs.drawmeanconnector),
          dip: (0, _lib.pluck)(dataset.meaniconshape, chartAttrs.meaniconshape, POLYGON),
          color: (0, _lib.pluck)(dataset.meaniconcolor, chartAttrs.meaniconcolor, COLOR_000000),
          data: []
        },
        showSD: {
          seriesname: 'SD',
          showvalues: 0,
          anchorbgcolor: (0, _lib.pluck)(dataset.sdiconcolor, chartAttrs.sdiconcolor, COLOR_000000),
          anchorbordercolor: COLOR_000000,
          anchorradius: (0, _lib.pluckNumber)(dataset.sdiconradius, chartAttrs.sdiconradius, 5),
          anchoralpha: (0, _lib.pluck)(dataset.alpha, dataset.sdiconalpha, chartAttrs.sdiconalpha),
          anchorbgalpha: (0, _lib.pluck)(dataset.sdiconalpha, chartAttrs.sdiconalpha, 100),
          linethickness: (0, _lib.pluck)(dataset.linethickness, chartAttrs.linethickness, 1),
          anchorsides: (0, _lib.pluck)(dataset.sdiconsides, chartAttrs.sdiconsides, 3),
          showline: !(0, _lib.pluckNumber)(dataset.drawsdconnector, chartAttrs.drawsdconnector),
          dip: (0, _lib.pluck)(dataset.sdiconshape, chartAttrs.sdiconshape, POLYGON),
          color: (0, _lib.pluck)(dataset.sdiconcolor, chartAttrs.sdiconcolor, COLOR_000000),
          data: []
        },
        showQD: {
          seriesname: 'QD',
          showvalues: 0,
          anchorbgcolor: (0, _lib.pluck)(dataset.qdiconcolor, chartAttrs.qdiconcolor, COLOR_000000),
          anchorbordercolor: COLOR_000000,
          anchorradius: (0, _lib.pluckNumber)(dataset.qdiconradius, chartAttrs.qdiconradius, 5),
          anchoralpha: (0, _lib.pluck)(dataset.alpha, dataset.qdiconalpha, chartAttrs.qdiconalpha),
          anchorbgalpha: (0, _lib.pluck)(dataset.qdiconalpha, chartAttrs.qdiconalpha, 100),
          linethickness: (0, _lib.pluck)(dataset.linethickness, chartAttrs.linethickness, 1),
          anchorsides: (0, _lib.pluck)(dataset.qdiconsides, chartAttrs.qdiconsides, 3),
          showline: !(0, _lib.pluckNumber)(dataset.drawqdconnector, chartAttrs.drawqdconnector),
          dip: (0, _lib.pluck)(dataset.qdiconshape, chartAttrs.qdiconshape, POLYGON),
          color: (0, _lib.pluck)(dataset.qdiconcolor, chartAttrs.qdiconcolor, COLOR_000000),
          data: []
        },
        showMD: {
          seriesname: 'MD',
          showvalues: 0,
          anchorbgcolor: (0, _lib.pluck)(dataset.mdiconcolor, chartAttrs.mdiconcolor, COLOR_000000),
          anchorbordercolor: COLOR_000000,
          anchorradius: (0, _lib.pluckNumber)(dataset.mdiconradius, chartAttrs.mdiconradius, 5),
          anchoralpha: (0, _lib.pluck)(dataset.alpha, dataset.mdiconalpha, chartAttrs.mdiconalpha),
          anchorbgalpha: (0, _lib.pluck)(dataset.mdiconalpha, chartAttrs.mdiconalpha, 100),
          linethickness: (0, _lib.pluck)(dataset.linethickness, chartAttrs.linethickness, 1),
          anchorsides: (0, _lib.pluck)(dataset.mdiconsides, chartAttrs.mdiconsides, 3),
          showline: !(0, _lib.pluckNumber)(dataset.drawmdconnector, chartAttrs.drawmdconnector),
          dip: (0, _lib.pluck)(dataset.mdiconshape, chartAttrs.mdiconshape, POLYGON),
          color: (0, _lib.pluck)(dataset.mdiconcolor, chartAttrs.mdiconcolor, COLOR_000000),
          data: []
        },
        outliers: {
          seriesname: 'Outliers',
          showvalues: 0,
          anchorbgcolor: (0, _lib.pluck)(dataset.outliericoncolor, chartAttrs.outliericoncolor, COLOR_000000),
          anchorbordercolor: COLOR_000000,
          anchorradius: (0, _lib.pluckNumber)(dataset.outliericonradius, chartAttrs.outliericonradius, 5),
          anchoralpha: (0, _lib.pluck)(dataset.alpha, dataset.outliericonalpha, chartAttrs.outliericonalpha),
          includeinlegend: dataset.seriesname ? 1 : 0,
          anchorbgalpha: (0, _lib.pluck)(dataset.outliericonalpha, chartAttrs.outliericonalpha, 100),
          linethickness: (0, _lib.pluck)(dataset.linethickness, chartAttrs.linethickness, 1),
          anchorsides: (0, _lib.pluck)(dataset.outliericonsides, chartAttrs.outliericonsides, 3),
          showline: !(0, _lib.pluckNumber)(dataset.drawoutliersconnector, chartAttrs.drawoutliersconnector),
          color: (0, _lib.pluck)(dataset.outliericoncolor, chartAttrs.outliericoncolor, COLOR_000000),
          dip: (0, _lib.pluck)(dataset.outliericonshape, chartAttrs.outliericonshape, POLYGON),
          data: []
        }
      };
      showMean = (0, _lib.pluckNumber)(dataset.showmean, chartAttrs.showmean, 0);
      showSD = (0, _lib.pluckNumber)(dataset.showsd, chartAttrs.showsd, 0);
      showQD = (0, _lib.pluckNumber)(dataset.showqd, chartAttrs.showqd, 0);
      showMD = (0, _lib.pluckNumber)(dataset.showmd, chartAttrs.showmd, 0);

      data = dataset.data;
      dataLen = data.length;
      for (j = 0; j < dataLen; j++) {
        setData = data[j];
        bwCalc.setArray(setData.value);
        bwCalc.getQuartiles();
        outliers = setData.outliers;

        // Checking if at all mean, sd, etc datasets are required
        showMean = currSubDS.showMean = currSubDS.showMean || (0, _lib.pluckNumber)(setData.showmean, showMean);
        showSD = currSubDS.showSD = currSubDS.showSD || (0, _lib.pluckNumber)(setData.showsd, showSD);
        showQD = currSubDS.showQD = currSubDS.showQD || (0, _lib.pluckNumber)(setData.showqd, showQD);
        showMD = currSubDS.showMD = currSubDS.showMD || (0, _lib.pluckNumber)(setData.showmd, showMD);

        // Storing the value of mean, sd as the same key of the previous check for ease of use
        currDerivedDataVal.showMean.data.push({
          value: showMean && bwCalc.getMean(),
          anchorbgcolor: setData.meaniconcolor,
          anchorradius: setData.meaniconradius,
          anchoralpha: setData.meaniconalpha,
          anchorbgalpha: setData.meaniconalpha,
          anchorsides: setData.meaniconsides,
          dip: setData.meaniconshape
        });
        currDerivedDataVal.showSD.data.push({
          value: showSD && bwCalc.getSD(),
          anchorbgcolor: setData.sdiconcolor,
          anchorradius: setData.sdiconradius,
          anchoralpha: setData.sdiconalpha,
          anchorbgalpha: setData.sdiconalpha,
          anchorsides: setData.sdiconsides,
          dip: setData.sdiconshape
        });
        currDerivedDataVal.showQD.data.push({
          value: showQD && bwCalc.getQD(),
          anchorbgcolor: setData.qdiconcolor,
          anchorradius: setData.qdiconradius,
          anchoralpha: setData.qdiconalpha,
          anchorbgalpha: setData.qdiconalpha,
          anchorsides: setData.qdiconsides,
          dip: setData.qdiconshape
        });
        currDerivedDataVal.showMD.data.push({
          value: showMD && bwCalc.getMD(),
          anchorbgcolor: setData.mdiconcolor,
          anchorradius: setData.mdiconradius,
          anchoralpha: setData.mdiconalpha,
          anchorbgalpha: setData.mdiconalpha,
          anchorsides: setData.mdiconsides,
          dip: setData.mdiconshape
        });

        if (outliers) {
          outliersArr = currDerivedDataVal.outliers.data;
          outliers.split(_lib.COMMA).forEach(fn);
          currSubDS.outliers = true;
        }
      }
    }

    // Creating the subDataset as per their requirements
    subDSLen = requiredSubDs.length;
    for (k = 0; k < subDSLen; k++) {
      currSubDS = requiredSubDs[k];
      currDerivedDS = derivedDS[k] = [];
      for (i in currSubDS) {
        currSubDS[i] && currDerivedDS.push(derivedDataValue[k][i]);
      }
    }

    return derivedDS;
  };

  /**
   * This method return the dataset definations for this charts
   * @return {Object} return column dataset
   */


  BoxAndWhisker2D.prototype.getDSdef = function getDSdef() {
    return _boxandwhisker2d2['default'];
  };

  /**
   * This method return the dataset-group definations for this charts
   * @return {Object} Multiseries column group definition
   */


  BoxAndWhisker2D.prototype.getDSGroupdef = function getDSGroupdef() {
    return _boxandwhisker2['default'];
  };

  return BoxAndWhisker2D;
}(_fusioncharts2['default']);

exports['default'] = BoxAndWhisker2D;

/***/ }),

/***/ 871:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(11);

var _assign2 = _interopRequireDefault(_assign);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _boxandwhiskerline = __webpack_require__(872);

var _boxandwhiskerline2 = _interopRequireDefault(_boxandwhiskerline);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _boxandwhisker2dAnimation = __webpack_require__(874);

var _boxandwhisker2dAnimation2 = _interopRequireDefault(_boxandwhisker2dAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var PLOTBORDERCOLOR = 'plotBorderColor',
    PLOTGRADIENTCOLOR = 'plotGradientColor',
    SHOWSHADOW = 'showShadow',
    SETROLLOVERATTR = 'setRolloverAttr',
    SETROLLOUTATTR = 'setRolloutAttr',
    UNDEFINED = void 0,
    colorStrings = _lib.preDefStr.colors,
    COLOR_000000 = colorStrings.c000000,
    LABEL = _lib.preDefStr.LABEL,
    ROLLOVER = _lib.preDefStr.ROLLOVER,
    ROLLOUT = _lib.preDefStr.ROLLOUT,
    UNDERSCORE = _lib.preDefStr.UNDERSCORE,
    POINTER = _lib.preDefStr.POINTER,
    BLANK = _lib.preDefStr.BLANK,
    ROUND = _lib.preDefStr.ROUND,
    GROUPID = _lib.preDefStr.GROUPID,
    POSITION_START = _lib.preDefStr.POSITION_START,
    POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
    POSITION_TOP = _lib.preDefStr.POSITION_TOP,
    showHoverEffectStr = _lib.preDefStr.showHoverEffectStr,
    EVENTARGS = _lib.preDefStr.EVENTARGS,

// dataLabelStr = preDefStr.dataLabelStr,
// shadowStr = preDefStr.shadowStr,
POSITION_END = _lib.preDefStr.POSITION_END,
    M = 'M',
    H = 'H',
    V = 'V',
    BOLDSTARTTAG = '<b>',
    BOLDENDTAG = '</b>',
    BREAKSTRING = '<br />',
    MAXIMUM_STR = 'Maximum',
    Q3_STR = 'Q3',
    MEDIAN_STR = 'Median',
    Q1_STR = 'Q1',
    MINIMUM_STR = 'Minimum',
    pStr = _lib.preDefStr.pStr,
    sStr = _lib.preDefStr.sStr,
    NONE = 'none',

/**
 * Helper function to create a RedRaphael group.
 * @param  {Object} attr  Attributes applied to the created group.
 * @param  {Element} parentContainer         The parent container in which the group will be appended.
 * @param {Object} dataset The concerned dataset
 * @return {Element}                         The group that was created.
 */
createGroup = function createGroup(attr, parentContainer, dataset) {
  var animationManager = dataset.getFromEnv('animationManager');
  return animationManager.setAnimation({
    el: 'group',
    attr: attr,
    container: parentContainer,
    component: dataset,
    label: 'group'
  });
},
    _hide = function _hide() {
  return function () {
    this.hide();
  };
};
(0, _dependencyManager.addDep)({
  name: 'boxandwhisker2dAnimation',
  type: 'animationRule',
  extension: _boxandwhisker2dAnimation2['default']
});
/**
 * Class for boxAndWhisker Dataset
 */

var BoxAndWhiskerDataset = function (_ColumnDataset) {
  _inherits(BoxAndWhiskerDataset, _ColumnDataset);

  function BoxAndWhiskerDataset() {
    _classCallCheck(this, BoxAndWhiskerDataset);

    return _possibleConstructorReturn(this, _ColumnDataset.apply(this, arguments));
  }

  /**
   * function to create group for dataset
   */
  BoxAndWhiskerDataset.prototype.createContainer = function createContainer() {
    var dataset = this,
        dsType = dataset.type,
        groupName = dataset.groupName,
        parent = dataset.getLinkedParent(),
        group = groupName || dataset.dsGroup || dsType,
        parentContainer,
        parentShadowContainer;

    !parent.getChildContainer(group + 'VcanvasGroup') && (group = 'default');
    parentContainer = parent.getChildContainer(group + 'VcanvasGroup');
    parentShadowContainer = parent.getChildContainer(group + 'ShadowVcanvasGroup');

    !dataset.getContainer('shadowGroup') && dataset.addContainer('shadowGroup', createGroup({ name: 'shadow-group' }, parentShadowContainer, dataset));

    !dataset.getContainer('commonElemsGroup') && dataset.addContainer('lowerBoxGroup', createGroup({ name: 'lower-box-group' }, parentContainer, dataset));

    !dataset.getContainer('commonElemsGroup') && dataset.addContainer('upperBoxGroup', createGroup({ name: 'upper-box-group' }, parentContainer, dataset));

    !dataset.getContainer('commonElemsGroup') && dataset.addContainer('upperWhiskerGroup', createGroup({ name: 'upper-whisker-group' }, parentContainer, dataset));

    !dataset.getContainer('commonElemsGroup') && dataset.addContainer('lowerWhiskerGroup', createGroup({ name: 'lower-whisker-group' }, parentContainer, dataset));

    !dataset.getContainer('commonElemsGroup') && dataset.addContainer('medianGroup', createGroup({ name: 'median-group' }, parentContainer, dataset));

    !dataset.getContainer('labelGroup') && dataset.addContainer('labelGroup', createGroup({ name: 'label-group',
      'class': 'fusioncharts-datalabels' }, parent.getChildContainer('vcanvasLabelGroup'), dataset));
  };

  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} Indicates whether the configuration was successful or not
    */


  BoxAndWhiskerDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.config.JSONData = datasetJSON;
    var dataset = this,

    // chart = dataset.chart,
    conf = dataset.config,
        JSONData = dataset.config.JSONData,
        setDataArr = JSONData.data,
        setDataLen = setDataArr && setDataArr.length,

    // categories = chart.config.categories,
    // singleSeries = chart.config.singleseries,
    chartConfig = dataset.getFromEnv('chartConfig'),
        xAxis = dataset.getFromEnv('xAxis'),
        catLen = xAxis.getTicksLen(),
        len = Math.min(catLen, setDataLen),
        chartAttr = dataset.getFromEnv('chart-attrib'),
        colorM = dataset.getFromEnv('color-manager'),
        index = conf.index,
        showplotborder,
        plotColor = conf.plotColor = colorM.getPlotColor(index),
        plotBorderDash = (0, _lib.pluckNumber)(JSONData.dashed, chartAttr.plotborderdashed),
        usePlotGradientColor = chartConfig.useplotgradientcolor,
        showTooltip,

    // parseUnsafeString = lib.parseUnsafeString,
    yAxisName = chartConfig.yaxisname,
        xAxisName = chartConfig.xaxisname,
        tooltipSepChar = (0, _lib.parseUnsafeString)((0, _lib.pluck)(chartAttr.tooltipsepchar, ': ')),

    // parseTooltext = lib.parseTooltext,
    formatedVal,
        parserConfig,
        setTooltext,
        macroIndices,
        tempPlotfillAngle,
        toolText,
        plotDashLen,
        plotDashGap,
        plotBorderThickness,
        isRoundEdges,
        showHoverEffect,
        plotfillAngle,
        plotFillAlpha,

    // plotRadius,
    plotFillRatio,
        plotgradientcolor,
        plotBorderAlpha,
        plotBorderColor,

    // plotBorderDashStyle,
    initailPlotBorderDashStyle,
        setData,
        setValue,
        dataObj,
        config,
        label,

    // colorArr,
    upperBoxHoverColor,
        upperBoxHoverAlpha,
        upperBoxBorderHoverColor,
        upperBoxBorderHoverAlpha,
        upperBoxBorderHoverThickness,
        lowerBoxHoverColor,
        lowerBoxHoverAlpha,
        lowerBoxBorderHoverColor,
        lowerBoxBorderHoverAlpha,
        lowerBoxBorderHoverThickness,
        upperQuartileHoverColor,
        upperQuartileHoverAlpha,
        upperQuartileHoverThickness,
        lowerQuartileHoverColor,
        lowerQuartileHoverAlpha,
        lowerQuartileHoverThickness,
        medianHoverColor,
        medianHoverAlpha,
        medianHoverThickness,

    // getDashStyle = lib.getDashStyle,
    dataStore = dataset.components.data,
        numberFormatter = dataset.getFromEnv('number-formatter'),
        toolTipValue,
        setDisplayValue,

    // definedGroupPadding,

    // use3DLighting,
    parentYAxis,
        setDataDashed,
        setDataPlotDashLen,
        setDataPlotDashGap,
        i,
        maxValue = -Infinity,
        minValue = +Infinity,
        bwCalc = dataset.getFromEnv('BoxAndWhiskerStatisticalCalc'),
        quartile,
        q1,
        q3,
        limits,
        min,
        max,
        medianValue,
        mean,
        md,
        sd,
        qd,

    // highValue,
    // lowValue,
    // itemValue,
    upperBoxColor,
        upperBoxAlpha,
        lowerBoxColor,
        lowerBoxAlpha,
        upperWhiskerAlpha,
        showValues,
        showAllOutliers,
        difference,
        lowerWhiskerAlpha,

    // showMean,
    // showSD,
    // showMD,
    // showQD,

    // outlierDS,
    // OutliersLength,
    // maxNumberOfOutliers = 0,
    maxmin;

    dataset.setState('visible', !!((0, _lib.pluckNumber)(dataset.config.JSONData.visible, !Number(dataset.config.JSONData.initiallyhidden), 1) === 1));

    (0, _lib.parseConfiguration)(JSONData, conf, chartConfig, { data: true });
    conf.defaultPadding = {
      left: 0.5,
      right: 0.5
    };
    conf.includeInLegend = (0, _lib.pluckNumber)(JSONData.includeinlegend, 1);
    conf.legendSymbolColor = conf.plotColor;
    showplotborder = conf.showplotborder;
    plotDashLen = conf.plotborderdashlen;
    plotDashGap = conf.plotborderdashgap;
    plotFillAlpha = conf.plotfillalpha;
    isRoundEdges = conf.useroundedges;
    plotFillRatio = conf.ratio;
    plotBorderThickness = conf.plotborderthickness;
    showValues = conf.showvalues = (0, _lib.pluckNumber)(JSONData.showvalues, chartAttr.showvalues, 1);
    showTooltip = conf.showtooltip;
    conf.rotatevalues && (conf.rotatevalues = 270);
    // use3DLighting = conf.use3dlighting;
    showAllOutliers = conf.showalloutliers;

    conf.plotfillAngle = plotfillAngle = (0, _lib.pluckNumber)(360 - chartAttr.plotfillangle, 90);
    conf.plotColor = plotColor = (0, _lib.pluck)(JSONData.color, plotColor);
    conf.plotRadius = (0, _lib.pluckNumber)(chartAttr.useroundedges, isRoundEdges ? 1 : 0);
    conf.plotgradientcolor = plotgradientcolor = (0, _lib.getDefinedColor)(chartAttr.plotgradientcolor, colorM.getColor(PLOTGRADIENTCOLOR));
    !usePlotGradientColor && (plotgradientcolor = _lib.BLANKSTRING);
    conf.plotBorderAlpha = plotBorderAlpha = showplotborder ? (0, _lib.pluck)(chartAttr.plotborderalpha, plotFillAlpha, _lib.HUNDREDSTRING) : 0;
    conf.plotBorderColor = plotBorderColor = (0, _lib.pluck)(chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR));
    conf.plotBorderDashStyle = initailPlotBorderDashStyle = plotBorderDash ? (0, _lib.getDashStyle)(plotDashLen, plotDashGap, plotBorderThickness) : NONE;

    conf.showShadow = isRoundEdges ? (0, _lib.pluckNumber)(chartAttr.showshadow, 1) : (0, _lib.pluckNumber)(chartAttr.showshadow, colorM.getColor(SHOWSHADOW));
    conf.showHoverEffect = showHoverEffect = (0, _lib.pluckNumber)(chartAttr.plothovereffect, chartAttr.showhovereffect, UNDEFINED);

    // conf.definedGroupPadding = definedGroupPadding = Math.max(pluckNumber(chartAttr.plotspacepercent), 0);
    // conf.plotSpacePercent = Math.max(pluckNumber(chartAttr.plotspacepercent, 20) % 100, 0);

    conf.parentYAxis = parentYAxis = (0, _lib.pluck)(JSONData.parentyaxis && JSONData.parentyaxis.toLowerCase(), pStr) === sStr ? 1 : 0;

    conf.dataSeparator = _lib.COMMASTRING;

    conf.textDirection = chartAttr.hasrtltext === '1' ? 'rtl' : _lib.BLANKSTRING;

    conf.showMeanLegend = conf.showSDLegend = conf.showMDLegend = conf.showQDLegend = conf.showOutliersLegend = 0;

    !dataset.components.data && (dataset.components.data = []);
    dataStore = dataset.components.data;

    // Parsing the attributes and values at set level.
    for (i = 0; i < len; i++) {
      setData = setDataArr && setDataArr[i];
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (!dataObj) {
        dataObj = dataStore[i] = {
          graphics: {}
        };
      }

      if (!dataObj.config) {
        config = dataStore[i].config = {};
      }

      if (!setData.value) {
        config.setValue = UNDEFINED;
        continue;
      }

      if (setData.value) {
        bwCalc.setArray(setData.value);
        quartile = bwCalc.getQuartiles();
        q1 = quartile.q1;
        q3 = quartile.q3;

        limits = bwCalc.getMinMax();
        config.min = min = limits.min;
        config.max = max = limits.max;
        medianValue = bwCalc.getMedian();
        config.mean = mean = bwCalc.getMean();
        config.md = md = bwCalc.getMD();
        config.sd = sd = bwCalc.getSD();
        config.qd = qd = bwCalc.getQD();

        // get the valid value
        // highValue = itemValue = max;
      }

      // if (setData.outliers) {
      //   config.outliers = setData.outliers.split(COMMA);
      //   maxNumberOfOutliers = Math.max(maxNumberOfOutliers, config.outliers.length);
      // }

      // config.showMean = showMean = pluckNumber(setData.showmean, conf.showmean);
      // config.showSD = showSD = pluckNumber(setData.showsd, conf.showsd);
      // config.showMD = showMD = pluckNumber(setData.showmd, conf.showmd);
      // config.showQD = showQD = pluckNumber(setData.showqd, conf.showqd);
      // setData.outliers && (conf.showOutliersLegend = 1);

      // showMean && (conf.showMeanLegend = 1);
      // showSD && (conf.showSDLegend = 1);
      // showMD && (conf.showMDLegend = 1);
      // showQD && (conf.showQDLegend = 1);

      config.upperQuartile = {
        value: q3,
        color: (0, _lib.convertColor)((0, _lib.pluck)(setData.upperquartilecolor, JSONData.upperquartilecolor, chartAttr.upperquartilecolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR)), (0, _lib.pluckNumber)(setData.upperquartilealpha, JSONData.upperquartilealpha, chartAttr.upperquartilealpha, chartAttr.plotborderalpha, 100)),
        borderWidth: (0, _lib.pluckNumber)(setData.upperquartilethickness, JSONData.upperquartilethickness, chartAttr.upperquartilethickness, chartAttr.plotborderthickness, !isRoundEdges ? 1 : 0),

        displayValue: numberFormatter.dataLabels(q3)
      };

      config.lowerQuartile = {
        value: q1,
        color: (0, _lib.convertColor)((0, _lib.pluck)(setData.lowerquartilecolor, JSONData.lowerquartilecolor, chartAttr.lowerquartilecolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR)), (0, _lib.pluckNumber)(setData.lowerquartilealpha, JSONData.lowerquartilealpha, chartAttr.lowerquartilealpha, chartAttr.plotborderalpha, 100)),
        borderWidth: (0, _lib.pluckNumber)(setData.lowerquartilethickness, JSONData.lowerquartilethickness, chartAttr.lowerquartilethickness, chartAttr.plotborderthickness, !isRoundEdges ? 1 : 0),

        displayValue: numberFormatter.dataLabels(q1)
      };

      config.upperBoxBorder = {
        color: (0, _lib.convertColor)((0, _lib.pluck)(setData.upperboxbordercolor, JSONData.upperboxbordercolor, chartAttr.upperboxbordercolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR)), (0, _lib.pluckNumber)(setData.upperboxborderalpha, JSONData.upperboxborderalpha, chartAttr.upperboxborderalpha, chartAttr.plotborderalpha, 100)),
        borderWidth: (0, _lib.pluckNumber)(setData.upperboxborderthickness, JSONData.upperboxborderthickness, chartAttr.upperboxborderthickness, !isRoundEdges && chartAttr.plotborderthickness, !isRoundEdges ? 1 : 0)
      };

      config.lowerBoxBorder = {
        color: (0, _lib.convertColor)((0, _lib.pluck)(setData.lowerboxbordercolor, JSONData.lowerboxbordercolor, chartAttr.lowerboxbordercolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR)), (0, _lib.pluckNumber)(setData.lowerboxborderalpha, JSONData.lowerboxborderalpha, chartAttr.lowerboxborderalpha, chartAttr.plotborderalpha, 100)),
        borderWidth: (0, _lib.pluckNumber)(setData.lowerboxborderthickness, JSONData.lowerboxborderthickness, chartAttr.lowerboxborderthickness, !isRoundEdges && chartAttr.plotborderthickness, !isRoundEdges ? 1 : 0)
      };

      config.median = {
        value: medianValue,
        color: (0, _lib.convertColor)((0, _lib.pluck)(setData.mediancolor, JSONData.mediancolor, chartAttr.mediancolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR)), (0, _lib.pluckNumber)(setData.medianalpha, JSONData.medianalpha, chartAttr.medianalpha, chartAttr.plotborderalpha, 100)),
        borderWidth: (0, _lib.pluckNumber)(setData.medianthickness, JSONData.medianthickness, chartAttr.medianthickness, chartAttr.plotborderthickness, 1),

        displayValue: numberFormatter.dataLabels(medianValue)
      };
      conf.upperBoxColor = upperBoxColor = (0, _lib.pluck)(setData.upperboxcolor, JSONData.upperboxcolor, chartAttr.upperboxcolor, colorM.getPlotColor(index * 2));

      upperBoxAlpha = conf.upperBoxAlpha = (0, _lib.pluck)(setData.upperboxalpha, JSONData.upperboxalpha, chartAttr.upperboxalpha, plotFillAlpha, _lib.HUNDREDSTRING);

      conf.lowerBoxColor = lowerBoxColor = (0, _lib.pluck)(setData.lowerboxcolor, JSONData.lowerboxcolor, chartAttr.lowerboxcolor, colorM.getPlotColor(index * 2 + 1));

      lowerBoxAlpha = conf.lowerBoxAlpha = (0, _lib.pluck)(setData.lowerboxalpha, JSONData.lowerboxalpha, chartAttr.lowerboxalpha, plotFillAlpha, _lib.HUNDREDSTRING);

      config.upperColorArr = _lib.graphics.getColumnColor(upperBoxColor, upperBoxAlpha, UNDEFINED, UNDEFINED, isRoundEdges, plotBorderColor, plotBorderAlpha.toString(), 0, false);

      config.lowerColorArr = _lib.graphics.getColumnColor(lowerBoxColor, lowerBoxAlpha, UNDEFINED, UNDEFINED, isRoundEdges, plotBorderColor, plotBorderAlpha.toString(), 0, false);

      // Priority:
      // showValue at data level > showvalues at dataset level > showvalues at chart level
      config.showValue = (0, _lib.pluckNumber)(setData.showvalue, showValues);

      config.showMinValues = config.showValue ? (0, _lib.pluckNumber)(setData.showminvalues, conf.showminvalues) : 0;

      config.showMaxValues = config.showValue ? (0, _lib.pluckNumber)(setData.showmaxvalues, conf.showmaxvalues) : 0;

      config.showQ1Values = config.showValue ? (0, _lib.pluckNumber)(setData.showq1values, conf.showq1values) : 0;

      config.showQ3Values = config.showValue ? (0, _lib.pluckNumber)(setData.showq3values, conf.showq3values) : 0;

      config.showMedianValues = config.showValue ? (0, _lib.pluckNumber)(setData.showmedianvalues, conf.showmedianvalues) : 0;

      config.upperWhiskerAlpha = upperWhiskerAlpha = (0, _lib.getFirstAlpha)((0, _lib.pluck)(setData.upperwhiskeralpha, JSONData.upperwhiskeralpha, chartAttr.upperwhiskeralpha, chartAttr.plotborderalpha, 100));

      config.upperWhiskerColor = (0, _lib.convertColor)((0, _lib.getFirstColor)((0, _lib.pluck)(setData.upperwhiskercolor, JSONData.upperwhiskercolor, chartAttr.upperwhiskercolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR))), upperWhiskerAlpha);

      config.upperWhiskerThickness = (0, _lib.pluckNumber)(setData.upperwhiskerthickness, JSONData.upperwhiskerthickness, chartAttr.upperwhiskerthickness, chartAttr.plotborderthickness, 1);

      config.upperWhiskerShadowOpacity = conf.showShadow ? upperWhiskerAlpha / 250 : 0;

      config.lowerWhiskerAlpha = lowerWhiskerAlpha = (0, _lib.getFirstAlpha)((0, _lib.pluck)(setData.lowerwhiskeralpha, JSONData.lowerwhiskeralpha, chartAttr.lowerwhiskeralpha, chartAttr.plotborderalpha, 100));

      config.lowerWhiskerColor = (0, _lib.convertColor)((0, _lib.getFirstColor)((0, _lib.pluck)(setData.lowerwhiskercolor, JSONData.lowerwhiskercolor, chartAttr.lowerwhiskercolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR))), lowerWhiskerAlpha);

      config.lowerWhiskerThickness = (0, _lib.pluckNumber)(setData.lowerwhiskerthickness, JSONData.lowerwhiskerthickness, chartAttr.lowerwhiskerthickness, chartAttr.plotborderthickness, 1);

      config.lowerWhiskerShadowOpacity = conf.showShadow ? lowerWhiskerAlpha / 250 : 0;

      config.setValue = setValue = numberFormatter.getCleanValue(setData.value);
      config.setLink = (0, _lib.pluck)(setData.link);
      config.toolTipValue = toolTipValue = numberFormatter.dataLabels(setValue, parentYAxis);
      config.setDisplayValue = setDisplayValue = (0, _lib.parseUnsafeString)(setData.displayvalue);
      config.displayValue = (0, _lib.pluck)(setDisplayValue, toolTipValue);
      setDataDashed = (0, _lib.pluckNumber)(setData.dashed);
      setDataPlotDashLen = (0, _lib.pluckNumber)(setData.dashlen, plotDashLen);
      setDataPlotDashGap = plotDashGap = (0, _lib.pluckNumber)(setData.dashgap, plotDashGap);

      maxValue = Math.max(maxValue, max);
      minValue = Math.min(minValue, min);

      // if (showAllOutliers && setData.outliers) {
      //   for (j = 0; j < config.outliers.length; j++) {
      //     maxValue = Math.max(maxValue, config.outliers[j]);
      //     minValue = Math.min(minValue, config.outliers[j]);
      //   }
      // }

      config.plotBorderDashStyle = setDataDashed === 1 ? (0, _lib.getDashStyle)(setDataPlotDashLen, setDataPlotDashGap, plotBorderThickness) : setDataDashed === 0 ? NONE : initailPlotBorderDashStyle;
      // if (singleSeries) {
      //   plotColor = colorM.getPlotColor(i);
      //   plotColor = pluck(setData.color, plotColor);
      //   plotFillRatio = pluck(setData.ratio, conf.ratio);
      // }
      // else {
      plotColor = (0, _lib.pluck)(setData.color, conf.plotColor);
      // }
      plotFillAlpha = (0, _lib.pluck)(setData.alpha, conf.plotfillalpha);

      // Setting the angle for plot fill for negative data
      if (setValue < 0 && !isRoundEdges) {
        tempPlotfillAngle = plotfillAngle;
        plotfillAngle = 360 - plotfillAngle;
      }

      // Setting the color Array to be applied to the bar/column.
      config.colorArr = _lib.graphics.getColumnColor(plotColor + _lib.COMMA + plotgradientcolor, plotFillAlpha, plotFillRatio, plotfillAngle, isRoundEdges, plotBorderColor, plotBorderAlpha.toString(), 0, false);

      config.label = label = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)(xAxis.getLabel((0, _lib.pluckNumber)(i))));

      // Parsing the hover effects only if showhovereffect is not 0.
      if (showHoverEffect !== 0) {
        upperBoxHoverColor = (0, _lib.pluck)(setData.upperboxhovercolor, JSONData.upperboxhovercolor, chartAttr.upperboxhovercolor, upperBoxColor);

        upperBoxHoverAlpha = (0, _lib.pluck)(setData.upperboxhoveralpha, JSONData.upperboxhoveralpha, chartAttr.upperboxhoveralpha, upperBoxAlpha);

        upperBoxBorderHoverColor = (0, _lib.pluck)(setData.upperboxborderhovercolor, JSONData.upperboxborderhovercolor, chartAttr.upperboxborderhovercolor, setData.upperboxbordercolor, JSONData.upperboxbordercolor, chartAttr.upperboxbordercolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR));

        upperBoxBorderHoverAlpha = (0, _lib.pluck)(setData.upperboxborderhoveralpha, JSONData.upperboxborderhoveralpha, chartAttr.upperboxborderhoveralpha, setData.upperboxborderalpha, JSONData.upperboxborderalpha, chartAttr.upperboxborderalpha, chartAttr.plotborderalpha, 100);

        upperBoxBorderHoverThickness = !isRoundEdges ? (0, _lib.pluck)(setData.upperboxborderhoverthickness, JSONData.upperboxborderhoverthickness, chartAttr.upperboxborderhoverthickness, config.upperBoxBorder.borderWidth) : 0;

        lowerBoxHoverColor = (0, _lib.pluck)(setData.lowerboxhovercolor, JSONData.lowerboxhovercolor, chartAttr.lowerboxhovercolor, lowerBoxColor);

        lowerBoxHoverAlpha = (0, _lib.pluck)(setData.lowerboxhoveralpha, JSONData.lowerboxhoveralpha, chartAttr.lowerboxhoveralpha, lowerBoxAlpha);

        lowerBoxBorderHoverColor = (0, _lib.pluck)(setData.lowerboxborderhovercolor, JSONData.lowerboxborderhovercolor, chartAttr.lowerboxborderhovercolor, setData.lowerboxbordercolor, JSONData.lowerboxbordercolor, chartAttr.lowerboxbordercolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR));

        lowerBoxBorderHoverAlpha = (0, _lib.pluck)(setData.lowerboxborderhoveralpha, JSONData.lowerboxborderhoveralpha, chartAttr.lowerboxborderhoveralpha, setData.lowerboxborderalpha, JSONData.lowerboxborderalpha, chartAttr.lowerboxborderalpha, chartAttr.plotborderalpha, 100);

        lowerBoxBorderHoverThickness = !isRoundEdges ? (0, _lib.pluck)(setData.lowerboxborderhoverthickness, JSONData.lowerboxborderhoverthickness, chartAttr.lowerboxborderhoverthickness, config.lowerBoxBorder.borderWidth) : 0;

        upperQuartileHoverColor = (0, _lib.pluck)(setData.upperquartilehovercolor, JSONData.upperquartilehovercolor, chartAttr.upperquartilehovercolor, setData.upperquartilecolor, JSONData.upperquartilecolor, chartAttr.upperquartilecolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR));

        upperQuartileHoverAlpha = (0, _lib.pluck)(setData.upperquartilehoveralpha, JSONData.upperquartilehoveralpha, chartAttr.upperquartilehoveralpha, setData.upperquartilealpha, JSONData.upperquartilealpha, chartAttr.upperquartilealpha, chartAttr.plotborderalpha, 100);

        upperQuartileHoverThickness = (0, _lib.pluck)(setData.upperquartilehoverthickness, JSONData.upperquartilehoverthickness, chartAttr.upperquartilehoverthickness, config.upperQuartile.borderWidth);

        lowerQuartileHoverColor = (0, _lib.pluck)(setData.lowerquartilehovercolor, JSONData.lowerquartilehovercolor, chartAttr.lowerquartilehovercolor, setData.lowerquartilecolor, JSONData.lowerquartilecolor, chartAttr.lowerquartilecolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR));

        lowerQuartileHoverAlpha = (0, _lib.pluck)(setData.lowerquartilehoveralpha, JSONData.lowerquartilehoveralpha, chartAttr.lowerquartilehoveralpha, setData.lowerquartilealpha, JSONData.lowerquartilealpha, chartAttr.lowerquartilealpha, chartAttr.plotborderalpha, 100);

        lowerQuartileHoverThickness = (0, _lib.pluck)(setData.lowerquartilehoverthickness, JSONData.lowerquartilehoverthickness, chartAttr.lowerquartilehoverthickness, config.lowerQuartile.borderWidth);

        medianHoverColor = (0, _lib.pluck)(setData.medianhovercolor, JSONData.medianhovercolor, chartAttr.medianhovercolor, setData.mediancolor, JSONData.mediancolor, chartAttr.mediancolor, chartAttr.plotbordercolor, colorM.getColor(PLOTBORDERCOLOR));

        medianHoverAlpha = (0, _lib.pluck)(setData.medianhoveralpha, JSONData.medianhoveralpha, chartAttr.medianhoveralpha, setData.medianalpha, JSONData.medianalpha, chartAttr.medianalpha, chartAttr.plotborderalpha, 100);

        medianHoverThickness = (0, _lib.pluck)(setData.medianhoverthickness, JSONData.medianhoverthickness, chartAttr.medianhoverthickness, config.median.borderWidth);

        /* If no hover effects are explicitly defined and
         * showHoverEffect is not 0 then hoverColor is set.
         */
        if (showHoverEffect === 1) {
          upperBoxColor === upperBoxHoverColor && (upperBoxHoverColor = (0, _lib.getLightColor)(upperBoxHoverColor, 70));
          lowerBoxColor === lowerBoxHoverColor && (lowerBoxHoverColor = (0, _lib.getLightColor)(lowerBoxHoverColor, 70));
        }

        config.upperBoxHoverColorArr = _lib.graphics.getColumnColor(upperBoxHoverColor, upperBoxHoverAlpha, UNDEFINED, UNDEFINED, isRoundEdges, plotBorderColor, plotBorderAlpha.toString(), 0, false);

        config.lowerBoxHoverColorArr = _lib.graphics.getColumnColor(lowerBoxHoverColor, lowerBoxHoverAlpha, UNDEFINED, UNDEFINED, isRoundEdges, plotBorderColor, plotBorderAlpha.toString(), 0, false);

        config.setUpperBoxRolloutAttr = {
          fill: (0, _lib.toRaphaelColor)(config.upperColorArr[0])
        };
        config.setUpperBoxRolloverAttr = {
          fill: (0, _lib.toRaphaelColor)(config.upperBoxHoverColorArr[0])
        };

        config.setLowerBoxRolloutAttr = {
          fill: (0, _lib.toRaphaelColor)(config.lowerColorArr[0])
        };
        config.setLowerBoxRolloverAttr = {
          fill: (0, _lib.toRaphaelColor)(config.lowerBoxHoverColorArr[0])
        };

        config.setUpperBoxBorderRolloverAttr = {
          stroke: (0, _lib.convertColor)(upperBoxBorderHoverColor, upperBoxBorderHoverAlpha),
          'stroke-width': upperBoxBorderHoverThickness
        };
        config.setUpperBoxBorderRolloutAttr = {
          stroke: config.upperBoxBorder.color,
          'stroke-width': config.upperBoxBorder.borderWidth
        };

        config.setLowerBoxBorderRolloverAttr = {
          stroke: (0, _lib.convertColor)(lowerBoxBorderHoverColor, lowerBoxBorderHoverAlpha),
          'stroke-width': lowerBoxBorderHoverThickness
        };
        config.setLowerBoxBorderRolloutAttr = {
          stroke: config.lowerBoxBorder.color,
          'stroke-width': config.lowerBoxBorder.borderWidth
        };

        config.setUpperQuartileRolloverAttr = {
          stroke: (0, _lib.convertColor)(upperQuartileHoverColor, upperQuartileHoverAlpha),
          'stroke-width': upperQuartileHoverThickness
        };
        config.setUpperQuartileRolloutAttr = {
          stroke: config.upperQuartile.color,
          'stroke-width': config.upperQuartile.borderWidth
        };

        config.setLowerQuartileRolloverAttr = {
          stroke: (0, _lib.convertColor)(lowerQuartileHoverColor, lowerQuartileHoverAlpha),
          'stroke-width': lowerQuartileHoverThickness
        };
        config.setLowerQuartileRolloutAttr = {
          stroke: config.lowerQuartile.color,
          'stroke-width': config.lowerQuartile.borderWidth
        };

        config.setMedianRolloverAttr = {
          stroke: (0, _lib.convertColor)(medianHoverColor, medianHoverAlpha),
          'stroke-width': medianHoverThickness
        };
        config.setMedianRolloutAttr = {
          stroke: config.median.color,
          'stroke-width': config.median.borderWidth
        };
      }

      formatedVal = config.toolTipValue;

      // Parsing tooltext against various configurations provided by the user.
      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.tooltext, JSONData.plottooltext, chartAttr.plottooltext)));
      if (!showTooltip) {
        toolText = false;
      } else {
        if (formatedVal === null) {
          toolText = false;
        } else if (setTooltext !== UNDEFINED) {
          macroIndices = [1, 2, 3, 4, 5, 6, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80];
          parserConfig = {
            maxValue: max,
            maxDataValue: numberFormatter.dataLabels(max),
            minValue: min,
            minDataValue: numberFormatter.dataLabels(min),
            Q1: numberFormatter.dataLabels(q1),
            unformattedQ1: q1,
            Q3: numberFormatter.dataLabels(q3),
            unformattedQ3: q3,
            median: numberFormatter.dataLabels(medianValue),
            unformattedMedian: medianValue,

            SD: numberFormatter.dataLabels(sd),
            unformattedsd: sd,
            QD: numberFormatter.dataLabels(qd),
            unformattedQD: qd,
            MD: numberFormatter.dataLabels(md),
            unformattedMD: md,
            mean: numberFormatter.dataLabels(mean),
            unformattedMean: mean,
            label: label,
            yaxisName: yAxisName,
            xaxisName: xAxisName,
            formattedValue: formatedVal,
            value: label
          };
          toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, setData, chartAttr, JSONData);
        } else {
          toolText = BOLDSTARTTAG + MAXIMUM_STR + tooltipSepChar + BOLDENDTAG + numberFormatter.dataLabels(max) + BREAKSTRING + BOLDSTARTTAG + Q3_STR + tooltipSepChar + BOLDENDTAG + numberFormatter.dataLabels(q3) + BREAKSTRING + BOLDSTARTTAG + MEDIAN_STR + tooltipSepChar + BOLDENDTAG + numberFormatter.dataLabels(medianValue) + BREAKSTRING + BOLDSTARTTAG + Q1_STR + tooltipSepChar + BOLDENDTAG + numberFormatter.dataLabels(q1) + BREAKSTRING + BOLDSTARTTAG + MINIMUM_STR + tooltipSepChar + BOLDENDTAG + numberFormatter.dataLabels(min);
        }
      }
      config.toolText = toolText;
      config.setTooltext = toolText;
      tempPlotfillAngle && (plotfillAngle = tempPlotfillAngle);
    }

    // conf.maxNumberOfOutliers = maxNumberOfOutliers;

    if (showAllOutliers) {
      maxmin = dataset._getOutLiersLimit();
      maxValue = Math.max(maxValue, maxmin.max);
      minValue = Math.min(minValue, maxmin.min);
    } else {
      difference = maxValue - minValue;
      maxValue += conf.outliersupperrangeratio * difference;
      minValue -= conf.outlierslowerrangeratio * difference;
    }

    conf.maxValue = maxValue;
    conf.minValue = minValue;

    dataset.setState('dirty', true);
    dataset._createSubDS();
    chartConfig.showLegend && dataset._addLegend();

    // (chart.config.hasLegend !== false) && dataset._addLegend();

    // dataset.subDS = 0;

    // (dataset.components.mean = dataset._createSubDS(0, MEAN_STR));

    // conf.showMeanLegend && (dataset._addLegendSubDS(dataset.components.mean));
    // conf.showMeanLegend && (dataset.subDS += 1);

    // (dataset.components.sd = dataset._createSubDS(1, SD_STR));
    // conf.showSDLegend && (dataset._addLegendSubDS(dataset.components.sd));
    // conf.showSDLegend && (dataset.subDS += 1);

    // (dataset.components.md = dataset._createSubDS(2, MD_STR));
    // conf.showMDLegend && (dataset._addLegendSubDS(dataset.components.md));
    // conf.showMDLegend && (dataset.subDS += 1);

    // (dataset.components.qd = dataset._createSubDS(3, QD_STR));
    // conf.showQDLegend && (dataset._addLegendSubDS(dataset.components.qd));
    // conf.showQDLegend && (dataset.subDS += 1);

    // !dataset.components.outliers && (dataset.components.outliers = []);

    // OutliersLength = dataset.config.maxNumberOfOutliers || dataset.components.outliers.length;

    // for (i = 0; i < OutliersLength; i++) {
    //   outlierDS = (dataset._createSubDS(4 + i, OUTLIERS_STR, i));
    //   dataset.components.outliers[i] = outlierDS;
    // }
    // conf.showOutliersLegend && (dataset._addLegendOutliers(dataset.components.outliers));
    // conf.showOutliersLegend && (dataset.subDS += 1);
  };

  /**
   * Function to create the derived sub-dataset
   */


  BoxAndWhiskerDataset.prototype._createSubDS = function _createSubDS() {
    var dataset = this,
        config = dataset.config,
        index = config.index,
        lineJSON = dataset.getFromEnv('lineJSON')[index],
        len = lineJSON.length;

    (0, _lib.datasetFactory)(dataset, _boxandwhiskerline2['default'], 'dataset', len, lineJSON);
    if (!len) {
      dataset.iterateComponents(function (child) {
        if (child.getName() === 'line') {
          child.remove();
        }
      });
    }
  };

  /**
   * Function to get the maximum and minimum of the outliers
   * @return {Object} The max and min value of the outliers
   */


  BoxAndWhiskerDataset.prototype._getOutLiersLimit = function _getOutLiersLimit() {
    var dataset = this,
        index = dataset.config.index,
        lineJSON = dataset.getFromEnv('lineJSON')[index],
        len = lineJSON.length,
        dataJSON,
        dataLen,
        j,
        data,
        max = -Infinity,
        min = +Infinity,
        i;

    for (i = 0; i < len; i++) {
      dataJSON = lineJSON[i];
      if (dataJSON.seriesname === 'Outliers') {
        data = dataJSON.data;
        dataLen = data.length;
        for (j = 0; j < dataLen; j++) {
          max = Math.max(data[j].value, max);
          min = Math.min(data[j].value, min);
        }
        return {
          max: max,
          min: min
        };
      }
    }
  };

  /**
   * Parses plot attributes and position during post space management
   *
   * @param {any} dataObj dataObj
   * @param {any} index index
   * @memberof BoxAndWhiskerDataset
   */


  BoxAndWhiskerDataset.prototype.parsePlotAttributes = function parsePlotAttributes(dataObj, index) {
    var dataset = this,
        JSONData = dataset.config.JSONData,
        conf = dataset.config,
        datasetIndex = conf.index,
        i = index,
        visible = dataset.getState('visible'),
        chart = dataset.getFromEnv('chart'),
        chartConfig = dataset.getFromEnv('chartConfig'),
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),
        xPos,
        showTooltip = conf.showtooltip,
        columnWidth,
        xPosOffset,
        toolText,
        dataStore = dataset.components.data,
        setLink,
        setValue,
        config,
        upperQuartile,
        yTop,
        yTopPos,
        lowerQuartile,
        yBottom,
        yBottomPos,
        median,
        yMed,
        yMedPos,
        upperBoxH,
        lowerBoxH,
        upperBoxBorder,
        lowerBoxBorder,
        crispX,
        crispX2,
        crispY,
        style = chartConfig.dataLabelStyle,
        hoverOutEffects,
        rotateValues = conf.rotatevalues,
        valuePadding = conf.valuepadding,
        numberFormatter = dataset.getFromEnv('number-formatter'),
        textAlign = rotateValues ? _lib.POSITION_LEFT : _lib.POSITION_MIDDLE,
        smartLabel = dataset.getFromEnv('smartLabel'),
        graphic,
        errorStartPos,
        errorBarWidth,
        halfErrorBarW,
        errorValPos,
        crispyX,
        crispyY,
        errorPath,
        smartText,
        lineHeight,
        labelBottomY,
        labelTopY,
        lastDataSetHeight = +Infinity,
        lastDataSetYpos,
        lowerBoxBorderEleAttr,
        lowerBoxElemAttr,
        lowerQuartileEleAttr,
        lowerWhiskerEleAttr,
        midLineElemAttr,
        upperBoxBorderEleAttr,
        upperBoxElemAttr,
        upperQuartileEleAttr,
        upperWhiskerEleAttr,
        upperQuartileMaxLabelAttr,
        upperQuartileMinLabelAttr,
        upperQuartileLabelAttr,
        lowerQuartileLabelAttr,
        medianLabelAttr,
        upperBoxStartPos,
        lowerBoxYPos,
        lowerBoxHeight,
        lowerBoxEndPos;

    xPosOffset = dataset.getFromEnv('columnXShift');
    columnWidth = dataset.getFromEnv('columnWidth');
    config = dataObj && dataObj.config;
    setValue = config && config.setValue;

    // If plot value is found "null", continue the loop to next iteration.
    if (dataObj === UNDEFINED || setValue === UNDEFINED || setValue === null) {
      return;
    }

    graphic = dataObj.graphics;

    // isPositive = setValue >= 0;

    setLink = config.setLink;
    // Creating the data structure if not present for storing the graphics elements.
    if (!dataObj.graphics) {
      dataStore[i].graphics = {};
    }
    if (!graphic.label) {
      dataStore[i].graphics.label = [];
    }

    // Getting the previous yposition of the plot and calculating the current yposition of the plot.
    // previousYPos = yAxis.getPixel(previousY || yBase);
    xPos = xAxis.getPixel(i) + xPosOffset;

    upperQuartile = config.upperQuartile || {};
    yTop = upperQuartile && upperQuartile.value;
    yTopPos = (yTop || yTop === 0) && yAxis.getPixel(yTop);

    lowerQuartile = config.lowerQuartile || {};
    yBottom = lowerQuartile && lowerQuartile.value;
    yBottomPos = (yBottom || yBottom === 0) && yAxis.getPixel(yBottom);

    median = config.median;
    yMed = median && median.value; // || yBottom;
    yMedPos = (yMed || yMed === 0) && yAxis.getPixel(yMed);

    upperBoxH = yMedPos - yTopPos;
    lowerBoxH = yBottomPos - yMedPos;

    upperBoxBorder = config.upperBoxBorder || {};
    lowerBoxBorder = config.lowerBoxBorder || {};

    toolText = config.toolText;

    config.eventArgs = {
      index: i,
      link: setLink,
      maximum: config.max,
      minimum: config.min,
      median: yMed,
      q3: upperQuartile.value,
      q1: lowerQuartile.value,
      maxDisplayValue: config.showMaxValues ? numberFormatter.dataLabels(config.max) : _lib.BLANKSTRING,
      minDisplayValue: config.showMinValues ? numberFormatter.dataLabels(config.min) : _lib.BLANKSTRING,
      medianDisplayValue: config.showMedianValues ? numberFormatter.dataLabels(yMed) : _lib.BLANKSTRING,
      q1DisplayValue: config.showQ1Values ? numberFormatter.dataLabels(lowerQuartile.value) : _lib.BLANKSTRING,
      q3DisplayValue: config.showQ3Values ? numberFormatter.dataLabels(upperQuartile.value) : _lib.BLANKSTRING,
      categoryLabel: config.label,
      toolText: toolText,
      datasetIndex: datasetIndex,
      datasetName: JSONData.seriesname,
      visible: visible
    };

    // upperBox
    crispX = Math.round(xPos) + upperBoxBorder.borderWidth % 2 * 0.5;
    crispX2 = Math.round(xPos + columnWidth) + upperBoxBorder.borderWidth % 2 * 0.5;
    crispY = Math.round(yTopPos) + upperQuartile.borderWidth % 2 * 0.5;
    columnWidth = crispX2 - crispX;

    hoverOutEffects = {
      upperBox: {
        fill: (0, _lib.toRaphaelColor)(config.upperColorArr[0]), // upperQuartile.color
        'stroke-width': 0,
        'stroke-dasharray': NONE,
        cursor: setLink ? POINTER : _lib.BLANKSTRING,
        ishot: true,
        visibility: visible
      },
      lowerBox: {
        fill: (0, _lib.toRaphaelColor)(config.lowerColorArr[0]),
        'stroke-width': 0,
        'stroke-dasharray': NONE,
        cursor: setLink ? POINTER : BLANK,
        ishot: true,
        visibility: visible
      },
      upperBoxBorder: {
        stroke: upperBoxBorder.color,
        'stroke-width': upperBoxBorder.borderWidth,
        'stroke-linecap': ROUND,
        dashstyle: upperBoxBorder.dashStyle,
        ishot: true,
        visibility: visible
      },
      lowerBoxBorder: {
        stroke: lowerBoxBorder.color,
        'stroke-width': lowerBoxBorder.borderWidth,
        dashstyle: lowerBoxBorder.dashStyle,
        'stroke-linecap': ROUND,
        ishot: true,
        visibility: visible
      },
      upperQuartile: {
        stroke: (0, _lib.toRaphaelColor)(upperQuartile.color),
        'stroke-width': upperQuartile.borderWidth,
        'stroke-dasharray': upperQuartile.dashSyle,
        'stroke-linecap': ROUND,
        cursor: setLink ? POINTER : BLANK,
        ishot: true,
        visibility: visible
      },
      lowerQuartile: {
        stroke: (0, _lib.toRaphaelColor)(lowerQuartile.color),
        'stroke-width': lowerQuartile.borderWidth,
        'stroke-dasharray': lowerQuartile.dashSyle,
        cursor: setLink ? POINTER : _lib.BLANKSTRING,
        'stroke-linecap': ROUND,
        ishot: true,
        visibility: visible
      },
      median: {
        stroke: (0, _lib.toRaphaelColor)(median.color),
        'stroke-width': median.borderWidth,
        'stroke-dasharray': median.dashSyle,
        cursor: setLink ? POINTER : _lib.BLANKSTRING,
        'stroke-linecap': ROUND,
        ishot: true,
        visibility: visible
      }
    };

    upperBoxStartPos = lastDataSetYpos || crispY;

    // draw upperbox element
    upperBoxElemAttr = (0, _assign2['default'])({
      x: crispX,
      y: lastDataSetYpos || crispY,
      width: Math.max(columnWidth, 0),
      height: Math.max(Math.min(lastDataSetHeight, upperBoxH), 0),
      r: 0
    }, hoverOutEffects.upperBox);

    // upperBoxBorder element
    upperBoxBorderEleAttr = (0, _assign2['default'])({
      path: [M, crispX, lastDataSetYpos || crispY, V, lastDataSetYpos || crispY + upperBoxH, M, crispX2, lastDataSetYpos || crispY, V, lastDataSetYpos || crispY + upperBoxH]
    }, hoverOutEffects.upperBoxBorder);

    // upperQuartileBorder element
    upperQuartileEleAttr = (0, _assign2['default'])({
      path: [M, crispX, lastDataSetYpos || crispY, H, crispX + columnWidth]
    }, hoverOutEffects.upperQuartile);

    errorStartPos = crispY;
    errorBarWidth = columnWidth * (conf.whiskerslimitswidthratio / 100);
    halfErrorBarW = errorBarWidth / 2;

    // Vertical Error drawing
    errorValPos = yAxis.getPixel(config.max);
    crispyY = errorValPos;
    crispyX = crispX;

    crispyY = Math.round(errorValPos) + config.upperWhiskerThickness % 2 / 2;
    crispX = Math.round(crispX + columnWidth / 2) + config.upperWhiskerThickness % 2 / 2;

    errorPath = [M, crispX, lastDataSetYpos || errorStartPos, V, Math.min(lastDataSetYpos || crispyY, upperBoxStartPos), M, crispX - halfErrorBarW, Math.min(lastDataSetYpos || crispyY, upperBoxStartPos), H, crispX + halfErrorBarW];

    upperWhiskerEleAttr = {
      path: errorPath,
      // In case of tooltip disabled this element should act as the hot element.
      ishot: !showTooltip,
      'stroke-width': config.upperWhiskerThickness,
      'cursor': setLink ? POINTER : _lib.BLANKSTRING,
      'stroke-linecap': ROUND,
      stroke: config.upperWhiskerColor
    };

    smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
    smartLabel.setStyle(style);
    smartText = smartLabel.getOriSize(numberFormatter.dataLabels(config.max));
    lineHeight = rotateValues ? smartText.width : smartText.height;
    labelTopY = errorValPos - config.upperWhiskerThickness * 0.5 - valuePadding - lineHeight * (rotateValues ? 0.5 : 1);

    if (labelTopY - (rotateValues ? lineHeight / 2 : 0) < chartConfig.canvasTop) {
      labelTopY = chartConfig.canvasTop + (rotateValues ? lineHeight / 2 : 0);
    }

    upperQuartileMaxLabelAttr = {
      text: numberFormatter.dataLabels(config.max),
      x: crispyX + columnWidth / 2,
      title: upperQuartile.originalText || _lib.BLANKSTRING,
      y: lastDataSetYpos || labelTopY,
      'text-anchor': rotateValues ? _lib.POSITION_MIDDLE : textAlign,
      'vertical-align': rotateValues ? _lib.POSITION_MIDDLE : POSITION_TOP,
      'visibility': _lib.visibleStr,
      direction: conf.textDirection,
      fill: style.color,
      transform: (0, _lib.getSuggestiveRotation)(rotateValues, crispyX + columnWidth / 2, labelTopY),
      'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
    };

    crispX = Math.round(xPos) + lowerBoxBorder.borderWidth % 2 * 0.5;
    crispX2 = Math.round(xPos + columnWidth) + lowerBoxBorder.borderWidth % 2 * 0.5;
    crispY = Math.round(yMedPos + lowerBoxH) + lowerQuartile.borderWidth % 2 * 0.5;

    lowerBoxYPos = lastDataSetYpos || yMedPos;
    lowerBoxHeight = Math.max(Math.min(lastDataSetHeight, crispY - yMedPos), 0);

    lowerBoxEndPos = lowerBoxYPos + lowerBoxHeight;

    // draw lower element
    lowerBoxElemAttr = (0, _assign2['default'])({
      x: crispX,
      y: lowerBoxYPos,
      width: Math.max(columnWidth, 0),
      height: lowerBoxHeight,
      r: 0
    }, hoverOutEffects.lowerBox);

    // lowerBoxBorder element
    lowerBoxBorderEleAttr = (0, _assign2['default'])({
      path: [M, crispX, lastDataSetYpos || yMedPos, V, lastDataSetYpos || yMedPos + lowerBoxH, M, crispX2, lastDataSetYpos || yMedPos, V, lastDataSetYpos || yMedPos + lowerBoxH]
    }, hoverOutEffects.lowerBoxBorder);

    // lowerQuartileBorder element
    crispY = Math.round(yMedPos + lowerBoxH) + lowerQuartile.borderWidth % 2 * 0.5;

    lowerQuartileEleAttr = (0, _assign2['default'])({
      path: [M, crispX, lastDataSetYpos || crispY, H, crispX + columnWidth]
    }, hoverOutEffects.lowerQuartile);

    errorStartPos = crispY;
    errorBarWidth = columnWidth * (conf.whiskerslimitswidthratio / 100);
    halfErrorBarW = errorBarWidth / 2;

    // Vertical Error drawing
    errorValPos = yAxis.getPixel(config.min);
    crispyY = errorValPos;
    crispyX = crispX;

    crispyY = Math.round(errorValPos) + config.lowerWhiskerThickness % 2 / 2;
    crispyX = Math.round(crispyX + columnWidth / 2) + config.lowerWhiskerThickness % 2 / 2;

    errorPath = [M, crispyX, lastDataSetYpos || errorStartPos, V, Math.max(lastDataSetYpos || crispyY, lowerBoxEndPos), M, crispyX - halfErrorBarW, Math.max(lastDataSetYpos || crispyY, lowerBoxEndPos), H, crispyX + halfErrorBarW];

    smartLabel.setStyle(style);
    smartText = smartLabel.getOriSize(numberFormatter.dataLabels(config.min));
    lineHeight = rotateValues ? smartText.width : smartText.height;

    labelBottomY = errorValPos + config.lowerWhiskerThickness * 0.5 + valuePadding;

    if (labelBottomY + lineHeight > chartConfig.canvasBottom) {
      labelBottomY = chartConfig.canvasBottom - lineHeight;
    }

    upperQuartileMinLabelAttr = {
      text: numberFormatter.dataLabels(config.min),
      x: crispyX,
      title: upperQuartile.originalText || _lib.BLANKSTRING,
      y: lastDataSetYpos || labelBottomY,
      'text-anchor': rotateValues ? POSITION_END : textAlign,
      'vertical-align': rotateValues ? _lib.POSITION_MIDDLE : POSITION_TOP,
      'visibility': _lib.visibleStr,
      direction: conf.textDirection,
      fill: style.color,
      transform: (0, _lib.getSuggestiveRotation)(rotateValues, crispyX, labelBottomY),
      'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
    };

    lowerWhiskerEleAttr = {
      path: errorPath,
      // In case of tooltip disabled this element should act as the hot element.
      ishot: !showTooltip,
      'stroke-width': config.lowerWhiskerThickness,
      'cursor': setLink ? POINTER : _lib.BLANKSTRING,
      'stroke-linecap': ROUND,
      stroke: config.lowerWhiskerColor
    };

    // medianBorder
    crispY = Math.round(yMedPos) + median.borderWidth % 2 * 0.5;

    midLineElemAttr = (0, _assign2['default'])({
      path: [M, crispX, lastDataSetYpos || crispY, H, crispX + columnWidth]
    }, hoverOutEffects.median);

    textAlign = rotateValues ? _lib.POSITION_LEFT : _lib.POSITION_MIDDLE;

    upperQuartileLabelAttr = {
      text: upperQuartile.displayValue,
      x: xPos + columnWidth / 2,
      title: upperQuartile.originalText || _lib.BLANKSTRING,
      y: yTopPos - valuePadding,
      'text-anchor': rotateValues ? POSITION_START : textAlign,
      'vertical-align': rotateValues ? _lib.POSITION_MIDDLE : POSITION_BOTTOM,
      'visibility': _lib.visibleStr,
      direction: conf.textDirection,
      fill: style.color,
      transform: (0, _lib.getSuggestiveRotation)(rotateValues, xPos + columnWidth / 2, yTopPos - valuePadding),
      'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
    };

    medianLabelAttr = {
      text: median.displayValue,
      x: crispX + columnWidth / 2,
      y: yMedPos - valuePadding,
      title: median.originalText || _lib.BLANKSTRING,
      'text-anchor': rotateValues ? POSITION_START : textAlign,
      'vertical-align': rotateValues ? _lib.POSITION_MIDDLE : POSITION_BOTTOM,
      'visibility': _lib.visibleStr,
      direction: conf.textDirection,
      fill: style.color,
      transform: (0, _lib.getSuggestiveRotation)(rotateValues, crispX + columnWidth / 2, yMedPos - valuePadding),
      'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
    };

    lowerQuartileLabelAttr = {
      text: lowerQuartile.displayValue,
      x: xPos + columnWidth / 2,
      y: yBottomPos + valuePadding,
      title: lowerQuartile.originalText || _lib.BLANKSTRING,
      'text-anchor': rotateValues ? POSITION_START : textAlign,
      'vertical-align': rotateValues ? _lib.POSITION_MIDDLE : POSITION_TOP,
      'visibility': _lib.visibleStr,
      direction: conf.textDirection,
      fill: style.color,
      transform: (0, _lib.getSuggestiveRotation)(rotateValues, xPos + columnWidth / 2, yBottomPos + valuePadding),
      'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
    };

    config.props = {
      lowerBoxBorderEle: {
        attr: lowerBoxBorderEleAttr
      },
      lowerBoxElem: {
        attr: lowerBoxElemAttr
      },
      lowerQuartileEle: {
        attr: lowerQuartileEleAttr
      },
      lowerWhiskerEle: {
        attr: lowerWhiskerEleAttr
      },
      midLineElem: {
        attr: midLineElemAttr
      },
      upperBoxElem: {
        attr: upperBoxElemAttr
      },
      upperBoxBorderEle: {
        attr: upperBoxBorderEleAttr
      },
      upperQuartileEle: {
        attr: upperQuartileEleAttr
      },
      upperWhiskerEle: {
        attr: upperWhiskerEleAttr
      },
      upperQuartileMaxLabel: {
        attr: upperQuartileMaxLabelAttr
      },
      upperQuartileMinLabel: {
        attr: upperQuartileMinLabelAttr
      },
      medianLabel: {
        attr: medianLabelAttr
      },
      upperQuartileLabel: {
        attr: upperQuartileLabelAttr
      },
      lowerQuartileLabel: {
        attr: lowerQuartileLabelAttr
      }
    };
  };
  /**
   * Parses attributes and allocates position during
   * post space management
   *
   * @memberof BoxAndWhiskerDataset
   */


  BoxAndWhiskerDataset.prototype.allocatePosition = function allocatePosition() {
    var dataset = this,
        setDataArr = dataset.config.JSONData.data,
        datasetLen = setDataArr && setDataArr.length,
        xAxis = dataset.getFromEnv('xAxis'),
        catLen = xAxis.getTicksLen(),
        dataStore = dataset.components.data,
        dataObj,
        i,
        len;

    len = Math.min(catLen, datasetLen);

    dataset.setColumnPosition();
    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      dataset.parsePlotAttributes(dataObj, i);
    }
  };
  /**
   * functioto draw and update the graphics elements of plots
   */


  BoxAndWhiskerDataset.prototype.drawPlots = function drawPlots() {
    var dataset = this,
        JSONData = dataset.config.JSONData,
        conf = dataset.config,
        datasetIndex = conf.index,
        setDataArr = JSONData.data,
        datasetLen = setDataArr && setDataArr.length,
        len,
        i,
        visible = dataset.getState('visible'),
        chart = dataset.getFromEnv('chart'),
        xAxis = dataset.getFromEnv('xAxis'),
        catLen = xAxis.getTicksLen(),
        showTooltip = conf.showtooltip,
        toolTipController = dataset.getFromEnv('toolTipController'),
        toolText,
        dataStore = dataset.components.data,
        dataObj,
        setValue,
        config,
        showShadow = conf.showShadow,
        upperBoxContainer = dataset.getContainer('upperBoxGroup').toBack(),
        lowerBoxContainer = dataset.getContainer('lowerBoxGroup'),
        medianContainer = dataset.getContainer('medianGroup'),
        upperWhiskerContainer = dataset.getContainer('upperWhiskerGroup'),
        lowerWhiskerContainer = dataset.getContainer('lowerWhiskerGroup'),
        dataLabelContainer = dataset.getContainer('labelGroup'),
        shadowContainer = dataset.getContainer('shadowGroup'),
        upperQuartile,
        applyShadow,
        lowerQuartile,
        median,
        upperBoxElem,
        upperBoxElemCheck,
        upperBoxBorderEle,
        upperBoxBorderEleCheck,
        upperQuartileEle,
        upperQuartileEleCheck,
        lowerBoxElem,
        lowerBoxElemCheck,
        lowerBoxBorderEle,
        lowerBoxBorderEleCheck,
        lowerQuartileEle,
        lowerQuartileEleCheck,
        midLineElem,
        midLineElemCheck,
        label,
        labelCheck,
        smartLabel = dataset.getFromEnv('smartLabel'),
        graphic,
        groupId,
        upperWhiskerEle,
        upperWhiskerEleCheck,
        lowerWhiskerEle,
        lowerWhiskerEleCheck,
        ele,
        graphics,
        removeDataArr = dataset.components.removeDataArr || [],
        removeDataArrLen = removeDataArr.length,
        newupperBoxElem,
        newlowerBoxElem,
        newupperBoxBorderEle,
        newlowerBoxBorderEle,
        newupperQuartileEle,
        newlowerQuartileEle,
        newmidLineElem,
        newupperWhiskerEle,
        newlowerWhiskerEle,
        hoverInAttr,
        hoverOutAttr,
        showHoverEffect = conf.showHoverEffect,
        k,
        subarr,
        arrlen,
        animationManager = dataset.getFromEnv('animationManager'),

    // Fired when clicked over the hot elements.
    clickFunc = function clickFunc(setDataArr) {
      var ele = this;
      _lib.plotEventHandler.call(ele, chart, setDataArr);
    },


    // Fired on mouse-in over the hot elements.
    rolloverResponseSetter = function rolloverResponseSetter(obj) {
      return function (data) {
        var ele = this,
            elem;
        if (ele.data(showHoverEffectStr) !== 0) {
          for (elem in obj) {
            if (elem !== LABEL) {
              animationManager.setAnimation({
                el: obj[elem],
                attr: ele.data(SETROLLOVERATTR)[elem],
                component: dataset
              });
              _lib.plotEventHandler.call(ele, chart, data, ROLLOVER);
            }
          }
        }
      };
    },


    // Fired on mouse-out over the hot elements.
    rolloutResponseSetter = function rolloutResponseSetter(obj) {
      return function (data) {
        var ele = this,
            elem;

        if (ele.data(showHoverEffectStr) !== 0) {
          for (elem in obj) {
            if (elem !== LABEL) {
              animationManager.setAnimation({
                el: obj[elem],
                attr: ele.data(SETROLLOUTATTR)[elem],
                component: dataset
              });
              _lib.plotEventHandler.call(ele, chart, data, ROLLOUT);
            }
          }
        }
      };
    },
        animCallBack = function animCallBack() {
      if (dataset.getState('visible') === false && (dataset._conatinerHidden === false || dataset._conatinerHidden === UNDEFINED)) {
        upperBoxContainer.hide();
        lowerBoxContainer.hide();
        upperWhiskerContainer.hide();
        lowerWhiskerContainer.hide();
        medianContainer.hide();
        shadowContainer.hide();
        dataLabelContainer && dataLabelContainer.hide();
        dataset._conatinerHidden = true;
      }
    };

    applyShadow = function applyShadow(shadowProps) {
      return function () {
        this.show();
        this.shadow(shadowProps);
      };
    };

    dataset.setColumnPosition();
    if (!visible) {
      dataLabelContainer.hide();
      upperWhiskerContainer.hide();
      upperBoxContainer.hide();
      lowerWhiskerContainer.hide();
      lowerBoxContainer.hide();
      medianContainer.hide();
      shadowContainer.hide();
    } else {
      // Showing the groups when visible set to true
      upperBoxContainer.show();
      lowerBoxContainer.show();
      upperWhiskerContainer.show();
      lowerWhiskerContainer.show();
      medianContainer.show();
      shadowContainer.show();
      dataLabelContainer.show();
      dataset._conatinerHidden = false;
    }

    len = Math.min(catLen, datasetLen);

    // Create plot elements.
    for (i = 0; i < len; i++) {
      // setData = setDataArr && setDataArr[i];
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;
      setValue = config && config.setValue;

      newupperBoxElem = false;
      newlowerBoxElem = false;
      newupperBoxBorderEle = false;
      newlowerBoxBorderEle = false;
      newupperQuartileEle = false;
      newlowerQuartileEle = false;
      newmidLineElem = false;
      newupperWhiskerEle = false;
      newlowerWhiskerEle = false;

      // If plot value is found "null", continue the loop to next iteration.
      if (dataObj === UNDEFINED || setValue === UNDEFINED || setValue === null) {
        graphics = dataObj.graphics;
        for (ele in graphics) {
          if (graphics[ele] instanceof Array) {
            subarr = graphics[ele];
            for (k = 0, arrlen = subarr.length; k < arrlen; k++) {
              subarr[k] && subarr[k].hide();
            }
          } else {
            graphics[ele].hide();
          }
        }
        continue;
      }

      graphic = dataObj.graphics;

      // Creating the data structure if not present for storing the graphics elements.
      if (!dataObj.graphics) {
        dataStore[i].graphics = {};
      }
      if (!graphic.label) {
        dataStore[i].graphics.label = [];
      }

      upperQuartile = config.upperQuartile || {};
      lowerQuartile = config.lowerQuartile || {};

      median = config.median;
      toolText = config.toolText;
      groupId = datasetIndex + UNDERSCORE + i;

      upperBoxElemCheck = dataObj.graphics.upperBoxElem;
      upperBoxElem = animationManager.setAnimation({
        el: upperBoxElemCheck || 'rect',
        attr: config.props.upperBoxElem.attr,
        label: 'upperBox',
        container: upperBoxContainer,
        component: dataset
      });
      if (!upperBoxElemCheck) {
        dataObj.graphics.upperBoxElem = upperBoxElem;
        newupperBoxElem = true;
      }

      upperBoxElem.shadow({ opacity: showShadow ? conf.upperBoxAlpha / 100 : 0 }, shadowContainer);

      upperBoxBorderEleCheck = dataObj.graphics.upperBoxBorderEle;
      upperBoxBorderEle = animationManager.setAnimation({
        el: upperBoxBorderEleCheck || 'path',
        attr: config.props.upperBoxBorderEle.attr,
        container: upperBoxContainer,
        dom: 'path',
        component: dataset
      });
      if (!upperBoxBorderEleCheck) {
        dataObj.graphics.upperBoxBorderEle = upperBoxBorderEle;
        newupperBoxBorderEle = true;
      }

      upperQuartileEleCheck = dataObj.graphics.upperQuartileEle;
      upperQuartileEle = animationManager.setAnimation({
        el: upperQuartileEleCheck || 'path',
        attr: config.props.upperQuartileEle.attr,
        dom: 'path',
        container: upperBoxContainer,
        component: dataset
      });
      if (!upperQuartileEleCheck) {
        dataObj.graphics.upperQuartileEle = upperQuartileEle;
        newupperQuartileEle = true;
      }

      upperWhiskerEleCheck = dataObj.graphics.upperWhiskerEle;

      upperWhiskerEle = animationManager.setAnimation({
        el: upperWhiskerEleCheck || 'path',
        attr: config.props.upperWhiskerEle.attr,
        dom: 'path',
        container: upperWhiskerContainer,
        component: dataset,
        callback: applyShadow({ opacity: config.upperWhiskerShadowOpacity }, shadowContainer)
      });
      if (!upperWhiskerEleCheck) {
        dataObj.graphics.upperWhiskerEle = upperWhiskerEle;
        newupperWhiskerEle = true;
      }

      smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
      if (config.showMaxValues) {
        labelCheck = graphic.label[3];
        labelCheck && labelCheck.show();
        label = animationManager.setAnimation({
          el: labelCheck || 'text',
          attr: config.props.upperQuartileMaxLabel.attr,
          component: dataset,
          dom: 'text',
          container: dataLabelContainer
        });
        if (!labelCheck) {
          graphic.label[3] = label;
        }
        graphic.label[3].data(GROUPID, groupId);
      } else {
        graphic.label[3] && animationManager.setAnimation({
          el: graphic.label[3],
          component: dataset,
          attr: { 'text-bound': [] },
          callback: _hide.call(graphic.label[3])
        });
      }

      lowerBoxElemCheck = dataObj.graphics.lowerBoxElem;
      lowerBoxElem = animationManager.setAnimation({
        el: lowerBoxElemCheck || 'rect',
        attr: config.props.lowerBoxElem.attr,
        label: 'lowerBox',
        container: lowerBoxContainer,
        component: dataset
      });
      if (!lowerBoxElemCheck) {
        dataObj.graphics.lowerBoxElem = lowerBoxElem;
        newlowerBoxElem = true;
      }

      lowerBoxElem.shadow({ opacity: showShadow ? conf.lowerBoxAlpha / 100 : 0 }, shadowContainer);

      lowerBoxBorderEleCheck = dataObj.graphics.lowerBoxBorderEle;
      lowerBoxBorderEle = animationManager.setAnimation({
        el: lowerBoxBorderEleCheck || 'path',
        attr: config.props.lowerBoxBorderEle.attr,
        component: dataset,
        dom: 'path',
        container: lowerBoxContainer
      });
      if (!lowerBoxBorderEleCheck) {
        dataObj.graphics.lowerBoxBorderEle = lowerBoxBorderEle;
        newlowerBoxBorderEle = true;
      }

      lowerQuartileEleCheck = dataObj.graphics.lowerQuartileEle;
      lowerQuartileEle = animationManager.setAnimation({
        el: lowerQuartileEleCheck || 'path',
        attr: config.props.lowerQuartileEle.attr,
        component: dataset,
        dom: 'path',
        container: lowerBoxContainer
      });
      if (!lowerQuartileEleCheck) {
        dataObj.graphics.lowerQuartileEle = lowerQuartileEle;
        newlowerQuartileEle = true;
      }

      lowerWhiskerEle = dataObj.graphics.lowerWhiskerEle;

      if (config.showMinValues) {
        labelCheck = graphic.label[4];
        labelCheck && labelCheck.show();
        label = animationManager.setAnimation({
          el: labelCheck || 'text',
          attr: config.props.upperQuartileMinLabel.attr,
          dom: 'text',
          container: dataLabelContainer,
          component: dataset
        });
        if (!labelCheck) {
          graphic.label[4] = label;
        }

        graphic.label[4].data(GROUPID, groupId);
      } else {
        graphic.label[4] && animationManager.setAnimation({
          el: graphic.label[4],
          component: dataset,
          attr: { 'text-bound': [] },
          callback: _hide.call(graphic.label[4])
        });
      }

      lowerWhiskerEleCheck = dataObj.graphics.lowerWhiskerEle;
      lowerWhiskerEle = animationManager.setAnimation({
        el: lowerWhiskerEleCheck || 'path',
        attr: config.props.lowerWhiskerEle.attr,
        dom: 'path',
        container: lowerWhiskerContainer,
        component: dataset,
        callback: applyShadow({ opacity: config.lowerWhiskerShadowOpacity }, shadowContainer)
      });
      if (!lowerWhiskerEleCheck) {
        dataObj.graphics.lowerWhiskerEle = lowerWhiskerEle;
        newlowerWhiskerEle = true;
      }

      midLineElemCheck = dataObj.graphics.midLineElem;
      midLineElem = animationManager.setAnimation({
        el: midLineElemCheck || 'path',
        component: dataset,
        label: 'midline',
        container: medianContainer,
        attr: config.props.midLineElem.attr
      });
      if (!midLineElemCheck) {
        dataObj.graphics.midLineElem = midLineElem;
        newmidLineElem = true;
      }

      hoverInAttr = {
        upperBoxElem: config.setUpperBoxRolloverAttr,
        lowerBoxElem: config.setLowerBoxRolloverAttr,
        upperBoxBorderEle: config.setUpperBoxBorderRolloverAttr,
        lowerBoxBorderEle: config.setLowerBoxBorderRolloverAttr,
        upperQuartileEle: config.setUpperQuartileRolloverAttr,
        lowerQuartileEle: config.setLowerQuartileRolloverAttr,
        midLineElem: config.setMedianRolloverAttr

      };

      hoverOutAttr = {
        upperBoxElem: config.setUpperBoxRolloutAttr,
        lowerBoxElem: config.setLowerBoxRolloutAttr,
        upperBoxBorderEle: config.setUpperBoxBorderRolloutAttr,
        lowerBoxBorderEle: config.setLowerBoxBorderRolloutAttr,
        upperQuartileEle: config.setUpperQuartileRolloutAttr,
        lowerQuartileEle: config.setLowerQuartileRolloutAttr,
        midLineElem: config.setMedianRolloutAttr
      };

      upperBoxElem.data(GROUPID, groupId).data(EVENTARGS, config.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, hoverInAttr).data(SETROLLOUTATTR, hoverOutAttr);

      if (newupperBoxElem) {
        upperBoxElem.click(clickFunc).hover(rolloverResponseSetter(dataObj.graphics), rolloutResponseSetter(dataObj.graphics));
      }

      lowerBoxElem.data(GROUPID, groupId).data(EVENTARGS, config.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, hoverInAttr).data(SETROLLOUTATTR, hoverOutAttr);

      if (newlowerBoxElem) {
        lowerBoxElem.click(clickFunc).hover(rolloverResponseSetter(dataObj.graphics), rolloutResponseSetter(dataObj.graphics));
      }

      upperBoxBorderEle.data(GROUPID, groupId).data(EVENTARGS, config.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, hoverInAttr).data(SETROLLOUTATTR, hoverOutAttr);

      if (newupperBoxBorderEle) {
        upperBoxBorderEle.click(clickFunc).hover(rolloverResponseSetter(dataObj.graphics), rolloutResponseSetter(dataObj.graphics));
      }

      lowerBoxBorderEle.data(GROUPID, groupId).data(EVENTARGS, config.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, hoverInAttr).data(SETROLLOUTATTR, hoverOutAttr);

      if (newlowerBoxBorderEle) {
        lowerBoxBorderEle.click(clickFunc).hover(rolloverResponseSetter(dataObj.graphics), rolloutResponseSetter(dataObj.graphics));
      }

      upperQuartileEle.data(GROUPID, groupId).data(EVENTARGS, config.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, hoverInAttr).data(SETROLLOUTATTR, hoverOutAttr);

      if (newupperQuartileEle) {
        upperQuartileEle.click(clickFunc).hover(rolloverResponseSetter(dataObj.graphics), rolloutResponseSetter(dataObj.graphics));
      }

      lowerQuartileEle.data(GROUPID, groupId).data(EVENTARGS, config.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, hoverInAttr).data(SETROLLOUTATTR, hoverOutAttr);

      if (newlowerQuartileEle) {
        lowerQuartileEle.click(clickFunc).hover(rolloverResponseSetter(dataObj.graphics), rolloutResponseSetter(dataObj.graphics));
      }

      midLineElem.data(GROUPID, groupId).data(EVENTARGS, config.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, hoverInAttr).data(SETROLLOUTATTR, hoverOutAttr);

      if (newmidLineElem) {
        midLineElem.click(clickFunc).hover(rolloverResponseSetter(dataObj.graphics), rolloutResponseSetter(dataObj.graphics));
      }

      upperWhiskerEle.data(GROUPID, groupId).data(EVENTARGS, config.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, hoverInAttr).data(SETROLLOUTATTR, hoverOutAttr);

      if (newupperWhiskerEle) {
        upperWhiskerEle.click(clickFunc).hover(rolloverResponseSetter(dataObj.graphics), rolloutResponseSetter(dataObj.graphics));
      }

      lowerWhiskerEle.data(GROUPID, groupId).data(EVENTARGS, config.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, hoverInAttr).data(SETROLLOUTATTR, hoverOutAttr);

      if (newlowerWhiskerEle) {
        lowerWhiskerEle.click(clickFunc).hover(rolloverResponseSetter(dataObj.graphics), rolloutResponseSetter(dataObj.graphics));
      }

      if ((0, _lib.defined)(upperQuartile.displayValue) && upperQuartile.displayValue !== BLANK && config.showQ3Values) {
        labelCheck = graphic.label[0];
        labelCheck && labelCheck.show();
        label = animationManager.setAnimation({
          el: labelCheck || 'text',
          attr: config.props.upperQuartileLabel.attr,
          component: dataset,
          dom: 'text',
          container: dataLabelContainer
        });
        if (!labelCheck) {
          graphic.label[0] = label;
        }
        graphic.label[0].data(GROUPID, groupId);
      } else {
        graphic.label[0] && animationManager.setAnimation({
          el: graphic.label[0],
          component: dataset,
          attr: { 'text-bound': [] },
          callback: _hide.call(graphic.label[0])
        });
      }

      if ((0, _lib.defined)(median.displayValue) && median.displayValue !== BLANK && config.showMedianValues) {
        labelCheck = graphic.label[1];
        labelCheck && labelCheck.show();
        label = animationManager.setAnimation({
          el: labelCheck || 'text',
          attr: config.props.medianLabel.attr,
          component: dataset,
          dom: 'text',
          container: dataLabelContainer
        });
        if (!labelCheck) {
          graphic.label[1] = label;
        }
        graphic.label[1].data(GROUPID, groupId);
      } else {
        graphic.label[1] && animationManager.setAnimation({
          el: graphic.label[1],
          component: dataset,
          attr: { 'text-bound': [] },
          callback: _hide.call(graphic.label[1])
        });
      }

      if ((0, _lib.defined)(lowerQuartile.displayValue) && lowerQuartile.displayValue !== BLANK && config.showQ1Values) {
        labelCheck = graphic.label[2];
        label = animationManager.setAnimation({
          el: labelCheck || 'text',
          component: dataset,
          attr: config.props.lowerQuartileLabel.attr,
          container: dataLabelContainer
        });
        if (!labelCheck) {
          graphic.label[2] = label;
          label.show();
        }
        graphic.label[2].data(GROUPID, groupId);
      } else {
        graphic.label[2] && animationManager.setAnimation({
          el: graphic.label[2],
          component: dataset,
          attr: { 'text-bound': [] },
          callback: _hide.call(graphic.label[2])
        });
      }

      if (showTooltip) {
        toolTipController.enableToolTip(upperBoxElem, toolText);
        toolTipController.enableToolTip(lowerBoxElem, toolText);
        toolTipController.enableToolTip(upperBoxBorderEle, toolText);
        toolTipController.enableToolTip(lowerBoxBorderEle, toolText);
        toolTipController.enableToolTip(upperQuartileEle, toolText);
        toolTipController.enableToolTip(lowerQuartileEle, toolText);
        toolTipController.enableToolTip(midLineElem, toolText);
        toolTipController.enableToolTip(upperWhiskerEle, toolText);
        toolTipController.enableToolTip(lowerWhiskerEle, toolText);
      } else {
        toolTipController.enableToolTip(upperBoxElem, false);
        toolTipController.enableToolTip(lowerBoxElem, false);
        toolTipController.enableToolTip(upperBoxBorderEle, false);
        toolTipController.enableToolTip(lowerBoxBorderEle, false);
        toolTipController.enableToolTip(upperQuartileEle, false);
        toolTipController.enableToolTip(lowerQuartileEle, false);
        toolTipController.enableToolTip(midLineElem, false);
        toolTipController.enableToolTip(upperWhiskerEle, false);
        toolTipController.enableToolTip(lowerWhiskerEle, false);
      }
    }

    // There has to be a provision such that the callback is called after the end of the slot animation
    animCallBack();
    removeDataArrLen && dataset.removeElements();
  };
  /**
   * Function to remove a data from a dataset
   */


  BoxAndWhiskerDataset.prototype.removeElements = function removeElements() {
    var dataSet = this,
        components = dataSet.components,
        removeDataArr = components.removeDataArr,
        animationManager = dataSet.getFromEnv('animationManager'),
        len = removeDataArr.length,
        removeData,
        ele,
        graphics,
        i,
        innerLen,
        j;

    for (i = 0; i < len; i++) {
      removeData = removeDataArr[0];
      removeDataArr.splice(0, 1);
      // In case of non existing data plot continue;
      if (!removeData || !removeData.graphics) {
        continue;
      }

      graphics = removeData.graphics;
      for (ele in graphics) {
        if (ele !== LABEL) {
          graphics[ele].shadow({ opacity: 0 });
          graphics[ele].hide();
        } else {
          innerLen = graphics[ele].length;
          for (j = 0; j < innerLen; j++) {
            if (graphics[ele][j]) {
              graphics[ele][j].shadow({ opacity: 0 });
              animationManager.setAnimation({
                el: graphics[ele][j],
                component: dataSet,
                attr: { 'text-bound': [] },
                callback: _hide.call(graphics[ele][j])
              });
            }
          }
        }
      }
    }
  };

  /**
   * Function to remove a data with a given index.
   * @param {number}  index     from which index data would be removed
   * @param {number}  stretch   delete count
   * @param {boolean} draw      whether draw or not
   */


  BoxAndWhiskerDataset.prototype.removeData = function removeData(index, stretch, draw) {
    var dataSet = this,
        components = dataSet.components,
        dataStore = components.data,
        removeDataArr = components.removeDataArr || (components.removeDataArr = []);

    stretch = stretch || 1;
    index = index || 0;

    // Storing the direction of input data for the type of animation to be done during remove.
    if (index + stretch === dataStore.length) {
      dataSet.endPosition = true;
    } else if (index === 0 || index === UNDEFINED) {
      dataSet.endPosition = false;
    }

    components.removeDataArr = removeDataArr = removeDataArr.concat(dataStore.splice(index, stretch));

    draw && dataSet.asyncDraw();
  };
  /**
   * parse defualt configuration of the dataset
   */


  BoxAndWhiskerDataset.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ColumnDataset.prototype.__setDefaultConfig && _ColumnDataset.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    config.showplotborder = UNDEFINED;
    config.plotborderdashlen = UNDEFINED;
    config.plotborderdashgap = UNDEFINED;
    config.plotfillalpha = UNDEFINED;
    config.useroundedges = UNDEFINED;
    config.ratio = UNDEFINED;
    config.plotborderthickness = UNDEFINED;
    config.showvalues = UNDEFINED;
    config.valuepadding = UNDEFINED;
    config.showtooltip = UNDEFINED;
    config.maxcolwidth = UNDEFINED;
    config.rotatevalues = UNDEFINED;
    config.use3dlighting = UNDEFINED;
    config.whiskerslimitswidthratio = UNDEFINED;
    config.outliersupperrangeratio = UNDEFINED;
    config.outlierslowerrangeratio = UNDEFINED;
    config.showalloutliers = UNDEFINED;
    config.showmean = UNDEFINED;
    config.showsd = UNDEFINED;
    config.showmd = UNDEFINED;
    config.showqd = UNDEFINED;
    config.showminvalues = UNDEFINED;
    config.showmaxvalues = UNDEFINED;
    config.showq1values = UNDEFINED;
    config.showq3values = UNDEFINED;
    config.showmedianvalues = UNDEFINED;
  };

  /**
   * Function to get the maximum and minimum from dataset
   * @return {Object}     contains max, min value
   */


  BoxAndWhiskerDataset.prototype.getDataLimits = function getDataLimits() {
    var dataset = this,
        conf = dataset.config,
        removed = dataset.getState('removed');
    return {
      max: removed ? -Infinity : conf.maxValue,
      min: removed ? +Infinity : conf.minValue
    };
  };

  /**
   * Function to register datasets in the internal data store of legend class.
   */


  BoxAndWhiskerDataset.prototype._addLegend = function _addLegend() {
    var dataset = this,

    // chart = dataset.chart,
    strokeColor,
        fillColor,
        config,
        conf = dataset.config,
        legendItem,
        legend = dataset.getFromEnv('legend'),
        upperBoxColor = conf.upperBoxColor,
        lowerBoxColor = conf.lowerBoxColor;
    strokeColor = COLOR_000000;

    fillColor = {
      FCcolor: {
        color: upperBoxColor + _lib.COMMA + lowerBoxColor,
        angle: 90,
        ratio: '50, 0',
        alpha: '100, 100'
      }
    };

    config = {
      enabled: conf.includeInLegend,
      datasetVisible: dataset.getState('visible'),
      label: (0, _lib.getFirstValue)(dataset.config.JSONData.seriesname),
      index: dataset.index,
      mainDS: true
    };
    if (conf.includeinlegend) {
      legendItem = legend.getItem(dataset.config.legendItemId);
      if (!legendItem) {
        dataset.config.legendItemId = legend.createItem(dataset);
        legendItem = legend.getItem(dataset.config.legendItemId);
        dataset.addExtEventListener('click', function () {
          dataset.legendInteractivity(legendItem);
        }, legendItem);
      }
      legendItem.configure(config);
    } else if (dataset.config.legendItemId) {
      legend.disposeItem(dataset.config.legendItemId);
    }
    legendItem.setStateCosmetics('default', {
      symbol: {
        fill: (0, _lib.toRaphaelColor)(fillColor),
        stroke: (0, _lib.toRaphaelColor)(strokeColor)
      },
      background: {
        legendBackgroundColor: (0, _lib.toRaphaelColor)(upperBoxColor),
        alpha: 20
      }
    });
    // check if dataset is initiallyhidden
    if (!dataset.getState('visible')) {
      legendItem.setLegendState('hidden');
    }
    dataset._mapChildren(function (child) {
      child.addToEnv('legendBackgroundColor', upperBoxColor);
      child && child._addLegend(true);
    });
  };

  /**
   * Fuction to be fired on legend click
   * @param  {Object} legendItem which legend is clicked
   */


  BoxAndWhiskerDataset.prototype.legendInteractivity = function legendInteractivity() {
    var dataset = this,
        childDS = dataset.getChildren('dataset'),
        visible = dataset.getState('visible'),
        state,
        i;
    state = visible ? 'hide' : 'show';

    for (i = 0; i < (childDS && childDS.length); i++) {
      childDS[i][state]();
    }
    dataset[state]();
  };

  /**
   * Over-writting drawLabel of column chart
   * @return {Object} the dataset object
   */


  BoxAndWhiskerDataset.prototype.drawLabel = function drawLabel() {
    return this;
  };
  /**
   * Gets the name of the component
   * @return {string} name
   */


  BoxAndWhiskerDataset.prototype.getName = function getName() {
    return 'boxandwhisker2D';
  };

  /**
   * Over-writting childChanged of column chart
   * @return {Object} the dataset object
   */


  BoxAndWhiskerDataset.prototype.childChanged = function childChanged() {
    return this;
  };

  /**
   * Function to show the dataset and raise an event
   */


  BoxAndWhiskerDataset.prototype.show = function show() {
    _ColumnDataset.prototype.show.call(this);
  };

  /**
   * Function to hide the dataset and raise an event
   */


  BoxAndWhiskerDataset.prototype.hide = function hide() {
    _ColumnDataset.prototype.hide.call(this);
  };

  return BoxAndWhiskerDataset;
}(_column2['default']);

exports['default'] = BoxAndWhiskerDataset;

/***/ }),

/***/ 872:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _boxandwhiskerlineAnimation = __webpack_require__(873);

var _boxandwhiskerlineAnimation2 = _interopRequireDefault(_boxandwhiskerlineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var UNDEF = void 0,
    POLYGON = _lib.preDefStr.POLYGON,
    SPOKE = _lib.preDefStr.SPOKE,
    BOLDSTARTTAG = '<b>',
    BOLDENDTAG = '</b>',

/**
 * Helper function to create a RedRaphael group.
 * @param  {Object} attrs  List of attributes that are applied to the created group.
 * @param  {Element} parentContainer         The parent container in which the group will be appended.
 * @param {Object} dataset The concerned dataset
 * @return {Element}                         The group that was created.
 */
createGroup = function createGroup(attrs, parentContainer, dataset) {
  var animationManager = dataset.getFromEnv('animationManager');
  return animationManager.setAnimation({
    el: 'group',
    attr: attrs,
    container: parentContainer,
    component: dataset,
    label: 'group'
  });
};
(0, _dependencyManager.addDep)({
  name: 'boxandwhiskerlineAnimation',
  type: 'animationRule',
  extension: _boxandwhiskerlineAnimation2['default']
});
/**
 * Class for boxAndWhiskerLine dataset
 */

var BoxAndWhiskerLinedataset = function (_Linedataset) {
  _inherits(BoxAndWhiskerLinedataset, _Linedataset);

  function BoxAndWhiskerLinedataset() {
    _classCallCheck(this, BoxAndWhiskerLinedataset);

    return _possibleConstructorReturn(this, _Linedataset.apply(this, arguments));
  }

  /**
   * Gets the name of the component
   * @return {string} name
   */
  BoxAndWhiskerLinedataset.prototype.getName = function getName() {
    return 'boxandwhiskerline';
  };
  /**
   * Create pixel coordinates for the plots
   */


  BoxAndWhiskerLinedataset.prototype.createCoordinates = function createCoordinates() {
    var dataset = this,
        dsComponents = dataset.components,
        dsData = dsComponents.data,

    // chart = dataset.getFromEnv('chart'),
    // isBar = chart.isBar,
    yAxis = dataset.getFromEnv('yAxis'),
        xAxis = dataset.getFromEnv('xAxis'),

    // yBase = yAxis.getAxisBase(),
    // yBasePos = yAxis.getPixel(yBase),
    dataObj,
        config,

    // previousY,
    i,
        Px,
        Py,

    // Pb,
    // xDepth = chart.config.xDepth || 0,
    // yDepth = chart.config.yDepth || 0,
    len = dsData.length,
        components = dataset.components,

    // groupManager = dataset.getLinkedParent(),
    // stackConf = groupManager.getstackConf && groupManager.getstackConf(),
    dataStore = components.data,
        xPosOffset = dataset.getFromEnv('columnXShift'),
        width = dataset.getFromEnv('columnWidth');

    // !isBar && (xDepth = -xDepth);
    // isBar && (yDepth = -yDepth);

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (dataObj === UNDEF) {
        continue;
      }
      // previousY = config._b;
      Px = xAxis.getPixel(config._x);
      Py = yAxis.getPixel(config._y);
      // Pb = (previousY ? yAxis.getPixel(previousY) : yBasePos) + yDepth;

      config._Px = Px + xPosOffset + width / 2;
      config._Py = Py;
      // config._Pby = Pb;
      // config._Pbx = Px;
    }
  };

  /**
   * Function to add legend for LineDs only when the function is called from its parent ds
   * @param {boolean} callFromParentDS if call is from parent ds
   */


  BoxAndWhiskerLinedataset.prototype._addLegend = function _addLegend(callFromParentDS) {
    if (!callFromParentDS) {
      return;
    }
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        conf = dataset.config,
        legend = chart.getChildren('legend')[0],
        legendItem,
        drawAnchors = (0, _lib.pluckNumber)(conf.drawanchors, 1),
        config;
    if (conf.includeinlegend) {
      config = {
        anchorSide: drawAnchors ? conf.anchorsides : 0,
        enabled: conf.includeinlegend,
        label: (0, _lib.getFirstValue)(conf.JSONData.seriesname),
        customLegendIcon: false,
        drawLine: !conf.showline
      };
      legendItem = legend.getItem(dataset.config.legendItemId);
      if (!legendItem) {
        dataset.config.legendItemId = legend.createItem(dataset);
        legendItem = legend.getItem(dataset.config.legendItemId);
        dataset.addExtEventListener('click', function () {
          dataset.legendInteractivity(legendItem);
        }, legendItem);
      }
      legendItem.configure(config);
      legendItem.setStateCosmetics('default', {
        symbol: {
          fill: (0, _lib.toRaphaelColor)({
            color: conf.anchorbgcolor,
            alpha: conf.anchorbgalpha
          }),
          stroke: (0, _lib.toRaphaelColor)({
            color: conf.anchorbordercolor,
            alpha: '100'
          })
        },
        background: {
          legendBackgroundColor: (0, _lib.toRaphaelColor)(dataset.getFromEnv('legendBackgroundColor')),
          alpha: 20
        }
      });
    } else if (dataset.config.legendItemId) {
      legend.disposeItem(dataset.config.legendItemId);
    }
  };

  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * @param  {Object} datasetJSON JSON for dataset configurations
    */


  BoxAndWhiskerLinedataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    _Linedataset.prototype.configureAttributes.call(this, datasetJSON);
    var dataset = this,
        JSONData = dataset.config.JSONData,
        conf = dataset.config;
    // chartAttr = dataset.getFromEnv('chart-attrib');

    conf.skipCommonElements = JSONData.showline;
    conf.dip = JSONData.dip;
  };

  /**
   * function to create group for dataset
   */


  BoxAndWhiskerLinedataset.prototype.createContainer = function createContainer() {
    var dataset = this,
        dsType = dataset.getType(),
        groupName = dataset.groupName,
        parent = dataset.getLinkedParent().getLinkedParent(),
        group = groupName || dataset.dsGroup || dsType,
        parentContainer,
        parentShadowContainer;

    !parent.getChildContainer(group + 'VcanvasGroup') && (group = 'default');
    parentContainer = parent.getChildContainer('manager-defaultVcanvasGroup-lines');
    parentShadowContainer = parent.getChildContainer(group + 'ShadowVcanvasGroup');

    !dataset.getContainer('shadowGroup') && dataset.addContainer('shadowGroup', createGroup({ name: 'shadow-group' }, parentShadowContainer, dataset));

    !dataset.getContainer('commonElemsGroup') && dataset.addContainer('commonElemsGroup', createGroup({ name: 'common-elems-group' }, parentContainer, dataset));

    !dataset.getContainer('plotGroup') && dataset.addContainer('plotGroup', createGroup({ name: 'common-elems-group' }, parentContainer, dataset));

    !dataset.getContainer('labelGroup') && dataset.addContainer('labelGroup', createGroup({ name: 'label-group',
      'class': 'fusioncharts-datalabels',
      opacity: 1 }, parent.getChildContainer('vcanvasLabelGroup'), dataset));
  };

  /**
   * Configure data level
   * @param {Object} newdataset new dataset added
   * @param {Object} newIndex new added dataset index
   */


  BoxAndWhiskerLinedataset.prototype._setConfigure = function _setConfigure(newdataset, newIndex) {
    _Linedataset.prototype._setConfigure.call(this, newdataset, newIndex);
    var dataset = this,
        chartConfig = dataset.getFromEnv('chartConfig'),
        JSONData = dataset.config.JSONData,
        setDataArr = newdataset || JSONData.data || [],
        setData,
        dataObj,
        len = setDataArr.length,
        dataStore = dataset.components.data,
        config,
        i,
        tempIndex,
        outlierIconShape;

    for (i = 0; i < len; i++) {
      if (newdataset) {
        setData = newdataset && newdataset.data[i] || {};

        if (newIndex !== UNDEF) {
          tempIndex = newIndex + i;
          dataObj = dataStore[tempIndex];
        } else {
          tempIndex = dataStore.length - len + i;
          dataObj = dataStore[tempIndex];
        }
      } else {
        dataObj = dataStore[i];
        setData = setDataArr && setDataArr[i] || {};
      }

      config = dataObj && dataObj.config;
      outlierIconShape = (0, _lib.pluck)(setData.dip, JSONData.dip);
      config.dip = outlierIconShape === POLYGON ? 0 : outlierIconShape === SPOKE ? 1 : 0;
      config.toolText = BOLDSTARTTAG + JSONData.seriesname + chartConfig.tooltipsepchar + BOLDENDTAG + config.displayValue;
    }
  };

  return BoxAndWhiskerLinedataset;
}(_line2['default']);

exports['default'] = BoxAndWhiskerLinedataset;

/***/ }),

/***/ 873:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.boxandwhiskerline': function initialDatasetBoxandwhiskerline() {
    return {
      'line.appearing': [{
        initialAttr: {
          opacity: 0
        },
        finalAttr: {
          opacity: 1
        },
        slot: 'plot',
        startEnd: {
          start: 0.5,
          end: 1
        }
      }],
      'anchor.appearing': [{
        initialAttr: {
          opacity: 0
        },
        finalAttr: {
          opacity: 1
        },
        slot: 'plot',
        startEnd: {
          start: 0.5,
          end: 1
        }
      }]
    };
  }
};

/***/ }),

/***/ 874:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.boxandwhisker2D': function initialDatasetBoxandwhisker2D() {
    return {
      'upperBox.appearing': function upperBoxAppearing(inputJSON) {
        return [{
          initialAttr: {
            x: inputJSON.attr.x,
            y: inputJSON.attr.y + inputJSON.attr.height,
            height: 0,
            width: inputJSON.attr.width
          },
          slot: 'plot',
          startEnd: {
            start: 0,
            end: 0.5
          }
        }];
      },
      'lowerBox.appearing': function lowerBoxAppearing(inputJSON) {
        return [{
          initialAttr: {
            x: inputJSON.attr.x,
            y: inputJSON.attr.y,
            height: 0,
            width: inputJSON.attr.width
          },
          slot: 'plot',
          startEnd: {
            start: 0,
            end: 0.5
          }
        }];
      },
      'path.appearing': [{
        initialAttr: {
          opacity: 0
        },
        finalAttr: {
          opacity: 1
        },
        slot: 'plot',
        startEnd: {
          start: 0.5,
          end: 1
        }
      }],
      'midline.appearing': [{
        initialAttr: {
          opacity: 0
        },
        finalAttr: {
          opacity: 1
        },
        slot: 'plot',
        startEnd: {
          start: 0,
          end: 0.2
        }
      }],
      'group.appearing': function groupAppearing(inputJSON) {
        if (inputJSON.attr.name === 'label-group') {
          return [{
            initialAttr: {
              opacity: 0
            },
            finalAttr: {
              opacity: 1
            },
            slot: 'final'
          }];
        } else {
          return [{
            initialAttr: {
              opacity: 1
            },
            finalAttr: {
              opacity: 1
            },
            slot: 'final'
          }];
        }
      },
      '*': null
    };
  }
};

/***/ }),

/***/ 875:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _column = __webpack_require__(15);

var _column2 = _interopRequireDefault(_column);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var key = 'manager-defaultVcanvasGroup-lines',
    vcanvasGroup = 'defaultVcanvasGroup';
/**
 * class for marimekko group manager
 */

var BoxAndWhiskerMultiSeriesGroup = function (_ColumnMultiseriesGro) {
  _inherits(BoxAndWhiskerMultiSeriesGroup, _ColumnMultiseriesGro);

  function BoxAndWhiskerMultiSeriesGroup() {
    _classCallCheck(this, BoxAndWhiskerMultiSeriesGroup);

    return _possibleConstructorReturn(this, _ColumnMultiseriesGro.apply(this, arguments));
  }

  /**
  * Create child containers
  */
  BoxAndWhiskerMultiSeriesGroup.prototype.createContainer = function createContainer() {
    _ColumnMultiseriesGro.prototype.createContainer.call(this);
    var manager = this,
        animationManager = manager.getFromEnv('animationManager'),
        parent = manager.getLinkedParent(),
        pContainer = parent.getChildContainer(vcanvasGroup);

    !manager.getChildContainer(key) && manager.addChildContainer(key,
    // create group
    animationManager.setAnimation({
      el: 'group',
      component: manager,
      attr: { name: key },
      container: pContainer
    }));
  };

  return BoxAndWhiskerMultiSeriesGroup;
}(_column2['default']);

exports['default'] = BoxAndWhiskerMultiSeriesGroup;

/***/ }),

/***/ 876:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var jsonData = chart.getFromEnv('dataSource'),
      datasetsJSON = jsonData.dataset,
      children = chart.getChildren(),
      canvas = children.canvas[0],
      vCanvas = void 0,
      datasetParent = vCanvas = canvas.getChildren('vCanvas')[0],
      DsGroupClass = void 0,
      DSClass = void 0,
      dsType = chart.config.defaultDatasetType || '',
      groupManager = void 0;

  if (!datasetsJSON) {
    chart.setChartMessage();
  }

  DsGroupClass = chart.getDSGroupdef();
  (0, _lib.componentFactory)(vCanvas, DsGroupClass, 'datasetGroup_' + dsType);
  groupManager = vCanvas.getChildren('datasetGroup_' + dsType);
  groupManager && (datasetParent = groupManager[0]);
  DSClass = chart.getDSdef();

  (0, _lib.componentFactory)(chart, _boxAndWhiskerStatisticalCalc2['default'], 'BoxAndWhiskerStatisticalCalc');
  vCanvas.getChildren('datasetGroup_' + dsType)[0].addToEnv('BoxAndWhiskerStatisticalCalc', chart.getChildren('BoxAndWhiskerStatisticalCalc')[0]);

  // Adding the JSON data of line dataset to the parent of boxandwhisker ds
  datasetParent.addToEnv('lineJSON', chart._getLineJSONdata());
  (0, _lib.datasetFactory)(datasetParent, DSClass, 'dataset', datasetsJSON.length, datasetsJSON);
};

var _lib = __webpack_require__(5);

var _boxAndWhiskerStatisticalCalc = __webpack_require__(877);

var _boxAndWhiskerStatisticalCalc2 = _interopRequireDefault(_boxAndWhiskerStatisticalCalc);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 877:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(7);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * class to make the mathematical calculations for boxAndWhisker
 */
var BoxAndWhiskerStatisticalCalc = function (_ComponentInterface) {
  _inherits(BoxAndWhiskerStatisticalCalc, _ComponentInterface);

  function BoxAndWhiskerStatisticalCalc() {
    _classCallCheck(this, BoxAndWhiskerStatisticalCalc);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  /**
   * Function to set the data for the bw calculator
   * @param {string} value The comma separated string value
   */
  BoxAndWhiskerStatisticalCalc.prototype.setArray = function setArray(value) {
    var calculater = this,
        nf = calculater.getFromEnv('number-formatter'),
        dataSeparator = _lib.COMMASTRING,
        sum = 0,
        len,
        dataArr;
    !value && (value = _lib.BLANK);
    // First we make an arry form the comma-separated value.
    // and then we sort and store the data array in dataArr
    //  for further calculation.
    dataArr = value.replace(/\s/g, _lib.BLANK).split(dataSeparator);
    // Parse the values using NumberFormatter getCleanValue
    len = this.dataLength = dataArr && dataArr.length;

    while (len--) {
      sum += dataArr[len] = nf.getCleanValue(dataArr[len]);
    }

    // Now sort the data in ascending order
    dataArr && dataArr.sort(function (a, b) {
      return a - b;
    });

    this.values = dataArr;
    // Calculate and store the Mean
    this.mean = sum / this.dataLength;
    this.getFrequencies();
  };

  /**
   * Function to get the values of quartiles
   * @return {Object} The value of 1st and 3rd quartile
   */


  BoxAndWhiskerStatisticalCalc.prototype.getQuartiles = function getQuartiles() {
    var values = this.values,
        len = this.dataLength,
        isOdd = len % 2,
        q1Pos,
        q1LowPos,
        q3Pos,
        q3LowPos,
        q1Val,
        q3Val,
        method = _lib.BLANKSTRING;

    switch (method) {
      case 'tukey':
        if (isOdd) {
          // Q1 = n + 3 / 4 And Q3 = 3N + 1 / 4
          q1Pos = (len + 3) / 4;
          q3Pos = (len * 3 + 1) / 4;
        } else {
          // Q1 = n + 2 / 4 And Q3 = 3N + 2 / 4
          q1Pos = (len + 2) / 4;
          q3Pos = (len * 3 + 2) / 4;
        }
        break;
      case 'mooremccabe':
        if (isOdd) {
          // Q1 = n + 1 / 4 And Q3 = 3N + 3 / 4
          q1Pos = (len + 1) / 4;
          q3Pos = q1Pos * 3;
        } else {
          // Q1 = n + 2 / 4 And Q3 = 3N + 2 / 4
          q1Pos = (len + 2) / 4;
          q3Pos = (len * 3 + 2) / 4;
        }
        break;
      case 'freundperles':
        // Q1 = n + 3 / 4 And Q3 = 3N + 1 / 4
        q1Pos = (len + 3) / 4;
        q3Pos = (len * 3 + 1) / 4;
        break;
      case 'mendenhallsincich':
        // Q1 = [n + 1 / 4] And [Q3 = 3N + 3 / 4]
        q1Pos = Math.round((len + 1) / 4);
        q3Pos = Math.round(q1Pos * 3);
        break;
      default:
        // Q1 = n + 1 / 4 And Q3 = 3N + 3 / 4
        q1Pos = (len + 1) / 4;
        q3Pos = q1Pos * 3;
        break;
    }

    q1Pos -= 1;
    q3Pos -= 1;
    q1LowPos = Math.floor(q1Pos);
    q3LowPos = Math.floor(q3Pos);

    q1Val = q1Pos - q1LowPos ? values[q1LowPos] + (values[Math.ceil(q1Pos)] - values[q1LowPos]) * (q1Pos - q1LowPos) : values[q1Pos];
    q3Val = q3Pos - q3LowPos ? values[q3LowPos] + (values[Math.ceil(q3Pos)] - values[q3LowPos]) * (q3Pos - q3LowPos) : values[q3Pos];

    return this.quartiles = {
      q1: q1Val,
      q3: q3Val
    };
  };

  /**
   * Return min and max values from the data array.
   * @return {Object} Contains the minimum and maximum of the entered data
   */


  BoxAndWhiskerStatisticalCalc.prototype.getMinMax = function getMinMax() {
    var values = this.values;
    return {
      min: values[0],
      max: values[this.dataLength - 1]
    };
  };

  /**
   * calculate and returns the mean value
   * @return {number} mean value
   */


  BoxAndWhiskerStatisticalCalc.prototype.getMean = function getMean() {
    return this.mean;
  };

  /**
   * calculate the MeanDeviation
   * @return {number} meanDevaition
   */


  BoxAndWhiskerStatisticalCalc.prototype.getMD = function getMD() {
    var mean = this.mean,
        freq = this.frequencies,
        freqLen = freq.length,
        freqObj,
        sum = 0;

    while (freqLen--) {
      freqObj = freq[freqLen];
      sum += freqObj.frequency * Math.abs(freqObj.value - mean);
    }
    return sum / this.dataLength;
  };

  /**
   * calculate the standard deviation
   * @return {number} standard deviation
   */


  BoxAndWhiskerStatisticalCalc.prototype.getSD = function getSD() {
    var mean = this.mean,
        values = this.values,
        i = this.dataLength,
        len = i,
        sum = 0;

    while (i--) {
      sum += Math.pow(values[i] - mean, 2);
    }

    return Math.sqrt(sum) / len;
  };

  /**
   * calculate the quartile deviation
   * @return {number} quartile deviation
   */


  BoxAndWhiskerStatisticalCalc.prototype.getQD = function getQD() {
    return (this.quartiles.q3 - this.quartiles.q1) * 0.5;
  };

  /**
   * calculate the frequencies and sum of the values
   */


  BoxAndWhiskerStatisticalCalc.prototype.getFrequencies = function getFrequencies() {
    var frequenciesArr = [],
        len = this.dataLength,
        values = this.values,
        sum = 0,
        value,
        freqObj,
        index;

    for (index = 0; index < len; index += 1) {
      sum += value = values[index];
      if ((0, _lib.defined)(frequenciesArr[index])) {
        frequenciesArr[index].frequency += 1;
      } else {
        freqObj = {};
        freqObj.value = value;
        freqObj.frequency = 1;
        frequenciesArr[index] = freqObj;
      }
    }
    this.sum = sum;
    this.frequencies = frequenciesArr;
  };

  /**
   * Function to get the median value
   * @return {number} median
   */


  BoxAndWhiskerStatisticalCalc.prototype.getMedian = function getMedian() {
    var len = this.dataLength,
        midVal = len * 0.5,
        values = this.values;

    return len % 2 === 0 ? (values[midVal] + values[midVal - 1]) / 2 : values[Math.floor(midVal)];
  };

  return BoxAndWhiskerStatisticalCalc;
}(_componentInterface2['default']);

exports['default'] = BoxAndWhiskerStatisticalCalc;

/***/ }),

/***/ 878:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _fusioncharts = __webpack_require__(16);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _vcanvas = __webpack_require__(311);

var _vcanvas2 = _interopRequireDefault(_vcanvas);

var _candlestickDataset = __webpack_require__(879);

var _candlestickDataset2 = _interopRequireDefault(_candlestickDataset);

var _candlestickAxis = __webpack_require__(884);

var _candlestickAxis2 = _interopRequireDefault(_candlestickAxis);

var _candlestick = __webpack_require__(146);

var _candlestick2 = _interopRequireDefault(_candlestick);

var _candlestickbar = __webpack_require__(885);

var _candlestickbar2 = _interopRequireDefault(_candlestickbar);

var _candlestickline = __webpack_require__(887);

var _candlestickline2 = _interopRequireDefault(_candlestickline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var MOUSEOUT = 'mouseout',
    BLANKSTRING = '';
var convertColor = _lib.graphics.convertColor,
    altHGridColorStr = _lib.preDefStr.altHGridColorStr,
    altHGridAlphaStr = _lib.preDefStr.altHGridAlphaStr,
    math = Math,
    mathMax = math.max,
    mathRound = math.round,
    POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
    divLineAlpha3DStr = _lib.preDefStr.divLineAlpha3DStr,
    defaultFontStr = _lib.preDefStr.defaultFontStr,
    divLineAlphaStr = _lib.preDefStr.divLineAlphaStr,
    altVGridColorStr = _lib.preDefStr.altVGridColorStr,
    altVGridAlphaStr = _lib.preDefStr.altVGridAlphaStr,
    colorStrings = _lib.preDefStr.colors,
    COLOR_000000 = colorStrings.c000000,
    chartPaletteStr = {
  chart2D: {
    bgColor: 'bgColor',
    bgAlpha: 'bgAlpha',
    bgAngle: 'bgAngle',
    bgRatio: 'bgRatio',
    canvasBgColor: 'canvasBgColor',
    canvasBaseColor: 'canvasBaseColor',
    divLineColor: 'divLineColor',
    legendBgColor: 'legendBgColor',
    legendBorderColor: 'legendBorderColor',
    toolTipbgColor: 'toolTipbgColor',
    toolTipBorderColor: 'toolTipBorderColor',
    baseFontColor: 'baseFontColor',
    anchorBgColor: 'anchorBgColor'
  },
  chart3D: {
    bgColor: 'bgColor3D',
    bgAlpha: 'bgAlpha3D',
    bgAngle: 'bgAngle3D',
    bgRatio: 'bgRatio3D',
    canvasBgColor: 'canvasBgColor3D',
    canvasBaseColor: 'canvasBaseColor3D',
    divLineColor: 'divLineColor3D',
    divLineAlpha: divLineAlpha3DStr,
    legendBgColor: 'legendBgColor3D',
    legendBorderColor: 'legendBorderColor3D',
    toolTipbgColor: 'toolTipbgColor3D',
    toolTipBorderColor: 'toolTipBorderColor3D',
    baseFontColor: 'baseFontColor3D',
    anchorBgColor: 'anchorBgColor3D'
  }
};
/**
 * class definition for candlestick chart API
 */

var CandleStick = function (_MSCartesian) {
  _inherits(CandleStick, _MSCartesian);

  /**
   * constructor function of this class
   */
  function CandleStick() {
    _classCallCheck(this, CandleStick);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.isDual = true;
    _this.paletteIndex = 3;
    _this.canvasborderthickness = 1;
    _this.hasInteractiveLegend = false;
    _this.numOfCanvas = 2;
    _this.registerFactory('vCanvas', _vcanvas2['default'], ['axis']);
    _this.registerFactory('axis', _candlestickAxis2['default'], ['canvas']);
    _this.registerFactory('dataset', _candlestickDataset2['default'], ['vCanvas']);
    return _this;
  }
  /**
   * Returns the name of the component
   *
   * @return {string} The name of the component
   */


  CandleStick.prototype.getName = function getName() {
    return 'candlestick';
  };
  /**
   * Returns the name of the component
   *
   * @return {string} The name of the component
   */


  CandleStick.getName = function getName() {
    return 'candlestick';
  };
  /**
   * This method return the dataset definations for this charts
   * @param {string} name   name of the dataset that is required
   * @return {Object}       Required dataset class definition
   */


  CandleStick.prototype.getDSdef = function getDSdef(name) {
    return name === 'bar' ? _candlestickbar2['default'] : name === 'line' ? _candlestickline2['default'] : _candlestick2['default'];
  };
  /**
   * parse defualt configuration of the chart
   */


  CandleStick.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.hasLegend = true;
    config.defaultDatasetType = 'candlestick';
    config.drawanchors = 0;
    config.enablemousetracking = true;
    config.iscandlestick = true;
  };
  /**
   * function to create component and configure and also configure the chart
   * It creates components which are depend on data and configure them and also configure chart
   * It calls helper function namely, configure
   * @param  {Object} dataObj contains json data of the chart
   */


  CandleStick.prototype.configureAttributes = function configureAttributes(dataObj) {
    _MSCartesian.prototype.configureAttributes.call(this, dataObj);
  };
  /**
   * Parse the chart attributes and store in chart's config
   * @param {Object} dataObj User input json
   */


  CandleStick.prototype.parseChartAttr = function parseChartAttr(dataObj) {
    _MSCartesian.prototype.parseChartAttr.call(this, dataObj);
    var iapi = this,
        volumeHeightPercent = void 0,
        config = iapi.config,
        chartAttrs = iapi.getFromEnv('chart-attrib'),
        colorM = iapi.getFromEnv('color-manager');
    config.showVolumeChart = (0, _lib.pluckNumber)(chartAttrs.showvolumechart, 1);
    config.rollOverBandColor = convertColor((0, _lib.pluck)(chartAttrs.rolloverbandcolor, colorM.getColor(altHGridColorStr)), (0, _lib.pluck)(chartAttrs.rolloverbandalpha, colorM.getColor(altHGridAlphaStr)));

    config.crosslinecolor = (0, _lib.pluck)(chartAttrs.crosslinecolor, chartAttrs.rolloverbandcolor, colorM.getColor(altHGridColorStr));
    config.drawcrosslineontop = 0;
    config.crosslinealpha = (0, _lib.pluckNumber)(chartAttrs.crosslinealpha, chartAttrs.rolloverbandalpha, colorM.getColor(altHGridAlphaStr));
    config.drawcrossline = 1;
    config.skipClipping = true;
    chartAttrs = iapi.getFromEnv('chart-attrib');
    config.vplotbordercolor = (0, _lib.getFirstValue)(chartAttrs.vplotbordercolor, BLANKSTRING);
    config.vplotborderalpha = (0, _lib.getFirstValue)(chartAttrs.vplotborderalpha, BLANKSTRING);
    config.vplotborderthickness = (0, _lib.pluckNumber)(chartAttrs.vplotborderthickness, 1);
    config.showplotborder = (0, _lib.pluckNumber)(chartAttrs.showvplotborder, 1);
    volumeHeightPercent = (0, _lib.pluckNumber)(chartAttrs.volumeheightpercent, 40);
    config.volumeHeightPercent = volumeHeightPercent < 20 ? 20 : volumeHeightPercent > 80 ? 80 : volumeHeightPercent;
    config.canvasBorderWidth = (0, _lib.pluckNumber)(chartAttrs.canvasborderthickness, 1);
  };

  /**
   * calculate and allote space for various components
   * every components are get notified with maximum space and then components return
   * the available space.
   */


  CandleStick.prototype._spaceManager = function _spaceManager() {
    var spaceForActionBar,
        actionBarSpace,
        availableWidth,
        availableHeight,
        iapi = this,
        config = iapi.config,
        components = iapi.getChildren(),
        legendPosition = config.legendPosition,
        xAxis = components.xAxis && components.xAxis[0],
        yAxis = components.yAxis && components.yAxis[0],
        yAxis2 = components.yAxis && components.yAxis[1],
        hasLegend = config.hasLegend,
        legend = iapi.getFromEnv('legend'),
        canvasHeight,
        xAxisDimensions,
        showVolumeChart = iapi.config.showVolumeChart,
        volumeHeightPercent = showVolumeChart ? config.volumeHeightPercent : 0,
        canvas = components.canvas[0],
        canvasConfig = canvas.config,
        volumeCanvas,
        volumeCanvasConfig,
        volumeCanvasY,
        padding = 6,
        canvasY,
        yAxisDim,
        vYAxisDim,
        width = config.width,
        height = config.height,
        actualYDim = {},
        allottedSpace,
        chartBorderWidth = config.chartBorderWidth,
        canvasBorderWidth = canvasConfig.canvasBorderWidth,
        minCanvasHeight = config.minCanvasHeight,
        minCanvasWidth = config.minCanvasWidth,
        canvasMarginLeft = config.canvasMarginLeft,
        canvasMarginRight = config.canvasMarginRight,
        canvasMarginTop = config.canvasMarginTop,
        canvasMarginBottom = config.canvasMarginBottom,
        diff,
        currentCanvasHeight,
        currentCanvasWidth,
        heightAdjust,
        origCanvasTopMargin = config.origCanvasTopMargin,
        origCanvasBottomMargin = config.origCanvasBottomMargin,
        origCanvasLeftMargin = config.origCanvasLeftMargin,
        origCanvasRightMargin = config.origCanvasRightMargin,
        left,
        right,
        top,
        bottom,
        widthAdjust,
        sum;
    // Manage space

    iapi._allocateSpace({
      top: chartBorderWidth,
      bottom: chartBorderWidth,
      left: chartBorderWidth,
      right: chartBorderWidth
    });

    // iapi._allocateSpace ( {
    //     left : config.canvasMarginLeft,
    //     right : config.canvasMarginRight
    // });

    spaceForActionBar = config.availableHeight * 0.225;
    actionBarSpace = iapi._manageActionBarSpace && iapi._manageActionBarSpace(spaceForActionBar) || {};
    iapi._allocateSpace(actionBarSpace);

    if (legendPosition === _lib.POSITION_RIGHT) {
      allottedSpace = config.canvasWidth * 0.225;
    } else {
      allottedSpace = config.canvasHeight * 0.3;
    }
    hasLegend !== false && xAxis && config.showLegend && iapi._allocateSpace(legend._manageLegendPosition(allottedSpace));
    availableWidth = config.canvasWidth * 0.7;
    yAxisDim = yAxis.placeAxis(availableWidth);
    vYAxisDim = showVolumeChart ? yAxis2.placeAxis(availableWidth) : {};
    actualYDim.left = mathMax(yAxisDim.left, vYAxisDim.left || 0);
    actualYDim.right = mathMax(yAxisDim.right, vYAxisDim.right || 0);
    iapi._allocateSpace(actualYDim);

    // Check for minimun canvas width for applying canvas left and right margin.
    if (minCanvasWidth > width - canvasMarginLeft - canvasMarginRight) {
      widthAdjust = true;
      diff = config.canvasWidth - minCanvasWidth;
      sum = canvasMarginLeft + canvasMarginRight;
      canvasMarginLeft = config.canvasMarginLeft = diff * canvasMarginLeft / sum;
      canvasMarginRight = config.canvasMarginRight = diff * canvasMarginRight / sum;
    }

    // Calculating the left and right canvas margin.
    left = canvasMarginLeft > config.canvasLeft ? canvasMarginLeft - config.canvasLeft : 0;
    right = canvasMarginRight > width - config.canvasRight ? canvasMarginRight + config.canvasRight - width : 0;

    iapi._allocateSpace({
      left: left,
      right: right
    });

    // Forcing canvas width to its minimum
    if (widthAdjust) {
      sum = origCanvasLeftMargin + origCanvasRightMargin;
      currentCanvasWidth = config.canvasWidth;
      if (currentCanvasWidth > minCanvasWidth) {
        diff = currentCanvasWidth - minCanvasWidth;
        left = diff * origCanvasLeftMargin / sum;
        right = diff * origCanvasRightMargin / sum;
      }
      iapi._allocateSpace({
        left: left,
        right: right
      });
    }

    availableHeight = config.canvasHeight * 0.225;

    availableHeight = legendPosition === POSITION_BOTTOM ? config.canvasHeight * 0.6 : config.canvasWidth * 0.6;
    // a space manager that manages the space for the tools as well as the captions.
    iapi._manageChartMenuBar(availableHeight);

    iapi._allocateSpace({
      top: config.canvasMarginTop,
      bottom: config.canvasMarginBottom
    });

    availableHeight = config.canvasHeight * 0.3;
    xAxisDimensions = xAxis.placeAxis(availableHeight);
    xAxis && iapi._allocateSpace(xAxisDimensions);
    xAxisDimensions.bottom += padding;
    canvasConfig.intermediarySpace = xAxisDimensions.bottom;

    // enforcing the 10 pixel deduction in canvas height to set a padding between canvas and legend
    if (showVolumeChart) {
      iapi._allocateSpace({ bottom: 10 });
    }
    iapi._allocateSpace({
      top: canvasBorderWidth,
      bottom: canvasBorderWidth * 2,
      left: canvasBorderWidth,
      right: canvasBorderWidth
    });

    // Check for minimum canvas height for applying top and bottom margin.
    if (minCanvasHeight > height - canvasMarginTop - canvasMarginBottom) {
      heightAdjust = true;
      diff = config.canvasHeight - minCanvasHeight;
      sum = canvasMarginTop + canvasMarginBottom;
      canvasMarginTop = config.canvasMarginTop = diff * canvasMarginTop / sum;
      canvasMarginBottom = config.canvasMarginBottom = diff * canvasMarginBottom / sum;
    }

    // Allocate space for canvas margin only if the margin is less than the margin entered by the user.
    top = canvasMarginTop > config.canvasTop ? canvasMarginTop - config.canvasTop : 0;
    bottom = canvasMarginBottom > height - config.canvasBottom ? canvasMarginBottom + config.canvasBottom - height : 0;

    iapi._allocateSpace({
      top: top,
      bottom: bottom
    });

    // Forcing canvas height to its minimum
    if (heightAdjust) {
      sum = origCanvasTopMargin + origCanvasBottomMargin;
      currentCanvasHeight = config.canvasHeight;
      if (currentCanvasHeight > minCanvasHeight) {
        diff = currentCanvasHeight - minCanvasHeight;
        top = diff * origCanvasTopMargin / sum;
        bottom = diff * origCanvasBottomMargin / sum;
      }
      iapi._allocateSpace({
        top: top,
        bottom: bottom
      });
    }

    canvasHeight = config.canvasHeight;
    canvasConfig.canvasHeight = mathRound((100 - volumeHeightPercent) / 100 * canvasHeight);

    canvasConfig.canvasTop = config.canvasTop;
    canvasConfig.canvasLeft = config.canvasLeft;
    canvasConfig.canvasBottom = canvasConfig.canvasTop + canvasConfig.canvasHeight;
    canvasConfig.canvasWidth = config.canvasWidth;
    canvasConfig.canvasRight = config.canvasRight;
    canvasY = config.canvasTop + canvasConfig.canvasHeight + canvasBorderWidth;
    canvasConfig.canvasY = canvasY;
    canvas.setDimension({
      top: canvasConfig.canvasTop,
      left: canvasConfig.canvasLeft,
      width: canvasConfig.canvasWidth,
      height: canvasConfig.canvasHeight
    });
    if (showVolumeChart) {
      volumeCanvas = components.canvas[1];
      volumeCanvasConfig = volumeCanvas.config;
      volumeCanvasConfig.canvasHeight = volumeHeightPercent / 100 * canvasHeight;
      volumeCanvasConfig.canvasTop = canvasConfig.canvasBottom + xAxisDimensions.bottom + canvasBorderWidth * 2;
      volumeCanvasConfig.canvasLeft = config.canvasLeft;
      volumeCanvasConfig.canvasBottom = volumeCanvasConfig.canvasTop + volumeCanvasConfig.canvasHeight + canvasBorderWidth * 2;
      volumeCanvasConfig.canvasRight = config.canvasRight;
      volumeCanvasConfig.canvasWidth = config.canvasWidth;
      volumeCanvasY = config.canvasTop + canvasConfig.canvasHeight + xAxisDimensions.bottom + canvasBorderWidth * 2;
      volumeCanvasConfig.canvasY = volumeCanvasY;
      volumeCanvas.setDimension({
        top: volumeCanvasConfig.canvasTop,
        left: volumeCanvasConfig.canvasLeft,
        width: volumeCanvasConfig.canvasWidth,
        height: volumeCanvasConfig.canvasHeight
      });
    }
  };
  /**
   * function to calculate post space management calculations
   * calculations like axis dimenetion set, allocate space for xaxis labels,
   * canvas padding etc.
   */


  CandleStick.prototype._postSpaceManagement = function _postSpaceManagement() {
    _MSCartesian.prototype._postSpaceManagement.call(this);
  };
  /**
    * Sets dimension of Axis components
    */


  CandleStick.prototype.setAxisDimention = function setAxisDimention() {
    var iapi = this,
        components = iapi.getChildren(),
        showVolumeChart = iapi.config.showVolumeChart,
        xAxis = components.xAxis && components.xAxis[0],
        yAxis = components.yAxis && components.yAxis[0],
        vyAxis = components.yAxis && components.yAxis[1],
        canvasArr = components.canvas,
        canvasConfig = canvasArr[0].config,
        volumeCanvasConfig = void 0,
        canvasBorderWidth = canvasConfig.canvasBorderWidth;
    xAxis && xAxis.setAxisDimention({
      x: canvasConfig.canvasLeft,
      y: canvasConfig.canvasY,
      opposite: canvasConfig.canvasTop - canvasBorderWidth,
      axisLength: canvasConfig.canvasWidth
    });
    yAxis && yAxis.setAxisDimention({
      x: canvasConfig.canvasLeft - canvasBorderWidth,
      y: canvasConfig.canvasTop,
      opposite: canvasConfig.canvasRight + canvasBorderWidth,
      axisLength: canvasConfig.canvasHeight
    });
    xAxis.setCanvas(canvasConfig);
    yAxis.setCanvas(canvasConfig);
    if (showVolumeChart) {
      volumeCanvasConfig = canvasArr[1].config;
      vyAxis && vyAxis.setAxisDimention({
        x: canvasConfig.canvasLeft - canvasBorderWidth,
        y: volumeCanvasConfig.canvasTop,
        opposite: volumeCanvasConfig.canvasRight + canvasBorderWidth,
        axisLength: volumeCanvasConfig.canvasHeight
      });
      vyAxis && vyAxis.setCanvas(volumeCanvasConfig);
    }
  };
  /**
   * function to parse JSON data for configurations of axis
   * @return { Object } contains axis configuration
   */


  CandleStick.prototype._feedAxesRawData = function _feedAxesRawData() {
    var iapi = this,
        colorM = iapi.getFromEnv('color-manager'),
        dataObj = iapi.getFromEnv('dataSource'),
        chartAttrs = iapi.getFromEnv('chart-attrib'),
        xAxisConf,
        yAxisConf,
        vYAxisConf,
        yAxisConfigure = [],
        xAxisConfigure = [],
        is3D = iapi.config.is3D,
        palleteString = is3D ? chartPaletteStr.chart3D : chartPaletteStr.chart2D;

    xAxisConf = {
      isVertical: false,
      isReverse: false,
      isOpposit: false,
      drawTrendLabels: true,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, defaultFontStr),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#?([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.xaxisnamepadding,
      axisValuePadding: chartAttrs.labelpadding,
      axisNameFont: chartAttrs.xaxisnamefont,
      axisNameFontSize: chartAttrs.xaxisnamefontsize,
      axisNameFontColor: chartAttrs.xaxisnamefontcolor,
      axisNameFontBold: chartAttrs.xaxisnamefontbold,
      axisNameFontItalic: chartAttrs.xaxisnamefontitalic,
      axisNameBgColor: chartAttrs.xaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.xaxisnamebordercolor,
      axisNameAlpha: chartAttrs.xaxisnamealpha,
      axisNameFontAlpha: chartAttrs.xaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.xaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.xaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.xaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.xaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.xaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.xaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.xaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.xaxisnameborderdashgap,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      divLineColor: (0, _lib.pluck)(chartAttrs.vdivlinecolor, chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.vdivlinealpha, chartAttrs.divlinealpha, is3D ? colorM.getColor(divLineAlpha3DStr) : colorM.getColor(divLineAlphaStr)),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.vdivlinethickness, chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.vdivlinedashed, chartAttrs.vdivlineisdashed, chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashlen, chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashgap, chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatevgridcolor, 0),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatevgridcolor, colorM.getColor(altVGridColorStr)),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatevgridalpha, colorM.getColor(altVGridAlphaStr)),
      numDivLines: chartAttrs.numvdivlines,
      labelFont: chartAttrs.labelfont,
      labelFontSize: chartAttrs.labelfontsize,
      labelFontColor: chartAttrs.labelfontcolor,
      labelFontAlpha: chartAttrs.labelalpha,
      labelFontBold: chartAttrs.labelfontbold,
      labelFontItalic: chartAttrs.labelfontitalic,
      axisName: chartAttrs.xaxisname,
      axisMinValue: chartAttrs.xaxisminvalue,
      axisMaxValue: chartAttrs.xaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptivexmin,
      adjustDiv: chartAttrs.adjustvdiv,
      labelDisplay: chartAttrs.labeldisplay,
      showLabels: chartAttrs.showlabels,
      rotateLabels: chartAttrs.rotatelabels,
      slantLabel: (0, _lib.pluckNumber)(chartAttrs.slantlabels, chartAttrs.slantlabel),
      labelStep: (0, _lib.pluckNumber)(chartAttrs.labelstep, chartAttrs.xaxisvaluesstep),
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showxaxisvalues, chartAttrs.showxaxisvalue),
      showLimits: chartAttrs.showvlimits,
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showvdivlinevalues, chartAttrs.showvdivlinevalues),
      showZeroPlane: chartAttrs.showvzeroplane,
      zeroPlaneColor: chartAttrs.vzeroplanecolor,
      zeroPlaneThickness: chartAttrs.vzeroplanethickness,
      zeroPlaneAlpha: chartAttrs.vzeroplanealpha,
      showZeroPlaneValue: chartAttrs.showvzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showxaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.xaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.xaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.xaxislinecolor, chartAttrs.axislinecolor, COLOR_000000),
      freezeLimit: true
    };
    xAxisConf.vtrendlines = dataObj.vtrendlines;
    xAxisConfigure.push(xAxisConf);
    yAxisConf = {
      isVertical: true,
      isReverse: true,
      isOpposit: false,
      drawLabelsOpposit: 1,
      axisNameAlignCanvas: 1,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, defaultFontStr),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#?([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.yaxisnamepadding,
      axisValuePadding: chartAttrs.yaxisvaluespadding,
      axisNameFont: chartAttrs.pyaxisnamefont,
      axisNameFontSize: chartAttrs.pyaxisnamefontsize,
      axisNameFontColor: chartAttrs.pyaxisnamefontcolor,
      axisNameFontBold: chartAttrs.pyaxisnamefontbold,
      axisNameFontItalic: chartAttrs.pyaxisnamefontitalic,
      axisNameBgColor: chartAttrs.pyaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.pyaxisnamebordercolor,
      axisNameAlpha: chartAttrs.pyaxisnamealpha,
      axisNameFontAlpha: chartAttrs.pyaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.pyaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.pyaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.pyaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.pyaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.pyaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.pyaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.pyaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.pyaxisnameborderdashgap,
      axisNameWidth: chartAttrs.yaxisnamewidth,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      rotateAxisName: (0, _lib.pluckNumber)(chartAttrs.rotateyaxisname, 1),
      axisName: chartAttrs.pyaxisname,
      divLineColor: (0, _lib.pluck)(chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.divlinealpha, colorM.getColor(divLineAlphaStr)),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 1)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatehgridcolor, 1),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatehgridcolor, colorM.getColor(altHGridColorStr)),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatehgridalpha, colorM.getColor(altHGridAlphaStr)),
      numDivLines: (0, _lib.pluckNumber)(chartAttrs.numpdivlines, 5),
      axisMinValue: chartAttrs.pyaxisminvalue,
      axisMaxValue: chartAttrs.pyaxismaxvalue,
      setAdaptiveMin: (0, _lib.pluckNumber)(chartAttrs.setadaptiveymin, 1),
      adjustDiv: chartAttrs.adjustdiv,
      labelStep: chartAttrs.yaxisvaluesstep,
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue),
      showLimits: (0, _lib.pluckNumber)(chartAttrs.showyaxislimits, chartAttrs.showlimits, iapi.showLimits),
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showdivlinevalues, chartAttrs.showdivlinevalue),
      showZeroPlane: chartAttrs.showzeroplane,
      zeroPlaneColor: chartAttrs.zeroplanecolor,
      zeroPlaneThickness: chartAttrs.zeroplanethickness,
      zeroPlaneAlpha: chartAttrs.zeroplanealpha,
      showZeroPlaneValue: chartAttrs.showzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showyaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.yaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.yaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.yaxislinecolor, chartAttrs.axislinecolor, COLOR_000000)
    };
    yAxisConf.trendlines = dataObj.trendlines;
    yAxisConfigure.push(yAxisConf);
    if (iapi.config.showVolumeChart) {
      vYAxisConf = {
        isVertical: true,
        isReverse: true,
        isOpposit: false,
        drawLabelsOpposit: 1,
        axisNameAlignCanvas: 1,
        uniqueClassName: 1,
        outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, defaultFontStr),
        outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
        outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#?([a-f0-9]+)/ig, '#$1'),
        axisNamePadding: chartAttrs.yaxisnamepadding,
        axisValuePadding: chartAttrs.yaxisvaluespadding,
        axisNameFont: chartAttrs.vyaxisnamefont,
        axisNameFontSize: chartAttrs.vyaxisnamefontsize,
        axisNameFontColor: chartAttrs.vyaxisnamefontcolor,
        axisNameFontBold: chartAttrs.vyaxisnamefontbold,
        axisNameFontItalic: chartAttrs.vyaxisnamefontitalic,
        axisNameBgColor: chartAttrs.vyaxisnamebgcolor,
        axisNameBorderColor: chartAttrs.vyaxisnamebordercolor,
        axisNameAlpha: chartAttrs.vyaxisnamealpha,
        axisNameFontAlpha: chartAttrs.vyaxisnamefontalpha,
        axisNameBgAlpha: chartAttrs.vyaxisnamebgalpha,
        axisNameBorderAlpha: chartAttrs.vyaxisnameborderalpha,
        axisNameBorderPadding: chartAttrs.vyaxisnameborderpadding,
        axisNameBorderRadius: chartAttrs.vyaxisnameborderradius,
        axisNameBorderThickness: chartAttrs.vyaxisnameborderthickness,
        axisNameBorderDashed: chartAttrs.vyaxisnameborderdashed,
        axisNameBorderDashLen: chartAttrs.vyaxisnameborderdashlen,
        axisNameBorderDashGap: chartAttrs.vyaxisnameborderdashgap,
        axisNameWidth: chartAttrs.yaxisnamewidth,
        useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
        rotateAxisName: (0, _lib.pluckNumber)(chartAttrs.rotateyaxisname, 1),
        axisName: chartAttrs.vyaxisname,
        divLineColor: (0, _lib.pluck)(chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
        divLineAlpha: (0, _lib.pluck)(chartAttrs.divlinealpha, colorM.getColor(divLineAlphaStr)),
        divLineThickness: (0, _lib.pluckNumber)(chartAttrs.divlinethickness, 1),
        divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 1)),
        divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.divlinedashlen, 4),
        divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.divlinedashgap, 2),
        showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatehgridcolor, 1),
        alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatehgridcolor, colorM.getColor(altHGridColorStr)),
        alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatehgridalpha, colorM.getColor(altHGridAlphaStr)),
        numDivLines: chartAttrs.numdivlines,
        // @todo have to change the y axis max and min value afterwards when percentage axis is ready
        axisMinValue: chartAttrs.vyaxisminvalue,
        axisMaxValue: chartAttrs.vyaxismaxvalue,
        setAdaptiveMin: chartAttrs.setadaptiveymin,
        adjustDiv: chartAttrs.adjustdiv,
        labelStep: chartAttrs.yaxisvaluesstep,
        showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue),
        showLimits: (0, _lib.pluckNumber)(chartAttrs.showsecondarylimits, chartAttrs.showlimits),
        showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showdivlinevalues, chartAttrs.showdivlinevalue),
        showZeroPlane: chartAttrs.showzeroplane,
        zeroPlaneColor: chartAttrs.zeroplanecolor,
        zeroPlaneThickness: chartAttrs.zeroplanethickness,
        zeroPlaneAlpha: chartAttrs.zeroplanealpha,
        showZeroPlaneValue: chartAttrs.showzeroplanevalue,
        trendlineColor: chartAttrs.trendlinecolor,
        trendlineToolText: chartAttrs.trendlinetooltext,
        trendlineThickness: chartAttrs.trendlinethickness,
        trendlineAlpha: chartAttrs.trendlinealpha,
        showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
        showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showyaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
        axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.yaxislinethickness, chartAttrs.axislinethickness, 1),
        axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.yaxislinealpha, chartAttrs.axislinealpha, 100),
        axisLineColor: (0, _lib.pluck)(chartAttrs.yaxislinecolor, chartAttrs.axislinecolor, COLOR_000000)
      };
      yAxisConfigure.push(vYAxisConf);
    }
    return { xAxisConfigure: xAxisConfigure, yAxisConfigure: yAxisConfigure };
  };
  /**
   * This method delegates the handling of  mouse event to the chart's event handler
   * @param  {Object} e The Event Object
   * @param  {Object} data The Data Object
   * @private
   */


  CandleStick.prototype._mouseEvtHandler = function _mouseEvtHandler(e, data) {
    var iapi = this,
        mouseTracker = data.mouseTracker,
        oriEvent = e.originalEvent,
        canvas,
        canvasArr = iapi.getChildren('canvas'),
        canvasLen = canvasArr.length,
        datasets,
        coordinate = oriEvent && (0, _lib.getMouseCoordinate)(iapi.getFromEnv('chart-container'), oriEvent, iapi),
        chartX = coordinate && coordinate.chartX || 0,
        chartY = coordinate && coordinate.chartY || 0,
        dataset,
        hoveredInfo,
        pointFound = false,
        i,
        j,
        l,
        derivedEvensInfo,
        _lastDatasetIndex = mouseTracker._lastDatasetIndex,
        _lastPointIndex = mouseTracker._lastPointIndex;

    for (i = 0; i < canvasLen; i++) {
      canvas = canvasArr[i];
      // todo make sure the datasets are as per their z-order
      datasets = iapi.getDatasets(canvas);
      j = datasets.length;
      while (j-- && !pointFound) {
        dataset = datasets[j];
        if (dataset && dataset.getState('visible')) {
          hoveredInfo = dataset._getHoveredPlot && dataset._getHoveredPlot(chartX, chartY);
          if (hoveredInfo && hoveredInfo.hovered) {
            pointFound = true;
            hoveredInfo.datasetIndex = j;
            derivedEvensInfo = mouseTracker.getMouseEvents(e, hoveredInfo.datasetIndex, hoveredInfo.pointIndex);
          }
        }
      }
    }

    // todo instead of sending event names, create a event object of that type and send it

    // fire out on last hovered plot
    if ((!pointFound || derivedEvensInfo && derivedEvensInfo.fireOut) && typeof _lastDatasetIndex !== 'undefined') {
      // delete stored last ds details
      delete mouseTracker._lastDatasetIndex;
      delete mouseTracker._lastPointIndex;
      datasets && datasets[_lastDatasetIndex] && datasets[_lastDatasetIndex]._firePlotEvent && datasets[_lastDatasetIndex]._firePlotEvent(MOUSEOUT, _lastPointIndex, e);

      // todo scope to have sticky tracked tooltip
    }
    // fire remaining events
    if (pointFound) {
      l = derivedEvensInfo.events && derivedEvensInfo.events.length;
      // store the index of the hovered DS and plot
      mouseTracker._lastDatasetIndex = hoveredInfo.datasetIndex;
      _lastPointIndex = mouseTracker._lastPointIndex = hoveredInfo.pointIndex;

      for (j = 0; j < l; j += 1) {
        dataset && dataset._firePlotEvent && dataset._firePlotEvent(derivedEvensInfo.events[j], _lastPointIndex, e, hoveredInfo.datasetIndex);
      }
    }
  };
  /**
   * allocate space for canvas
   * @param  {Object} dimensions contains left, right, top, bottom co-ordinate (relative)
   */


  CandleStick.prototype._allocateSpace = function _allocateSpace(dimensions) {
    var iapi = this,
        canvas = iapi.getChildren('canvas'),
        canvasConfig = canvas && canvas[0].config,
        config = iapi.config,
        canvasHeight = config.canvasHeight,
        canvasWidth = config.canvasWidth,
        canvasTop,
        canvasLeft,
        availableHeight = config.availableHeight,
        availableWidth = config.availableWidth;

    canvasLeft = config.canvasLeft += dimensions.left || 0;
    canvasTop = config.canvasTop += dimensions.top || 0;
    canvasWidth = config.canvasWidth = mathMax(canvasWidth - ((dimensions.left || 0) + (dimensions.right || 0)), 0);
    canvasHeight = config.canvasHeight = mathMax(canvasHeight - ((dimensions.top || 0) + (dimensions.bottom || 0)), 0);

    config.availableHeight = mathMax(availableHeight - ((dimensions.top || 0) + (dimensions.bottom || 0)), 0);
    config.availableWidth = mathMax(availableWidth - ((dimensions.left || 0) + (dimensions.right || 0)), 0);
    config.canvasRight = canvasLeft + canvasWidth;
    config.canvasBottom = canvasTop + canvasHeight;

    if (canvasConfig) {
      canvasConfig.canvasPaddingLeft = mathMax(canvasConfig.canvasPaddingLeft, dimensions.paddingLeft || 0);
      canvasConfig.canvasPaddingRight = mathMax(canvasConfig.canvasPaddingRight, dimensions.paddingRight || 0);
      canvasConfig.canvasPaddingTop = mathMax(canvasConfig.canvasPaddingTop, dimensions.paddingTop || 0);
      canvasConfig.canvasPaddingBottom = mathMax(canvasConfig.canvasPaddingBottom, dimensions.paddingBottom || 0);
    }
  };

  /**
   * function to check if the chart specific data is proper is not
   * this fn is define for specific chart types
   * @return {boolean} if JSON data is valid or not
   */


  CandleStick.prototype._checkInvalidSpecificData = function _checkInvalidSpecificData() {
    var jsonData = this.getFromEnv('dataSource'),
        datasetsJSON = jsonData.dataset;
    if (!datasetsJSON) {
      return true;
    }
  };

  return CandleStick;
}(_fusioncharts2['default']);

exports['default'] = CandleStick;

/***/ }),

/***/ 879:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var jsonData = chart.getFromEnv('dataSource'),
      datasetsJSON = jsonData.dataset,
      trendSet = jsonData.trendset,
      chartAttrs = chart.getFromEnv('chart-attrib'),
      showVolumeChart = chart.getFromEnv('chartConfig').showVolumeChart,
      dsType = (0, _lib.pluck)((0, _lib.parseUnsafeString)(chartAttrs.plotpriceas).toLowerCase(), 'candlestick'),
      children = chart.getChildren(),
      canvas = children.canvas[0],
      datasetParent = canvas.getChildren('vCanvas')[0],
      volumeCanvas = void 0,
      volumeDatasetParent = void 0,
      sortedDatasetsJSON = void 0,
      set = ['candlestick', 'candlestickbar', 'candlestickline', 'trendset'],
      DSClass = void 0;

  if (!datasetsJSON) {
    chart.setChartMessage();
    return;
  }
  sortedDatasetsJSON = datasetsJSON.slice(0);
  sortedDatasetsJSON[0] && sortedDatasetsJSON[0].data && sortedDatasetsJSON[0].data.sort(function (a, b) {
    return a.x - b.x;
  });
  DSClass = chart.getDSdef(dsType);
  (0, _lib.datasetFactory)(datasetParent, DSClass, 'dataset_' + dsType, datasetsJSON.length, sortedDatasetsJSON);
  if (dsType === 'bar') {
    arraySpliceByValue(set, 'candlestickbar');
  } else if (dsType === 'line') {
    arraySpliceByValue(set, 'candlestickline');
  } else {
    arraySpliceByValue(set, 'candlestick');
  }
  if (showVolumeChart) {
    volumeCanvas = children.canvas[1];
    volumeDatasetParent = volumeCanvas.getChildren('vCanvas')[0];
    (0, _lib.datasetFactory)(volumeDatasetParent, _volume2['default'], 'dataset_volume', datasetsJSON.length, datasetsJSON);
  }

  if (trendSet) {
    (0, _lib.datasetFactory)(datasetParent, _trendset2['default'], 'dataset_trendset', trendSet.length, trendSet);
    arraySpliceByValue(set, 'trendset');
  }
  removeComponents(datasetParent, set);
};

var _lib = __webpack_require__(5);

var _volume = __webpack_require__(880);

var _volume2 = _interopRequireDefault(_volume);

var _trendset = __webpack_require__(882);

var _trendset2 = _interopRequireDefault(_trendset);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * splice a given array with the given value
 * @param  {Array} array   on which splice opration will be executed
 * @param  {generic} value criteria to splice the array
 */
var arraySpliceByValue = function arraySpliceByValue(array, value) {
  var indexOf = array.indexOf(value);
  if (indexOf !== -1) {
    array.splice(indexOf, 1);
  }
},

/**
 * function to remove component if name is matched with value in set
 * @param  {Object} component from where it would iterate
 * @param  {Array} set        criteria; if matched then remove
 */
removeComponents = function removeComponents(component, set) {
  var i = void 0;
  component && component.iterateComponents(function (child) {
    for (i = 0; i < set.length; i++) {
      if (child.getName() === set[i]) {
        child.remove();
      }
    }
  });
};
/**
 * function to  create dataset
 * sort data wrt. x value
 * assign dataset to its parents
 **/

/***/ }),

/***/ 880:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _lib = __webpack_require__(5);

var _candlestick = __webpack_require__(146);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var colorStrings = _lib.preDefStr.colors,
    COLOR_B90000 = colorStrings.B90000,
    DASH_DEF = 'none',
    COLOR_FFFFFF = colorStrings.FFFFFF;

/**
 * Class def for bull candles chart API
 * This dataset is reponsible for drawing candle depending on open and close value
 */

var Volume = function (_Column) {
  _inherits(Volume, _Column);

  function Volume() {
    _classCallCheck(this, Volume);

    return _possibleConstructorReturn(this, _Column.apply(this, arguments));
  }

  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * This function is called once from the init() function of the Column class.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} Indicates whether the configuration was successful or not
    */
  Volume.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.config.JSONData = datasetJSON;

    var dataset = this,
        conf = dataset.config,
        JSONData = dataset.config.JSONData,
        dataArr = JSONData.data || [],
        chartAttr = dataset.getFromEnv('chart-attrib'),
        chartConfig = dataset.getFromEnv('chartConfig'),
        dataLength = dataArr.length,
        colorM = dataset.getFromEnv('color-manager'),
        setColor,
        setAlpha,
        pointShadow,
        index,
        dataObj,
        open,
        close,
        volume,
        x,
        borderAlpha,
        numberFormatterAttrs,
        plotLineDashLen,
        plotLineDashGap,

    // Candle stick properties.
    // Bear fill and border color - (Close lower than open)
    bearBorderColor = conf.bearBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartConfig.vplotbordercolor, chartAttr.bearbordercolor, COLOR_B90000)),
        bearFillColor = conf.bearFillColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bearfillcolor, COLOR_B90000)),

    // Bull fill and border color - Close higher than open
    bullBorderColor = conf.bullBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartConfig.vplotbordercolor, chartAttr.bullbordercolor, colorM.getColor('canvasBorderColor'))),
        bullFillColor = conf.bullFillColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bullfillcolor, COLOR_FFFFFF)),
        showVPlotBorder = (0, _lib.pluckNumber)(chartConfig.showplotborder, 1),

    // VPlotBorder is border properties for the volume chart.
    vPlotBorderThickness = showVPlotBorder ? (0, _lib.pluckNumber)(chartAttr.vplotborderthickness, 1) : 0,
        dataStore,
        setData,
        config,
        enableAnimation,
        plotSpacePercent,
        numberFormatter = dataset.getFromEnv('number-formatter'),
        yMax = -Infinity,
        yMin = +Infinity,
        xMax = -Infinity,
        xMin = +Infinity,
        userMaxColWidth,
        vNumberFormatter = dataset.getFromEnv('number-formatter');
    dataset.setState('visible', (0, _lib.pluckNumber)(JSONData.visible, 1) === 1);
    if (dataset.getState('visible') === true) {
      dataset._conatinerHidden = false;
    } else {
      dataset._containerHidden = true;
    }
    conf.parentYAxis = 1;
    conf.volumeToolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(JSONData.volumetooltext, chartAttr.volumetooltext, chartAttr.plottooltext)));
    // Dataset seriesname
    conf.name = (0, _lib.getValidValue)(JSONData.seriesname);
    conf.showTooltip = (0, _lib.pluck)(chartAttr.showtooltip, 1);
    // Animation related attributes configuration
    conf.enableAnimation = enableAnimation = (0, _lib.pluckNumber)(chartAttr.animation, chartAttr.defaultanimation, 1);
    conf.animation = !enableAnimation ? false : {
      duration: (0, _lib.pluckNumber)(chartAttr.animationduration, 1) * 1000
    };
    userMaxColWidth = (0, _lib.pluck)(chartAttr.maxcolwidth);
    conf.maxColWidth = Math.abs((0, _lib.pluckNumber)(userMaxColWidth, 50)) || 1;
    plotSpacePercent = Math.max((0, _lib.pluckNumber)(chartAttr.plotspacepercent, 20) % 100, 0);
    conf.plotSpacePercent = conf.groupPadding = plotSpacePercent / 200;
    conf.plotborderthickness = vPlotBorderThickness;
    dataStore = dataset.components.data = dataset.components.data || (dataset.components.data = []);
    numberFormatterAttrs = (0, _lib.extend2)((0, _lib.extend2)({}, chartAttr), {
      forcedecimals: (0, _lib.getFirstValue)(chartAttr.forcevdecimals, chartAttr.forcedecimals),
      forceyaxisvaluedecimals: (0, _lib.getFirstValue)(chartAttr.forcevyaxisvaluedecimals, chartAttr.forceyaxisvaluedecimals),
      yaxisvaluedecimals: (0, _lib.getFirstValue)(chartAttr.vyaxisvaluedecimals, chartAttr.yaxisvaluedecimals),
      formatnumber: (0, _lib.getFirstValue)(chartAttr.vformatnumber, chartAttr.formatnumber),
      formatnumberscale: (0, _lib.getFirstValue)(chartAttr.vformatnumberscale, chartAttr.formatnumberscale),
      defaultnumberscale: (0, _lib.getFirstValue)(chartAttr.vdefaultnumberscale, chartAttr.defaultnumberscale),
      numberscaleunit: (0, _lib.getFirstValue)(chartAttr.vnumberscaleunit, chartAttr.numberscaleunit),
      vnumberscalevalue: (0, _lib.getFirstValue)(chartAttr.vnumberscalevalue, chartAttr.numberscalevalue),
      scalerecursively: (0, _lib.getFirstValue)(chartAttr.vscalerecursively, chartAttr.scalerecursively),
      maxscalerecursion: (0, _lib.getFirstValue)(chartAttr.vmaxscalerecursion, chartAttr.maxscalerecursion),
      scaleseparator: (0, _lib.getFirstValue)(chartAttr.vscaleseparator, chartAttr.scaleseparator),
      numberprefix: (0, _lib.getFirstValue)(chartAttr.vnumberprefix, chartAttr.numberprefix),
      numbersuffix: (0, _lib.getFirstValue)(chartAttr.vnumbersuffix, chartAttr.numbersuffix),
      decimals: (0, _lib.getFirstValue)(chartAttr.vdecimals, chartAttr.decimals)
    });
    plotLineDashLen = conf.plotLineDashLen = (0, _lib.pluckNumber)(chartAttr.plotlinedashlen, 5);
    plotLineDashGap = conf.plotLineDashGap = (0, _lib.pluckNumber)(chartAttr.plotlinedashgap, 4);

    vNumberFormatter.configure(numberFormatterAttrs);

    // Iterate through all level data
    for (index = 0; index < dataLength; index += 1) {
      // Individual data obj
      // for further manipulation
      setData = dataArr[index];
      dataObj = dataStore[index];
      if (!dataObj) {
        dataObj = dataStore[index] = {};
      }
      !dataObj.config && (dataObj.config = {});
      !dataObj.graphics && (dataObj.graphics = {});
      config = dataObj.config;
      if (setData && !setData.vline) {
        open = config.open = numberFormatter.getCleanValue(setData.open);
        close = config.close = numberFormatter.getCleanValue(setData.close);
        volume = config.volume = numberFormatter.getCleanValue(setData.volume, true);
        config.high = numberFormatter.getCleanValue(setData.high);
        config.low = numberFormatter.getCleanValue(setData.low);
        x = config.x = numberFormatter.getCleanValue(setData.x);

        yMax = Math.max(yMax, volume);
        yMin = Math.min(yMin, volume);
        xMax = Math.max(xMax, x);
        xMin = Math.min(xMin, x);
        // valueText = parseUnsafeString(getValidValue(setData.valuetext, BLANK));

        config.borderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.bordercolor, close < open ? bearBorderColor : bullBorderColor));
        setAlpha = (0, _lib.pluckNumber)(setData.alpha, 100);
        borderAlpha = (0, _lib.pluckNumber)(chartConfig.vplotborderalpha, setData.alpha, 100);
        setColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.color, close < open ? bearFillColor : bullFillColor));
        // Set alpha of the shadow
        pointShadow = {
          opacity: setAlpha / 100
        };
        config.color = setColor;
        config.alpha = setAlpha;
        config.setLink = setData.link;
        config.borderWidth = vPlotBorderThickness;
        config.borderAlpha = borderAlpha;
        config.y = volume;
        config.colorArr = [{
          color: config.color,
          alpha: config.alpha
        }, {
          color: config.borderColor,
          alpha: config.borderAlpha
        }];
        config.toolText = dataset._parseToolText(index);
        config.toolTipValue = '';
        config.setValue = config._y = config.y;
        config.plotBorderDashStyle = (0, _lib.pluckNumber)(setData.dashed) ? (0, _lib.getDashStyle)(plotLineDashLen, plotLineDashGap) : DASH_DEF;
        x = x !== null ? x : index + 1;
        config._x = x;
        config.shadow = pointShadow;
      }
    }
    conf.defaultPadding = {
      left: 0,
      right: 0
    };
    conf.yMax = yMax;
    conf.yMin = yMin;
    conf.xMax = xMax;
    conf.xMin = xMin;
    dataset.setState('dirty', true);
  };
  /**
   * parse tooltext from the dataset json
   * @param {number} i index of data
   * @return {string} tooltext
   */


  Volume.prototype._parseToolText = function _parseToolText(i) {
    return _candlestick._parseToolText.call(this, i);
  };
  /**
   * fetches data indices wrt. the x pos value
   * @param {number} x  x pos value
   * @return {Array}    contains indices
   */


  Volume.prototype.getPlotIndices = function getPlotIndices(x) {
    var dataset = this,
        i,
        minX = Math.floor(x),
        maxX = Math.ceil(x),
        data,
        returnIndices = [],
        sortedData = dataset.config.JSONData && dataset.config.JSONData.data;

    for (i = sortedData.length; i--;) {
      data = sortedData[i];
      if (data.x >= minX && data.x <= maxX) {
        returnIndices.push(i);
      }
    }
    return returnIndices;
  };
  /**
   * Function that retunr the nearest plot details
   * @param {number} chartX x-axis position of the mouse cordinate
   * @param {number} chartY x-axis position of the mouse cordinate
   * @return {Object} return an object with details of nearest polt and whether it is hovered or not
   */


  Volume.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        xAxis = dataset.getFromEnv('xAxis'),
        x,
        i,
        hoveredInfo,
        pXs,
        pX;

    chartX += xAxis.getTranslation();
    x = xAxis.getValue(chartX);
    pXs = dataset.getPlotIndices(x);
    // Checking for overlap between two cosecutive column plots along x-axis
    for (i = pXs.length - 1; i > -1; i--) {
      pX = pXs[i];
      hoveredInfo = pX - x > 0 ? dataset._checkPointerOverColumn(pX, chartX, chartY) || dataset._checkPointerOverColumn(pX - 1, chartX, chartY) : dataset._checkPointerOverColumn(pX + 1, chartX, chartY) || dataset._checkPointerOverColumn(pX, chartX, chartY);
      if (hoveredInfo) {
        break;
      }
    }
    return hoveredInfo;
  };
  /**
   * Function to get the maximum and minimum from dataset
   * @return {Object}     contains max, min value
   */


  Volume.prototype.getDataLimits = function getDataLimits() {
    var conf = this.config;
    return {
      max: conf.yMax,
      min: conf.yMin,
      xMax: conf.xMax,
      xMin: conf.xMin
    };
  };
  /**
   * calculate min and max position to scroll
   */


  Volume.prototype.calculateScrollRange = function calculateScrollRange() {
    var dataset = this,
        conf = dataset.config,
        dataLen = dataset.components.data && dataset.components.data.length;
    conf.scrollMinVal = 0;
    conf.scrollMaxVal = dataLen;
  };
  /**
    * This function overrides drawlabel method
    * it prevents the label drawing
    */
  // eslint-disable-next-line


  Volume.prototype.drawLabel = function drawLabel() {};
  /**
   * Returns the name of the component
   *
   * @return {string} The name of the component
   */


  Volume.prototype.getName = function getName() {
    return 'volume';
  };

  return Volume;
}(_column2['default']);

exports['default'] = Volume;

/***/ }),

/***/ 881:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.candlestick': function initialDatasetCandlestick() {
    return {
      'rect.appearing': function rectAppearing(inputJSON) {
        return [{
          initialAttr: {
            y: inputJSON.attr.y + inputJSON.attr.height,
            height: 0
          },
          slot: 'plot'
        }];
      },
      'group.appearing': function groupAppearing(inputJSON) {
        if (inputJSON.attr.name === 'label-group') {
          return [{
            initialAttr: {
              opacity: 0
            },
            finalAttr: {
              opacity: 1
            },
            slot: 'final'
          }];
        } else {
          return [{
            initialAttr: {
              opacity: 1
            },
            finalAttr: {
              opacity: 1
            },
            slot: 'final'
          }];
        }
      },
      '*': null
    };
  },
  'initial.dataset.volume': function initialDatasetVolume() {
    return {
      'rect.appearing': function rectAppearing(inputJSON) {
        return [{
          initialAttr: {
            y: inputJSON.attr.y + inputJSON.attr.height,
            height: 0
          },
          slot: 'plot'
        }];
      },
      '*': null
    };
  }
};

/***/ }),

/***/ 882:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _trendsetAnimation = __webpack_require__(883);

var _trendsetAnimation2 = _interopRequireDefault(_trendsetAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var HUNDRED = '100',

// The default value for stroke-dash attribute
DASH_DEF = 'none';

(0, _dependencyManager.addDep)({
  name: 'trendsetAnimation',
  type: 'animationRule',
  extension: _trendsetAnimation2['default']
});
/**
 * Class def for bull candles chart API
 * This dataset is reponsible for drawing candle depending on open and close value
 */

var Trendset = function (_Line) {
  _inherits(Trendset, _Line);

  function Trendset() {
    _classCallCheck(this, Trendset);

    return _possibleConstructorReturn(this, _Line.apply(this, arguments));
  }

  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * This function is called once from the init() function of the Column class.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} Indicates whether the configuration was successful or not
    */
  Trendset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.config.JSONData = datasetJSON;
    var dataset = this,
        chartAttr = dataset.getFromEnv('chart-attrib'),
        chartConfig = dataset.getFromEnv('chartConfig'),
        trendset = dataset.config.JSONData,
        index = dataset.index,
        setDataArr = trendset.data || trendset.set || [],
        conf = dataset.config,
        dataObj,
        itemValue,
        dataStore = dataset.components.data,
        dataStoreObj,
        config,
        maxValue = -Infinity,
        minValue = +Infinity,
        x,
        length,
        xMax = -Infinity,
        xMin = +Infinity,
        NumberFormatter = dataset.getFromEnv('number-formatter'),

    // Trend-sets default properties
    trendSetColor = (0, _lib.getFirstColor)((0, _lib.pluck)(trendset.color, chartAttr.trendsetcolor, '666666')),
        trendSetAlpha = (0, _lib.pluck)(trendset.alpha, chartAttr.trendsetalpha, HUNDRED),
        trendSetThickness = (0, _lib.pluckNumber)(trendset.thickness, chartAttr.trendsetthickness, 2),
        trendSetDashed = Boolean((0, _lib.pluckNumber)(trendset.dashed, chartAttr.trendsetdashed, 0)),
        trendSetDashLen = (0, _lib.pluckNumber)(trendset.dashlen, chartAttr.trendsetdashlen, 4),
        trendSetDashGap = (0, _lib.pluckNumber)(trendset.dashgap, chartAttr.trendsetdashgap, 4);

    conf.includeInLegend = (0, _lib.pluckNumber)(trendset.includeinlegend, 1);
    conf.lineColor = trendSetColor;
    conf.lineAlpha = trendSetAlpha;
    conf.connectNullData = (0, _lib.pluckNumber)(chartAttr.connectnulldata, 0);
    conf.linethickness = trendSetThickness;
    conf.lineDashStyle = trendSetDashed ? (0, _lib.getDashStyle)(trendSetDashLen, trendSetDashGap) : DASH_DEF;
    conf.name = (0, _lib.getValidValue)(trendset.name);
    conf.includeInLegend = (0, _lib.pluckNumber)(trendset.includeinlegend, 1);
    conf.defaultPadding = {
      left: 0.5,
      right: 0.5
    };
    if (!dataStore) {
      dataStore = dataset.components.data = [];
    }
    for (index = 0, length = setDataArr.length; index < length; index += 1) {
      dataObj = setDataArr[index];
      if (dataObj && !dataObj.vline) {
        dataStoreObj = dataStore[index] = dataStore[index] || (dataStore[index] = {});
        config = dataStoreObj.config = dataStoreObj.config || (dataStoreObj.config = {});
        itemValue = config._y = config.setValue = NumberFormatter.getCleanValue(dataObj.value);
        config.setColor = conf.lineColor;
        config.setAlpha = conf.lineAlpha;
        x = NumberFormatter.getCleanValue(dataObj.x);
        x = config._x = config.x = x !== null ? x : index + 1;
        maxValue = Math.max(maxValue, itemValue);
        minValue = Math.min(minValue, itemValue);
        xMin = Math.min(xMin, x);
        xMax = Math.max(xMax, x);
        // Parsing the anchor properties for set level
        config.anchorProps = this._parseAnchorProperties(index);
        config.hoverEffects = {};
        if (!dataStoreObj.graphics) {
          dataStoreObj.graphics = {};
        }
      }
    }
    conf.max = maxValue;
    conf.min = minValue;
    conf.xMax = xMax;
    conf.xMin = xMin;
    chartConfig.showLegend && dataset._addLegend();
    dataset.setState('visible', true);
    dataset.setState('dirty', true);
  };
  /**
   * Function to register datasets in the internal data store of legend class.
   */


  Trendset.prototype._addLegend = function _addLegend() {
    var dataset = this,
        JSONData = dataset.config.JSONData,
        conf = dataset.config,
        legendItem,
        legend = dataset.getFromEnv('legend'),
        config = {
      enabled: conf.includeInLegend,
      interactiveLegend: false,
      type: dataset.type,
      drawLine: true,
      label: (0, _lib.getFirstValue)(JSONData.name)
    };
    if (conf.includeinlegend) {
      legendItem = legend.getItem(dataset.config.legendItemId);
      if (!legendItem) {
        dataset.config.legendItemId = legend.createItem(dataset);
        legendItem = legend.getItem(dataset.config.legendItemId);
        dataset.addExtEventListener('click', function () {
          dataset.legendInteractivity(legendItem);
        }, legendItem);
      } else {
        legendItem.configure({ style: legend.config.itemStyle,
          hiddenStyle: legend.config.itemHiddenStyle,
          datasetVisible: legend.config.datasetVisible,
          hoverStyle: legend.config.itemHoverStyle });
      }
      legendItem.configure(config);
      legendItem.setStateCosmetics('default', {
        symbol: {
          stroke: (0, _lib.toRaphaelColor)({
            color: conf.lineColor,
            alpha: HUNDRED
          })
        }
      });
    } else if (dataset.config.legendItemId) {
      legend.disposeItem(dataset.config.legendItemId);
    }
  };
  /**
   * Fuction to be fired on legend click
   */
  // eslint-disable-next-line


  Trendset.prototype.legendInteractivity = function legendInteractivity() {}
  // for this dataset no legend interaction is needed

  /**
   * Function to get the maximum and minimum from dataset
   * @return {Object}     contains max, min value
   */
  ;

  Trendset.prototype.getDataLimits = function getDataLimits() {
    var conf = this.config;
    return {
      max: conf.max,
      min: conf.min,
      xMax: conf.xMax,
      xMin: conf.xMin
    };
  };
  /**
   * Sets the type of the component
   * @return {string} type
   */


  Trendset.prototype.getType = function getType() {
    return 'trendset';
  };
  /**
    * This function overrides drawlabel method
    * it prevents the label drawing
    */
  // eslint-disable-next-line


  Trendset.prototype.drawLabel = function drawLabel() {};

  /**
   * Sets the name of the component
   * @return {string} name
   */


  Trendset.prototype.getName = function getName() {
    return 'trendset';
  };

  return Trendset;
}(_line2['default']);

exports['default'] = Trendset;

/***/ }),

/***/ 883:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lineAnimation = __webpack_require__(25);

var _lineAnimation2 = _interopRequireDefault(_lineAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.trendset.trendset': _lineAnimation2['default']['initial.dataset.line']
};

/***/ }),

/***/ 884:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var canvasArr = chart.getChildren('canvas'),
      canvas = canvasArr[0],
      canvasVolume = canvasArr[1],
      showVolumeChart = chart.config.showVolumeChart,
      zoomObj = {
    zoomable: true,
    pannable: true
  },
      conf = void 0,
      axisRefVisualCartesian = canvas.getChildren('axisRefVisualCartesian')[0],
      axisRefVisualCartesianVol = canvasVolume.getChildren('axisRefVisualCartesian')[0],
      vYAxis = void 0,
      yAxis = void 0,
      xAxis = void 0,
      redraw = function redraw() {
    return axisRefVisualCartesian.asyncDraw();
  },
      redrawVol = function redrawVol() {
    return axisRefVisualCartesianVol.asyncDraw();
  };

  conf = chart._feedAxesRawData();
  (0, _lib.componentFactory)(chart, _numeric2['default'], 'yAxis', showVolumeChart ? 2 : 1, conf.yAxisConfigure);
  (0, _lib.componentFactory)(chart, _numeric2['default'], 'xAxis', 1, conf.xAxisConfigure);

  yAxis = chart.getChildren('yAxis')[0];
  vYAxis = chart.getChildren('yAxis')[1];
  yAxis.setAxisConfig({
    relativeAxis: vYAxis
  });
  vYAxis && vYAxis.setAxisConfig({
    relativeAxis: yAxis
  });
  xAxis = chart.getChildren('xAxis')[0];

  yAxis.setLinkedItem('canvas', canvas);
  xAxis.setLinkedItem('canvas', canvas);

  axisRefVisualCartesian.setLinkedItem(yAxis.getId(), yAxis);
  axisRefVisualCartesian.setLinkedItem(xAxis.getId(), xAxis);

  axisRefVisualCartesian.addExtEventListener('visiblerangeset', redraw, yAxis);
  axisRefVisualCartesian.addExtEventListener('visiblerangeset', redraw, xAxis);

  canvas.attachAxis(xAxis, false, chart.zoomX ? zoomObj : {});
  canvas.attachAxis(yAxis, true, chart.zoomY ? zoomObj : {});
  if (showVolumeChart) {
    canvasVolume.attachAxis(xAxis, false, chart.zoomX ? zoomObj : {});

    vYAxis.setLinkedItem('canvas', canvas);
    axisRefVisualCartesianVol.setLinkedItem(vYAxis.getId(), vYAxis);
    axisRefVisualCartesianVol.addExtEventListener('visiblerangeset', redrawVol, vYAxis);
    canvasVolume.attachAxis(vYAxis, true, chart.zoomY ? zoomObj : {});
  }

  chart._setCategories();
};

var _lib = __webpack_require__(5);

var _numeric = __webpack_require__(69);

var _numeric2 = _interopRequireDefault(_numeric);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 885:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _errorbar2d = __webpack_require__(144);

var _candlestick = __webpack_require__(146);

var _dependencyManager = __webpack_require__(6);

var _candlestickbarAnimation = __webpack_require__(886);

var _candlestickbarAnimation2 = _interopRequireDefault(_candlestickbarAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var colorStrings = _lib.preDefStr.colors,
    COLOR_B90000 = colorStrings.B90000,
    COLOR_FFFFFF = colorStrings.FFFFFF,
    ROUND = _lib.preDefStr.ROUND,
    visibleStr = _lib.preDefStr.visibleStr,
    DASH_DEF = 'none',
    POINTER = 'pointer',
    BLANKSTRING = '',
    M = 'M',
    L = 'L';

(0, _dependencyManager.addDep)({
  name: 'candlestickbarAnimation',
  type: 'animationRule',
  extension: _candlestickbarAnimation2['default']
});
/**
 * Class def for bull stick chart API
 * This dataset is reponsible for drawing stick depending on high and open value
 */

var CandleStickBar = function (_Column) {
  _inherits(CandleStickBar, _Column);

  function CandleStickBar() {
    _classCallCheck(this, CandleStickBar);

    return _possibleConstructorReturn(this, _Column.apply(this, arguments));
  }

  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * This function is called once from the init() function of the Column class.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} Indicates whether the configuration was successful or not
    */
  CandleStickBar.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.config.JSONData = datasetJSON;

    var dataset = this,
        conf = dataset.config,
        chart = dataset.getFromEnv('chart'),
        rawDataObj = chart.getFromEnv('dataSource'),
        JSONData = dataset.config.JSONData,
        dataArr = JSONData.data || [],
        chartAttr = rawDataObj.chart,
        dataLength = dataArr.length,
        numberFormatter = dataset.getFromEnv('number-formatter'),
        colorM = dataset.getFromEnv('color-manager'),
        setColor,
        setBorderColor,
        setAlpha,

    // Candle stick properties.
    // Bear fill and border color - (Close lower than open)
    bearBorderColor = conf.bearBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bearbordercolor, COLOR_B90000)),
        bearFillColor = conf.bearFillColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bearfillcolor, COLOR_B90000)),

    // Bull fill and border color - Close higher than open
    bullBorderColor = conf.bullBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bullbordercolor, colorM.getColor('canvasBorderColor'))),
        bullFillColor = conf.bullFillColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bullfillcolor, COLOR_FFFFFF)),
        index,
        dataObj,
        open,
        close,
        high,
        low,
        minValue,
        maxValue,
        x,
        plotLineDashLen,
        plotLineDashGap,
        dataStore,
        setData,
        config,
        isCandleStick = false,
        yMax = -Infinity,
        yMin = +Infinity,
        xMax = -Infinity,
        xMin = +Infinity,
        userMaxColWidth,
        enableAnimation;

    dataset.setState('visible', (0, _lib.pluckNumber)(JSONData.visible, 1) === 1);

    dataset._conatinerHidden = !!dataset.getState('visible');

    conf.defaultPadding = {
      left: 0.5,
      right: 0.5
    };
    conf.linethickness = (0, _lib.pluckNumber)(chartAttr.plotlinethickness, 2);
    conf.toolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(JSONData.tooltext, chartAttr.plottooltext)));
    // Dataset seriesname
    conf.name = (0, _lib.getValidValue)(JSONData.seriesname);
    conf.showTooltip = (0, _lib.pluck)(chartAttr.showtooltip, 1);

    conf.showErrorValue = true;
    conf.errorBarWidthPercent = 0;
    isCandleStick = true;
    userMaxColWidth = (0, _lib.pluck)(chartAttr.maxcolwidth);
    conf.maxColWidth = Math.abs((0, _lib.pluckNumber)(userMaxColWidth, 50)) || 1;
    // Animation related attributes configuration
    conf.enableAnimation = enableAnimation = (0, _lib.pluckNumber)(chartAttr.animation, chartAttr.defaultanimation, 1);
    conf.animation = !enableAnimation ? false : {
      duration: (0, _lib.pluckNumber)(chartAttr.animationduration, 1) * 1000
    };

    plotLineDashLen = conf.plotLineDashLen = (0, _lib.pluckNumber)(chartAttr.plotlinedashlen, 5);
    plotLineDashGap = conf.plotLineDashGap = (0, _lib.pluckNumber)(chartAttr.plotlinedashgap, 4);
    dataStore = dataset.components.data = dataset.components.data || (dataset.components.data = []);
    conf.valuePadding = (0, _lib.pluckNumber)(JSONData.valuepadding, chartAttr.valuepadding, 2);
    // Iterate through all level data
    for (index = 0; index < dataLength; index++) {
      // Individual data obj
      // for further manipulation
      setData = dataArr[index];
      dataObj = dataStore[index];
      if (!dataObj) {
        dataObj = dataStore[index] = {};
      }
      !dataObj.config && (dataObj.config = {});
      !dataObj.graphics && (dataObj.graphics = {});
      config = dataObj.config;
      if (setData && !setData.vline) {
        config.setLink = (0, _lib.pluck)(setData.link);
        open = config.open = numberFormatter.getCleanValue(setData.open);
        close = config.close = numberFormatter.getCleanValue(setData.close);
        high = numberFormatter.getCleanValue(setData.high);
        low = numberFormatter.getCleanValue(setData.low);
        config.volume = numberFormatter.getCleanValue(setData.volume, true);
        x = config.x = numberFormatter.getCleanValue(setData.x);
        config.high = Math.max(open, close, high, low);
        config.low = Math.min(open, close, high, low);
        config.yVal = Math.max(open, close);
        minValue = Math.min(open, close, high, low);
        maxValue = Math.max(open, close, high, low);

        // valueText = parseUnsafeString(getValidValue(setData.valuetext, BLANK));

        setBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.bordercolor, close < open ? bearBorderColor : bullBorderColor));

        setAlpha = (0, _lib.pluckNumber)(setData.alpha, 100);
        setColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.color, close < open ? bearFillColor : bullFillColor));

        config.color = isCandleStick ? setColor : setBorderColor;
        config.alpha = setAlpha;
        /*
         * Storing the set level color and set level alpha which is required in drawing of line
         * In line we are checking setColor and setAlpha of current line segment is same as the previous
         * line segment's setColor and setAlpha by accesing config.setColor and config.setAlpha
         */
        config.setColor = config.color;
        config.setAlpha = config.alpha;
        // Finally add the data
        // we call getPointStub function that manage displayValue, toolText and link
        config.borderColor = setBorderColor;
        config.borderAlpha = config.plotLineAlpha;
        config.colorArr = [{
          color: config.color,
          alpha: config.alpha
        }, {
          color: config.borderColor,
          alpha: config.borderAlpha
        }];
        config.showValue = 1;
        config.hoverEffects = {};
        config.link = (0, _lib.pluck)(setData.link);
        config.setValue = config.y;

        if (minValue !== null) {
          yMax = Math.max(yMax, minValue);
          yMin = Math.min(yMin, minValue);
        }
        if (maxValue !== null) {
          yMax = Math.max(yMax, maxValue);
          yMin = Math.min(yMin, maxValue);
        }
        if (x !== null) {
          xMax = Math.max(xMax, x);
          xMin = Math.min(xMin, x);
        }
        config.dashStyle = (0, _lib.pluckNumber)(setData.dashed) ? (0, _lib.getDashStyle)(plotLineDashLen, plotLineDashGap) : DASH_DEF;
        config.shadow = {
          opacity: setAlpha / 100
        };
        x = x !== null ? x : index + 1;
        config.toolText = dataset._parseToolText(index);
        config.toolTipValue = '';
        config._x = x;
        config.y = open;
        config.previousY = close;
      }
    }
    conf.yMax = yMax;
    conf.yMin = yMin;
    conf.xMax = xMax;
    conf.xMin = xMin;
    dataset.setState('dirty', true);
  };
  /**
   * functioto draw and update the graphics elements of plots
   * @param {Object} anim    - object reference of animation manager argument
   *                           consist of elements and their configuration
   */


  CandleStickBar.prototype.drawPlots = function drawPlots() {
    var dataset = this,
        config,
        animationManager = dataset.getFromEnv('animationManager'),
        conf = dataset.config,
        components = dataset.components,
        data = components.data,
        length = data.length,
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),
        xPosOffset,

    // key,
    i,
        set,
        setLink,
        x,
        y,
        previousY,
        xPos,
        yPos,
        previousYPos,
        setElem,
        bars,
        applyShadow = function applyShadow(shadow) {
      return function () {
        this.shadow(shadow);
      };
    },
        trackerTolerance = conf.linethickness > 5 ? conf.linethickness / 2 : 2.5,
        container = dataset.getContainer('plotGroup'),

    // hotElem,
    visible = dataset.getState('visible'),

    // targetGroup,
    highPos,
        lowPos,
        halfW,
        path,
        graphics;
    animationManager.setAnimation({
      el: container,
      attr: {
        opacity: visible ? 1 : 0
      },
      component: dataset
    });

    dataset.setColumnPosition();
    xPosOffset = dataset.getFromEnv('columnXShift');

    // draw plots
    for (i = 0; i < length; i += 1) {
      set = data[i];
      config = set.config;
      graphics = set.graphics;
      y = config.y;
      setElem = null;

      if (y === null) {
        setElem = graphics.element;
      } else {
        // when valid value
        x = config._x;
        setLink = config.link;
        config.setLink = config.link;
        // fixedWidth = config._FCW * groupMaxWidth;

        xPos = xAxis.getPixel(x);
        previousY = config.previousY;
        previousYPos = yAxis.getPixel(previousY);
        yPos = yAxis.getPixel(y);
        highPos = yAxis.getPixel(config.high);
        lowPos = yAxis.getPixel(config.low);
        halfW = xPosOffset;
        set.errorBar = [];
        bars = set.errorBar;
        bars.push([{
          _xPos: xPos - trackerTolerance,
          _yPos: highPos,
          _height: Math.abs(highPos - lowPos),
          _width: 2 * trackerTolerance
        }, {
          _xPos: xPos + halfW,
          _yPos: yPos,
          _height: 2 * trackerTolerance,
          _width: Math.abs(halfW)
        }, {
          _xPos: xPos,
          _yPos: previousYPos,
          _height: 2 * trackerTolerance,
          _width: Math.abs(halfW)
        }]);

        path = [M, xPos, lowPos, L, xPos, highPos, M, xPos, yPos, L, xPos + halfW, yPos, M, xPos, previousYPos, L, xPos - halfW, previousYPos];
        setElem = graphics.element;
        setElem = animationManager.setAnimation({
          el: setElem || 'path',
          container: dataset,
          attr: {
            'path': path,
            'cursor': setLink ? POINTER : BLANKSTRING,
            fill: (0, _lib.toRaphaelColor)(config.color),
            stroke: (0, _lib.toRaphaelColor)(config.borderColor),
            'stroke-width': conf.linethickness,
            'stroke-dasharray': config.dashStyle,
            'stroke-linecap': ROUND,
            'stroke-linejoin': ROUND,
            'shape-rendering': 'crisp',
            'visibility': visibleStr
          },
          dom: 'path',
          component: dataset,
          callback: applyShadow.call(setElem, config.shadow)
        });
      }
    }
  };
  /**
   * parse tooltext from the dataset json
   * @param {number} i index of data
   * @return {string} tooltext
   */


  CandleStickBar.prototype._parseToolText = function _parseToolText(i) {
    return _candlestick._parseToolText.call(this, i);
  };
  /**
   * This method handles all mouse events of an dataset.
   * @param {string} eventType    name of the event
   * @param {number} plotIndex    index of the plot where this event has been occured
   * @param {Event}  e            reference of the original mouse event
   */


  CandleStickBar.prototype._firePlotEvent = function _firePlotEvent(eventType, plotIndex, e) {
    _candlestick._firePlotEvent.call(this, eventType, plotIndex, e);
  };
  /**
   * function to check if given x,y coordiante is over a column plot or not
   */
  // eslint-disable-next-line


  CandleStickBar.prototype._checkPointerOverColumn = function _checkPointerOverColumn() {};
  /**
   * Function that retunr the nearest plot details
   * @param {number} chartX x-axis position of the mouse cordinate
   * @param {number} chartY y-axis position of the mouse cordinate
   * @return {Object} return an object with details of nearest polt and whether it is hovered or not
   */


  CandleStickBar.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        xAxis = dataset.getFromEnv('xAxis'),
        x,
        i,
        hoveredInfo,
        pXs,
        pX;

    x = xAxis.getValue(chartX);
    pXs = _candlestick.getPlotIndices.call(dataset, x);

    // Checking for overlap between two cosecutive column plots along x-axis
    for (i = pXs.length - 1; i > -1; i--) {
      pX = pXs[i];
      hoveredInfo = pX - x > 0 ? dataset._checkPointerOverPlot(pX, chartX, chartY) || dataset._checkPointerOverPlot(pX - 1, chartX, chartY) : dataset._checkPointerOverPlot(pX + 1, chartX, chartY) || dataset._checkPointerOverPlot(pX, chartX, chartY);
      if (hoveredInfo) {
        break;
      }
    }
    return hoveredInfo;
  };
  /**
   * Helper function of _getHoverPlot fn
   * @param {number} pX     x index value
   * @param {number} chartX x-axis position of the mouse cordinate
   * @param {number} chartY y-axis position of the mouse cordinate
   * @return {Object}       return hover information
   */


  CandleStickBar.prototype._checkPointerOverPlot = function _checkPointerOverPlot(pX, chartX, chartY) {
    return _errorbar2d._checkPointerOverPlot.call(this, pX, chartX, chartY);
  };
  /**
   * Helper function of _checkPointerOverPlot fn
   * @param {number} pX     x index value
   * @param {number} chartX x-axis position of the mouse cordinate
   * @param {number} chartY y-axis position of the mouse cordinate
   * @return {Object}       return hover information
   */


  CandleStickBar.prototype._checkPointerOverErrorBar = function _checkPointerOverErrorBar(pX, chartX, chartY) {
    return _errorbar2d._checkPointerOverErrorBar.call(this, pX, chartX, chartY);
  };
  /**
    * This function overrides drawlabel method
    * it prevents the label drawing
    */
  // eslint-disable-next-line


  CandleStickBar.prototype.drawLabel = function drawLabel() {};
  /**
   * Function to get the maximum and minimum from dataset
   * @return {Object}     contains max, min value
   */


  CandleStickBar.prototype.getDataLimits = function getDataLimits() {
    var conf = this.config;
    return {
      max: conf.yMax,
      min: conf.yMin,
      xMax: conf.xMax,
      xMin: conf.xMin
    };
  };
  /**
   * Returns the name of the component
   *
   * @return {string} The name of the component
   */


  CandleStickBar.prototype.getName = function getName() {
    return 'candlestickbar';
  };

  return CandleStickBar;
}(_column2['default']);

exports['default'] = CandleStickBar;

/***/ }),

/***/ 886:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = {
  'initial.dataset.candlestickbar': function initialDatasetCandlestickbar() {
    return {
      'path.appearing': function pathAppearing() {
        return [{
          initialAttr: {
            opacity: 1,
            'stroke-width': 1
          },
          finalAttr: {
            opacity: 1
          }
        }];
      },
      '*': null
    };
  }
};

/***/ }),

/***/ 887:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _line = __webpack_require__(12);

var _line2 = _interopRequireDefault(_line);

var _candlestick = __webpack_require__(146);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var colorStrings = _lib.preDefStr.colors,
    COLOR_B90000 = colorStrings.B90000,
    COLOR_FFFFFF = colorStrings.FFFFFF,
    UNDERSCORE = '_',
    BLANK = '',
    ZEROSTRING = '0',
    HUNDRED = '100';

/**
 * Class def for bull stick chart API
 * This dataset is reponsible for drawing stick depending on high and open value
 */

var CandleStickline = function (_Line) {
  _inherits(CandleStickline, _Line);

  function CandleStickline() {
    _classCallCheck(this, CandleStickline);

    return _possibleConstructorReturn(this, _Line.apply(this, arguments));
  }

  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * This function is called once from the init() function of the Column class.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} Indicates whether the configuration was successful or not
    */
  CandleStickline.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.config.JSONData = datasetJSON;

    var dataset = this,
        conf = dataset.config,
        JSONData = dataset.config.JSONData,
        dataArr = JSONData.data || [],
        chartAttr = dataset.getFromEnv('chart-attrib'),
        dataLength = dataArr.length,
        numberFormatter = dataset.getFromEnv('number-formatter'),
        colorM = dataset.getFromEnv('color-manager'),
        setColor,
        setBorderColor,
        setAlpha,
        dashStyle,

    // Candle stick properties.
    // Bear fill and border color - (Close lower than open)
    bearBorderColor = conf.bearBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bearbordercolor, COLOR_B90000)),
        bearFillColor = conf.bearFillColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bearfillcolor, COLOR_B90000)),

    // Bull fill and border color - Close higher than open
    bullBorderColor = conf.bullBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bullbordercolor, colorM.getColor('canvasBorderColor'))),
        bullFillColor = conf.bullFillColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.bullfillcolor, COLOR_FFFFFF)),

    // Line Properties - Serves as line for bar & line and border for candle stick
    plotLineThickness = conf.linethickness = conf.plotBorderThickness = (0, _lib.pluckNumber)(chartAttr.plotlinethickness, 2),
        plotLineDashLen = conf.plotLineDashLen = (0, _lib.pluckNumber)(chartAttr.plotlinedashlen, 5),
        plotLineDashGap = conf.plotLineDashGap = (0, _lib.pluckNumber)(chartAttr.plotlinedashgap, 4),

    // Anchor cosmetics in data points
    // Getting anchor cosmetics for the data points or its default values
    // The default value is different from flash in order to render a
    // perfect circle when no anchorside is provided.
    drawAnchors = !!(0, _lib.pluckNumber)(chartAttr.drawanchors, 0),
        setAnchorAngle = (0, _lib.pluckNumber)(chartAttr.anchorstartangle, 90),
        setAnchorRadius = (0, _lib.pluckNumber)(chartAttr.anchorradius, this.anchorRadius, 3),
        setAnchorBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.anchorbordercolor, bullBorderColor)),
        setAnchorBorderThickness = (0, _lib.pluckNumber)(chartAttr.anchorborderthickness, this.anchorBorderThickness, 1),
        setAnchorBgColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.anchorbgcolor, colorM.getColor('anchorBgColor'))),
        setAnchorAlpha = (0, _lib.pluck)(chartAttr.anchoralpha, ZEROSTRING),
        setAnchorBgAlpha = (0, _lib.pluck)(chartAttr.anchorbgalpha, setAnchorAlpha),
        pointShadow,
        index,
        dataObj,
        open,
        close,
        high,
        low,
        minValue,
        maxValue,
        x,
        dataStore,
        setData,
        config,
        isCandleStick = false,
        plotSpacePercent,
        yMax = -Infinity,
        yMin = +Infinity,
        xMax = -Infinity,
        xMin = +Infinity,
        userMaxColWidth,
        enableAnimation,
        mapSymbolName = _lib.graphics.mapSymbolName;
    dataset.setState('visible', (0, _lib.pluckNumber)(JSONData.visible, 1) === 1);

    dataset._conatinerHidden = !!dataset.getState('visible');
    conf.defaultPadding = {
      left: 0.5,
      right: 0.5
    };
    conf.plotType = 'line';
    conf.parentYAxis = 0;
    conf.toolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(JSONData.tooltext, chartAttr.plottooltext)));
    // Dataset seriesname
    conf.name = (0, _lib.getValidValue)(JSONData.seriesname);
    conf.showTooltip = (0, _lib.pluck)(chartAttr.showtooltip, 1);

    userMaxColWidth = (0, _lib.pluck)(chartAttr.maxcolwidth);
    conf.maxColWidth = Math.abs((0, _lib.pluckNumber)(userMaxColWidth, 50)) || 1;
    // Animation related attributes configuration
    conf.enableAnimation = enableAnimation = (0, _lib.pluckNumber)(chartAttr.animation, chartAttr.defaultanimation, 1);
    conf.animation = !enableAnimation ? false : {
      duration: (0, _lib.pluckNumber)(chartAttr.animationduration, 1) * 1000
    };
    conf.lineAlpha = (0, _lib.pluck)(chartAttr.plotlinealpha, HUNDRED);
    plotSpacePercent = Math.max((0, _lib.pluckNumber)(chartAttr.plotspacepercent, 20) % 100, 0);
    conf.plotSpacePercent = conf.groupPadding = plotSpacePercent / 200;
    dataStore = dataset.components.data = dataset.components.data || (dataset.components.data = []);
    conf.valuePadding = (0, _lib.pluckNumber)(JSONData.valuepadding, chartAttr.valuepadding, 2);
    conf.plotBorderThickness = plotLineThickness;
    conf.showvalues = 1;
    // // Anchor cosmetics attributes in dataset level
    // conf.anchorstartangle = pluckNumber(chartAttr.anchorstartangle, 90);
    // conf.anchorradius = pluckNumber(chartAttr.anchorradius,
    //               this.anchorRadius, 3);
    // conf.anchorbordercolor = getFirstColor(pluck(chartAttr.anchorbordercolor,
    //               bullBorderColor));
    // conf.anchorborderthickness = pluckNumber(chartAttr.anchorborderthickness,
    //           this.anchorBorderThickness, 1);
    // conf.anchorbgcolor = getFirstColor(pluck(chartAttr.anchorbgcolor,
    //               colorM.getColor('anchorBgColor')));
    // conf.nchorAlpha = pluck(chartAttr.anchoralpha, '0');
    // conf.anchorBgAlpha = pluck(chartAttr.anchorbgalpha, conf.anchorAlpha);
    // conf.drawanchors = pluckNumber(JSONData.drawanchors, JSONData.showanchors,
    //   chartAttr.showanchors, chartAttr.drawanchors);
    // Iterate through all level data
    for (index = 0; index < dataLength; index += 1) {
      // Individual data obj
      // for further manipulation
      setData = dataArr[index];
      dataObj = dataStore[index];
      if (!dataObj) {
        dataObj = dataStore[index] = {};
      }
      !dataObj.config && (dataObj.config = {});
      !dataObj.graphics && (dataObj.graphics = {});
      config = dataObj.config;
      if (setData && !setData.vline) {
        config.setLink = (0, _lib.pluck)(setData.link);
        open = config.open = numberFormatter.getCleanValue(setData.open);
        close = config.close = numberFormatter.getCleanValue(setData.close);
        high = config.high = numberFormatter.getCleanValue(setData.high);
        low = config.low = numberFormatter.getCleanValue(setData.low);
        config.volume = numberFormatter.getCleanValue(setData.volume, true);

        x = config.x = numberFormatter.getCleanValue(setData.x);
        // openVal = config.openVal = isCandleStick ? Math.abs(close - open) : open;
        config.closeVal = Math.min(open, close);
        config.yVal = Math.max(open, close);
        minValue = Math.min(open, close, high, low);
        maxValue = Math.max(open, close, high, low);

        // valueText = parseUnsafeString(getValidValue(setData.valuetext, BLANK));

        setBorderColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.bordercolor, close < open ? bearBorderColor : bullBorderColor));
        setAlpha = (0, _lib.pluck)(setData.alpha, conf.lineAlpha);
        setColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.color, close < open ? bearFillColor : bullFillColor));
        dashStyle = (0, _lib.pluckNumber)(setData.dashed) ? (0, _lib.getDashStyle)(plotLineDashLen, plotLineDashGap) : 'none';
        config.dashStyle = dashStyle;
        // Set alpha of the shadow
        pointShadow = {
          opacity: setAlpha / 100
        };
        config.color = isCandleStick ? setColor : setBorderColor;
        config.alpha = setAlpha;
        /*
         * Storing the set level color and set level alpha which is required in drawing of line
         * In line we are checking setColor and setAlpha of current line segment is same as the previous
         * line segment's setColor and setAlpha by accesing config.setColor and config.setAlpha
         */
        config.setColor = config.color;
        config.setAlpha = config.alpha;
        config.anchorImageUrl = (0, _lib.pluck)(setData.anchorimageurl, JSONData.anchorimageurl, chartAttr.anchorimageurl);
        // Finally add the data
        // we call getPointStub function that manage displayValue, toolText and link
        config.borderColor = setBorderColor;
        config.borderAlpha = config.plotLineAlpha;
        config.colorArr = [{
          color: config.color,
          alpha: config.alpha
        }, {
          color: config.borderColor,
          alpha: config.borderAlpha
        }];
        config.anchorSides = (0, _lib.pluckNumber)(setData.anchorsides, JSONData.anchorsides, chartAttr.anchorsides);
        config.symbol = mapSymbolName(config.anchorSides).split(UNDERSCORE);
        config.anchorProps = {
          enabled: drawAnchors,
          bgColor: setAnchorBgColor,
          symbol: config.symbol,
          bgAlpha: setAnchorBgAlpha * setAnchorAlpha / 100 + BLANK,
          borderColor: setAnchorBorderColor,
          borderAlpha: setAnchorAlpha,
          anchorAlpha: setAnchorAlpha,
          borderThickness: setAnchorBorderThickness,
          imageUrl: config.anchorImageUrl,
          radius: setAnchorRadius,
          imageScale: (0, _lib.pluckNumber)(setData.imagescale, JSONData.imagescale, chartAttr.imagescale, 100),
          imagePadding: (0, _lib.pluckNumber)(setData.anchorimagepadding, JSONData.anchorimagepadding, chartAttr.anchorimagepadding, 1),
          imageAlpha: (0, _lib.pluckNumber)(JSONData.anchorimagealpha, chartAttr.anchorimagealpha, 100),
          startAngle: setAnchorAngle
        };
        config.showValue = 1;
        config.hoverEffects = {};
        config.anchorSides = (0, _lib.pluckNumber)(setData.anchorsides, JSONData.anchorsides, chartAttr.anchorsides);
        config.symbol = mapSymbolName(config.anchorSides).split(UNDERSCORE);

        config.hoverEffects = {};
        config.y = close;
        config.link = (0, _lib.pluck)(setData.link);
        config.toolText = dataset._parseToolText(index);
        config.toolTipValue = '';
        config.setValue = config._y = config.y;
        config.displayValue = (0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.displayvalue, setData.valuetext, BLANK));
        if (minValue !== null) {
          yMax = Math.max(yMax, minValue);
          yMin = Math.min(yMin, minValue);
        }
        if (maxValue !== null) {
          yMax = Math.max(yMax, maxValue);
          yMin = Math.min(yMin, maxValue);
        }
        if (x !== null) {
          xMax = Math.max(xMax, x);
          xMin = Math.min(xMin, x);
        }
        x = x || index + 1;
        config._x = config.x = x;

        config.high = Math.max(open, close, high, low);
        config.low = Math.min(open, close, high, low);
        config.shadow = pointShadow;
      }
    }
    conf.yMax = yMax;
    conf.yMin = yMin;
    conf.xMax = xMax;
    conf.xMin = xMin;
    dataset.setState('dirty', true);
  };
  /**
   * calculate min and max position to scroll
   */


  CandleStickline.prototype.calculateScrollRange = function calculateScrollRange() {
    var dataset = this,
        conf = dataset.config,
        dataLen = dataset.components.data && dataset.components.data.length;
    conf.scrollMinVal = conf.scrollMinValForLabel = 0;
    conf.scrollMaxVal = conf.scrollMaxValForLabel = dataLen;
  };
  /**
   * Function to get the maximum and minimum from dataset
   * @return {Object}     contains max, min value
   */


  CandleStickline.prototype.getDataLimits = function getDataLimits() {
    var conf = this.config;
    return {
      max: conf.yMax,
      min: conf.yMin,
      xMax: conf.xMax,
      xMin: conf.xMin
    };
  };
  /**
   * fetches data indices wrt. the x pos value
   * @param {number} x  x pos value
   * @return {Array}    contains indices
   */


  CandleStickline.prototype.getPlotIndices = function getPlotIndices(x) {
    var dataset = this,
        i,
        minX = Math.floor(x),
        maxX = Math.ceil(x),
        data,
        returnIndices = [],
        sortedData = dataset.config.JSONData && dataset.config.JSONData.data;

    for (i = sortedData.length; i--;) {
      data = sortedData[i];
      if (data.x >= minX && data.x <= maxX) {
        returnIndices.push(i);
      }
    }
    return returnIndices;
  };
  /**
   * parse tooltext from the dataset json
   * @param {number} i index of data
   * @return {string} tooltext
   */


  CandleStickline.prototype._parseToolText = function _parseToolText(i) {
    return _candlestick._parseToolText.call(this, i);
  };
  /**
   * Function that retunr the nearest plot details
   * @param {number} chartX x-axis position of the mouse cordinate
   * @param {number} chartY x-axis position of the mouse cordinate
   * @return {Object} return an object with details of nearest polt and whether it is hovered or not
   */
  /**
   * Function that return the nearest plot details
   * @param   {number} chartX x-axis position of the mouse cordinate
   * @param   {number} chartY y-axis position of the mouse cordinate
   * @return {Object} return an object with details of nearest plot and whether it is
   *                   hovered or not
   */


  CandleStickline.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        xAxis = dataset.getFromEnv('xAxis'),
        components = dataset.components,
        dataStore = components.dataRT || components.data,
        pointObj,
        pXs,
        xMin,
        xMax,
        len = dataStore.length,
        returnValue,
        conf = dataset.config,
        i,
        maxRadius = conf && conf.radius || 0;

    // getting new chart XY accordint to Translation of axis
    chartX += xAxis.getTranslation();

    pXs = dataset.getPlotIndices(Math.floor(Math.max(xAxis.getValue(chartX - maxRadius), 0)));
    xMin = pXs[0];
    pXs = dataset.getPlotIndices(Math.ceil(Math.min(xAxis.getValue(chartX + maxRadius), len - 1)));
    xMax = pXs[pXs.length - 1];

    var _ref = xMin > xMax ? [xMax, xMin] : [xMin, xMax];

    xMin = _ref[0];
    xMax = _ref[1];


    for (i = xMax; i >= xMin; i--) {
      pointObj = dataStore[i];
      if (pointObj) {
        returnValue = dataset.isWithinShape(pointObj, i, chartX, chartY);
        if (returnValue) {
          break;
        }
      }
    }

    return returnValue;
  };
  /**
   * Returns the name of the component
   *
   * @return {string} The name of the component
   */


  CandleStickline.prototype.getName = function getName() {
    return 'candlestickline';
  };

  return CandleStickline;
}(_line2['default']);

exports['default'] = CandleStickline;

/***/ }),

/***/ 888:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(216);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _radar = __webpack_require__(889);

var _radar2 = _interopRequireDefault(_radar);

var _radarAxis = __webpack_require__(891);

var _radarAxis2 = _interopRequireDefault(_radarAxis);

var _polarCanvas = __webpack_require__(894);

var _polarCanvas2 = _interopRequireDefault(_polarCanvas);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


/**
 * Creates radar class
 * @class
 */
var Radar = function (_Area) {
  _inherits(Radar, _Area);

  /**
   * constructor fn
   */
  function Radar() {
    _classCallCheck(this, Radar);

    var _this = _possibleConstructorReturn(this, _Area.call(this));

    _this.registerFactory('canvas', _polarCanvas2['default']);
    _this.registerFactory('axis', _radarAxis2['default'], ['canvas']);
    return _this;
  }
  /**
   * Sets the default configuration
   */


  Radar.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _Area.prototype.__setDefaultConfig && _Area.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.axisType = 'polar';
    config.axisValuePadding = 10;
    config.gridLineWidth = 1;
    config.showRadarBorder = 1;
    config.showvalues = 0;
    config.radarBorderThickness = 2;
    config.skipCanvasDrawing = true;
    config.useplotgradientcolor = 0;
    config.plotfillalpha = 50;
  };
  /**
   * Sets dimension of Axis components
   */


  Radar.prototype.setAxisDimention = function setAxisDimention() {
    var iapi = this,
        yAxis = iapi.getChildren('yAxis') && iapi.getChildren('yAxis')[0],
        config = iapi.config;

    yAxis && yAxis.setAxisDimention({
      x: config.canvasLeft + config.canvasWidth / 2,
      y: config.canvasTop,
      axisLength: config.canvasHeight / 2
    });
  };
  /**
   * function to parse JSON data for configurations of axis
   * @return {Object} configurations of axes
   */


  Radar.prototype._feedAxesRawData = function _feedAxesRawData() {
    var iapi = this,
        chartConfig = iapi.config,
        colorM = iapi.getFromEnv('color-manager'),
        dataObj = iapi.getFromEnv('dataSource'),
        chartAttrs = dataObj.chart,
        isReverse = chartConfig.isInverse,
        xAxisConf,
        yAxisConf,
        is3D = iapi.config.is3D,
        palleteString = _lib.chartPaletteStr.chart2D;

    xAxisConf = {
      isVertical: false,
      isReverse: chartConfig.reverseXAxis,
      isOpposit: false,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.xaxisnamepadding,
      axisValuePadding: chartAttrs.labelpadding,
      axisNameFont: chartAttrs.xaxisnamefont,
      axisNameFontSize: chartAttrs.xaxisnamefontsize,
      axisNameFontColor: chartAttrs.xaxisnamefontcolor,
      axisNameFontBold: chartAttrs.xaxisnamefontbold,
      axisNameFontItalic: chartAttrs.xaxisnamefontitalic,
      axisNameBgColor: chartAttrs.xaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.xaxisnamebordercolor,
      axisNameAlpha: chartAttrs.xaxisnamealpha,
      axisNameFontAlpha: chartAttrs.xaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.xaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.xaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.xaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.xaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.xaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.xaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.xaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.xaxisnameborderdashgap,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      divLineColor: (0, _lib.pluck)(chartAttrs.vdivlinecolor, chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.vdivlinealpha, chartAttrs.divlinealpha, is3D ? colorM.getColor('divLineAlpha3D') : colorM.getColor('divLineAlpha')),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.vdivlinethickness, chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.vdivlinedashed, chartAttrs.vdivlineisdashed, chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashlen, chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashgap, chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatevgridcolor, 1),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatevgridcolor, colorM.getColor('altVGridColor')),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatevgridalpha, colorM.getColor('altVGridAlpha')),
      numDivLines: chartAttrs.numvdivlines,
      labelFont: chartAttrs.labelfont,
      labelFontSize: chartAttrs.labelfontsize,
      labelFontColor: chartAttrs.labelfontcolor,
      labelFontAlpha: chartAttrs.labelalpha,
      labelFontBold: chartAttrs.labelfontbold,
      labelFontItalic: chartAttrs.labelfontitalic,
      axisName: chartAttrs.yaxisname,
      axisMinValue: chartAttrs.xaxisminvalue,
      axisMaxValue: chartAttrs.xaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptivexmin,
      adjustDiv: chartAttrs.adjustvdiv,
      labelDisplay: chartAttrs.labeldisplay,
      showLabels: chartAttrs.showlabels,
      rotateLabels: chartAttrs.rotatelabels,
      slantLabel: (0, _lib.pluckNumber)(chartAttrs.slantlabels, chartAttrs.slantlabel),
      labelStep: (0, _lib.pluckNumber)(chartAttrs.labelstep, chartAttrs.xaxisvaluesstep),
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showxaxisvalues, chartAttrs.showxaxisvalue),
      showLimits: chartAttrs.showvlimits,
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showvdivlinevalues, chartAttrs.showvdivlinevalues),
      zeroPlaneColor: chartAttrs.vzeroplanecolor,
      zeroPlaneThickness: chartAttrs.vzeroplanethickness,
      zeroPlaneAlpha: chartAttrs.vzeroplanealpha,
      showZeroPlaneValue: chartAttrs.showvzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showxaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.xaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.xaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.xaxislinecolor, chartAttrs.axislinecolor, '#000000'),

      showRadarBorder: chartAttrs.showradarborder,
      radarBorderColor: chartAttrs.radarbordercolor,
      radarBorderThickness: chartAttrs.radarborderthickness,
      radarBorderAlpha: chartAttrs.radarborderalpha,
      radarFillColor: chartAttrs.radarfillcolor,
      radarFillAlpha: chartAttrs.radarfillalpha,
      radarSpikeColor: chartAttrs.radarspikecolor,
      radarSpikeThickness: chartAttrs.radarspikethickness,
      radarSpikeAlpha: chartAttrs.radarspikealpha,
      radarInLineAlpha: chartAttrs.radarinlinealpha
    };
    yAxisConf = {
      isVertical: true,
      isReverse: !isReverse,
      isOpposit: false,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.yaxisnamepadding,
      axisValuePadding: chartAttrs.yaxisvaluespadding,
      axisNameFont: chartAttrs.yaxisnamefont,
      axisNameFontSize: chartAttrs.yaxisnamefontsize,
      axisNameFontColor: chartAttrs.yaxisnamefontcolor,
      axisNameFontBold: chartAttrs.yaxisnamefontbold,
      axisNameFontItalic: chartAttrs.yaxisnamefontitalic,
      axisNameBgColor: chartAttrs.yaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.yaxisnamebordercolor,
      axisNameAlpha: chartAttrs.yaxisnamealpha,
      axisNameFontAlpha: chartAttrs.yaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.yaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.yaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.yaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.yaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.yaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.yaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.yaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.yaxisnameborderdashgap,
      axisNameWidth: chartAttrs.yaxisnamewidth,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      rotateAxisName: (0, _lib.pluckNumber)(chartAttrs.rotateyaxisname, 1),
      axisName: chartAttrs.xaxisname,
      divLineColor: (0, _lib.pluck)(chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.divlinealpha, colorM.getColor('divLineAlpha')),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatehgridcolor, 1),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatehgridcolor, colorM.getColor('altHGridColor')),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatehgridalpha, colorM.getColor('altHGridAlpha')),
      numDivLines: chartAttrs.numdivlines,
      axisMinValue: chartAttrs.yaxisminvalue,
      axisMaxValue: chartAttrs.yaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptiveymin,
      adjustDiv: chartAttrs.adjustvdiv,
      labelStep: chartAttrs.yaxisvaluesstep,
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue),
      showLimits: (0, _lib.pluckNumber)(chartAttrs.showyaxislimits, chartAttrs.showlimits, iapi.showLimits),
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showdivlinevalues, chartAttrs.showdivlinevalue),
      // showZeroPlane: chartAttrs.showzeroplane,
      zeroPlaneColor: chartAttrs.zeroplanecolor,
      zeroPlaneThickness: (0, _lib.pluckNumber)(chartAttrs.zeroplanethickness, chartAttrs.divlinethickness, 2),
      zeroPlaneAlpha: chartAttrs.zeroplanealpha,
      showZeroPlaneValue: chartAttrs.showzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: (0, _lib.pluckNumber)(chartAttrs.showyaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.yaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.yaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.yaxislinecolor, chartAttrs.axislinecolor, '#000000')
    };
    xAxisConf.vtrendlines = dataObj.vtrendlines;
    yAxisConf.trendlines = dataObj.trendlines;
    return {
      xAxisConf: [xAxisConf],
      yAxisConf: [yAxisConf]
    };
  };

  /**
   * space manager for radar
   */


  Radar.prototype._spaceManager = function _spaceManager() {
    // todo marge _allocateSpace and _spacemanager
    var spaceForActionBar,
        actionBarSpace,
        availableWidth,
        availableHeight,
        iapi = this,
        config = iapi.config,

    // components = iapi.components,
    radarBorderThickness = config.radarBorderThickness,
        legendPosition = config.legendPosition,
        xAxis = iapi.getChildren('xAxis') && iapi.getChildren('xAxis')[0],
        yAxisArr = iapi.getChildren('yAxis') && iapi.getChildren('yAxis') || [],
        yAxis = yAxisArr[0],
        hasLegend = config.hasLegend,
        legend = iapi.getChildren('legend') && iapi.getChildren('legend')[0],
        allottedSpace,
        minLength,
        decreaseCanvasBy,
        POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
        math = Math,
        mathMin = math.min,
        mathAbs = math.abs;

    if (legendPosition === POSITION_BOTTOM) {
      allottedSpace = config.canvasHeight * 0.3;
    } else {
      allottedSpace = config.canvasWidth * 0.3;
    }
    // No space is allocated for legend drawing in single series charts
    hasLegend !== false && xAxis && config.showLegend && iapi._allocateSpace(legend._manageLegendPosition(allottedSpace));

    availableHeight = config.canvasHeight * 0.7;
    availableWidth = config.canvasWidth * 0.7;
    xAxis && iapi._allocateSpace(xAxis.placeAxis(availableWidth, availableHeight));
    //* ***** Manage space
    availableWidth = config.canvasWidth * 0.7;
    yAxis && yAxis.placeAxis(availableWidth);

    spaceForActionBar = config.availableHeight * 0.225;
    actionBarSpace = iapi._manageActionBarSpace && (iapi._manageActionBarSpace(spaceForActionBar) || {});
    iapi._allocateSpace(actionBarSpace);

    // for rader make the canvas square with the minimum of width and height
    minLength = config.radarradius > 0 ? config.radarradius * 2 : mathMin(config.canvasHeight, config.canvasWidth);
    if (config.canvasHeight > minLength) {
      decreaseCanvasBy = mathAbs((config.canvasHeight - minLength) / 2);
      iapi._allocateSpace({
        top: decreaseCanvasBy,
        bottom: decreaseCanvasBy
      });
    }
    if (config.canvasWidth > minLength) {
      decreaseCanvasBy = mathAbs((config.canvasWidth - minLength) / 2);
      iapi._allocateSpace({
        left: decreaseCanvasBy,
        right: decreaseCanvasBy
      });
    }

    availableHeight = legendPosition === POSITION_BOTTOM ? config.availableHeight * 0.6 : config.availableWidth * 0.6;
    // a space manager that manages the space for the tools as well as the captions.
    iapi._manageChartMenuBar(availableHeight);

    yAxis.setAxisDimention({
      x: config.canvasLeft + config.canvasWidth / 2 - radarBorderThickness / 2,
      y: config.canvasTop,
      axisLength: config.canvasHeight / 2
    });

    xAxis.setAxisConfig({
      radius: mathMin(config.canvasWidth / 2, config.canvasHeight / 2) - radarBorderThickness / 2
    });
    xAxis.setAxisDimention({
      x: config.canvasLeft + config.canvasWidth / 2,
      y: config.canvasTop + config.canvasHeight / 2
    });
  };

  /**
   * Sets the name of the component
   * @return {string} name
   */


  Radar.getName = function getName() {
    return 'Radar';
  };
  /**
   * This method return the dataset definations for this charts
   * @return {string} dataset defination
   */


  Radar.prototype.getDSdef = function getDSdef() {
    return _radar2['default'];
  };

  return Radar;
}(_fusioncharts2['default']);

exports['default'] = Radar;

/***/ }),

/***/ 889:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _area = __webpack_require__(23);

var _area2 = _interopRequireDefault(_area);

var _find = __webpack_require__(297);

var _find2 = _interopRequireDefault(_find);

var _radarAnimation = __webpack_require__(890);

var _radarAnimation2 = _interopRequireDefault(_radarAnimation);

var _dependencyManager = __webpack_require__(6);

var _polarUtil = __webpack_require__(93);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var COMMASTRING = ',',
    UNDEF,
    M = 'M',
    L = 'L',
    Z = 'Z',
    dropHash = _lib.regex.dropHash,
    getLightColor = _lib.graphics.getLightColor;
(0, _dependencyManager.addDep)({
  name: 'radarAnimation',
  type: 'animationRule',
  extension: _radarAnimation2['default']
});
/**
 * Creates the Radar Dataset
 * @class
 */

var RadarDataset = function (_AreaDataset) {
  _inherits(RadarDataset, _AreaDataset);

  function RadarDataset() {
    _classCallCheck(this, RadarDataset);

    return _possibleConstructorReturn(this, _AreaDataset.apply(this, arguments));
  }

  /**
   * return name
   * @return {string} - component name
   */
  RadarDataset.prototype.getName = function getName() {
    return 'radar';
  };
  /**
   * Create pixel coordinates for the plots
   */


  RadarDataset.prototype.createCoordinates = function createCoordinates() {
    var dataSet = this,
        dsComponents = dataSet.components,
        dsData = dsComponents.data,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        yAxis = dataSet.getFromEnv('yAxis'),
        xAxis = dataSet.getFromEnv('xAxis'),
        dataObj,
        config,
        previousY,
        i,
        Px,
        Py,
        len = dsData.length,
        components = dataSet.components,
        dataStore = components.data,
        xPos,
        yPos,
        setValue;
    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;
      setValue = config.setValue;

      if (dataObj === UNDEF) {
        continue;
      }

      yPos = yAxis.getPixel(setValue + (previousY || 0));
      xPos = (0, _polarUtil.getCoordinates)({
        radius: chartConfig.canvasTop + chartConfig.canvasHeight / 2 - yPos,
        theta: i
      }, xAxis);
      // xPos = xAxis.getPixel(i, (chartConfig.canvasTop + chartConfig.canvasHeight / 2) - yPos);
      Py = xPos.y;
      Px = xPos.x;

      config._Px = Px;
      config._Py = Py;
      config._Pbx = Px;
      config._Pby = Py;
    }
  };
  /**
   * Gets the path for the line plot.
   * @param {Object} data data object
   * @param {Object} lastObj last valid object
   * @param {Object} positions position object
   * @param {boolean} type represents whether it is of type 'base'
   * @return {Object} path details
   */


  RadarDataset.prototype.getLinePath = function getLinePath(data, lastObj, positions, type) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        chartConfig = chart.config,
        obj = lastObj || {},

    // Used for determining whether the last value was valid
    // Initially it is false
    lastValidValue = obj.lastValidValue || false,
        temp = obj.temp || [],
        temp2 = obj.temp2 || [],
        pathArr = obj.pathArr || [],
        i,
        config,
        xPos,
        yPos,
        length = data.length,
        pointsJoined = obj.pointsJoined || 0,
        dataObj,
        setValue,
        startPos = positions && positions.begin || 0,
        endPos = positions && positions.end || length,
        step = chartConfig.viewPortConfig.step || 1,
        yAxis = dataset.getFromEnv('yAxis'),
        xAxis = dataset.getFromEnv('xAxis'),
        baseZero = yAxis.getPixel(0),
        removeDataLen = dataset.removeDataLen || 0,
        dataWithRemovedPaths = [];
    removeDataLen = 0;
    // Added current dataStore to arr
    dataWithRemovedPaths = dataWithRemovedPaths.concat(data);

    for (i = startPos; i < endPos + removeDataLen; i += step) {
      dataObj = dataWithRemovedPaths[i];
      if (!dataObj) {
        continue;
      }

      config = dataObj.config;
      setValue = config.setValue;
      if (setValue === null || config && config.isSkipped === true) {
        // xPos = xAxis.getPixel(xAxis.getLimit().min).x;
        xPos = (0, _polarUtil.getCoordinates)({
          theta: xAxis.getLimit().min
        }, xAxis).x;
        yPos = yAxis.getPixel(yAxis.config.axisRange.min);
      } else {
        xPos = config._Px;
        yPos = config._Py;
      }

      // take base or zero y value for animation
      if (type === 'zero') {
        yPos = baseZero;
      } else if (type === 'base') {
        yPos = config._Pby;
      }
      if (lastValidValue) {
        if (temp.length) {
          pathArr = pathArr.concat(temp);
          temp = [];
          pointsJoined++;
        }
        // Push the upper x and y position to pathArr
        pathArr.push([L, xPos, yPos]);
      } else {
        // Push the upper x and y positions of area plot to temp
        temp.push([M, xPos, yPos]);
        // No points are joined when starting a new path
        pointsJoined = 0;
        lastValidValue = true;
      }
    }
    // If path is not closed and any points are joined then close the path
    if (pathArr[pathArr.length - 1] !== Z && pointsJoined > 0) {
      pathArr.push(Z);
    }
    return {
      pathArr: pathArr,
      path2Arr: [],
      lastValidValue: lastValidValue,
      pointsJoined: pointsJoined,
      temp: temp,
      temp2: temp2,
      getPathArr: dataset.getPathArr
    };
  };
  /**
   * Parses all the attributes for dataset level and set level
   * Called from init function of area class and line class
   * Both line and area attributes configuration is done here
   * @param {Object} datasetJSON the data provided by user
   * @return {boolean} false if datasetJSON is undefined
   */


  RadarDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.JSONData = datasetJSON;
    var dataset = this,
        conf = dataset.config,
        chart = dataset.getFromEnv('chart'),
        index = dataset.index,
        chartAttr = chart.getFromEnv('dataSource').chart,
        colorM = dataset.getFromEnv('color-manager'),
        JSONData = dataset.JSONData,
        plotColor = colorM.getPlotColor(index);
    _AreaDataset.prototype.configureAttributes.call(this, datasetJSON);
    conf.defaultPadding = {
      left: 0,
      right: 0
    };
    conf.plotfillcolor = (0, _lib.pluck)(JSONData.color, chartAttr.plotfillcolor, plotColor);
    conf.plotbordercolor = (0, _lib.pluck)(JSONData.plotbordercolor, chartAttr.plotbordercolor, chartAttr.areabordercolor, plotColor).split(COMMASTRING)[0];
    conf.fillColor = {
      color: conf.plotfillcolor + (conf.plotgradientcolor ? COMMASTRING + conf.plotgradientcolor : _lib.BLANKSTRING),
      alpha: conf.plotfillalpha,
      angle: conf.plotfillangle
    };
    conf.legendSymbolColor = conf.plotfillcolor;
  };
  /**
   * Function that return the nearest plot details
   * @param   {number} chartX x-axis position of the mouse cordinate
   * @param   {number} chartY y-axis position of the mouse cordinate
   * @return {Object} return an object with details of nearest plot and whether it is
   *                   hovered or not
   */


  RadarDataset.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        xAxis = dataset.getFromEnv('xAxis'),
        dataStore = dataset.components.data,
        pointObj,
        xMin,
        xMax,
        len = dataStore.length,
        returnValue,
        conf = dataset.config,
        divAngle = 360 / len,
        i;

    xMin = Math.floor(Math.max((0, _polarUtil.getPlotFromPixel)({
      x: chartX - conf.maxRadius,
      y: chartY
    }, xAxis) / divAngle - 1, 0));

    xMax = Math.floor(Math.max((0, _polarUtil.getPlotFromPixel)({
      x: chartX + conf.maxRadius,
      y: chartY
    }, xAxis) / divAngle, len - 1));

    for (i = xMax; i >= xMin; i--) {
      pointObj = dataStore[i];
      if (pointObj) {
        returnValue = dataset.isWithinShape(pointObj, i, chartX, chartY);
        if (returnValue) {
          break;
        }
      }
    }

    return returnValue;
  };

  /**
   * Returns the details of the plot in the category band that the givennt x and y co-ordinates
   * are in.
   *
   * @param {number} [chartX=0] x-axis position of the mouse cordinate
   * @param {number} [chartY=0] y-axis position of the mouse cordinate
   *
   * @return {Object} Return an object with details of nearest plot in the category band.
   */


  RadarDataset.prototype.getPlotInCategoryAt = function getPlotInCategoryAt(chartX, chartY) {
    var plots = this.components.data,
        categoryAxis = this.getFromEnv('xAxis'),
        isDatasetVisible = this.getState('visible'),
        hoveredCategoryIndex = Math.round((0, _polarUtil.getPlotFromPixel)({
      x: chartX,
      y: chartY
    }, categoryAxis)),
        foundPlot = _find2['default'].call(plots, function (plot, idx, plotArr) {
      var plotCategoryIndex = void 0,
          nextPlotCategoryIndex = void 0,
          prevPlotCategoryIndex = void 0,
          halfCategoryDiff = void 0,
          nextPlot = void 0,
          prevPlot = void 0;

      if (idx === 0) {
        nextPlot = plotArr[idx + 1];
        // For the first plot, the previous plot will be the last plot in the array of plots
        prevPlot = plotArr[plotArr.length - 1];
      } else if (idx === plotArr.length - 1) {
        // For the last plot, the next plot will be the first plot in the array of plots
        nextPlot = plotArr[0];
        prevPlot = plotArr[plotArr.length - 2];
      } else {
        // For any other plot just select the plot immediately before and after the current plot
        nextPlot = plotArr[idx + 1];
        prevPlot = plotArr[idx - 1];
      }
      // plotCategoryIndex = categoryAxis.getAngle(plot.config._Px, plot.config._Py);
      plotCategoryIndex = (0, _polarUtil.getPlotFromPixel)({
        x: plot.config._Px,
        y: plot.config._Py
      }, categoryAxis);

      // For the last plot, the category band will end at 360 degrees
      nextPlotCategoryIndex = idx === plotArr.length - 1 ? 360 :
      // categoryAxis.getAngle(nextPlot.config._Px, nextPlot.config._Py);
      (0, _polarUtil.getPlotFromPixel)({
        x: nextPlot.config._Px,
        y: nextPlot.config._Py
      }, categoryAxis);
      // prevPlotCategoryIndex = categoryAxis.getAngle(prevPlot.config._Px, prevPlot.config._Py);
      prevPlotCategoryIndex = (0, _polarUtil.getPlotFromPixel)({
        x: prevPlot.config._Px,
        y: prevPlot.config._Py
      }, categoryAxis);
      // The angle at which the category ends and the next category starts
      halfCategoryDiff = (nextPlotCategoryIndex - plotCategoryIndex) / 2;

      if (hoveredCategoryIndex <= 0 + halfCategoryDiff) {
        // If the mouse is over an angle less than where the first category ends
        return hoveredCategoryIndex >= 0 && hoveredCategoryIndex <= 0 + halfCategoryDiff;
      } else if (hoveredCategoryIndex > 360 - halfCategoryDiff) {
        // If the mouse is over an angle greater than where the last category band ends
        return hoveredCategoryIndex >= 360 - halfCategoryDiff && hoveredCategoryIndex <= 360;
      } else {
        return hoveredCategoryIndex >= prevPlotCategoryIndex + halfCategoryDiff && hoveredCategoryIndex <= nextPlotCategoryIndex - halfCategoryDiff;
      }
    }),
        hoveredPlotInfo = this._getHoveredPlot(chartX, chartY);

    if (isDatasetVisible && hoveredPlotInfo) {
      // If dataset is visible and the mouse is exactly over a plot
      return hoveredPlotInfo;
    } else if (isDatasetVisible && foundPlot) {
      // If dataset is visible and the mouse is over a category band
      return {
        pointIndex: foundPlot._index,
        hovered: false,
        pointObj: foundPlot
      };
    } else {
      // If dataset is not visible and no relevant plot was found
      return false;
    }
  };

  /**
   * Function to register datasets in the internal data store of legend class.
   */


  RadarDataset.prototype._addLegend = function _addLegend() {
    var dataset = this,
        strokeColor,
        fillColor,
        config,
        conf = dataset.config,
        chartAttr = dataset.getFromEnv('chart-attrib'),
        legendItem,
        legend = dataset.getFromEnv('legend'),
        color = conf.legendSymbolColor,
        lightColor,
        use3DLighting = (0, _lib.pluckNumber)(chartAttr.use3dlighting, chartAttr.useplotgradientcolor, 1);
    strokeColor = getLightColor(color, 60).replace(dropHash, _lib.HASHSTRING);
    if (use3DLighting) {
      lightColor = getLightColor(color, 40);
      fillColor = {
        FCcolor: {
          color: color + ',' + color + ',' + lightColor + ',' + color + ',' + color,
          ratio: '0,70,30',
          angle: 270,
          alpha: '100,100,100,100,100'
        }
      };
    } else {
      fillColor = {
        FCcolor: {
          color: color,
          angle: 0,
          ratio: '0',
          alpha: '100'
        }
      };
    }
    config = {
      enabled: conf.includeInLegend,
      type: dataset.type,
      label: (0, _lib.getFirstValue)(dataset.JSONData.seriesname)
    };
    if (conf.includeinlegend) {
      legendItem = legend.getItem(dataset.config.legendItemId);
      if (!legendItem) {
        dataset.config.legendItemId = legend.createItem(dataset);
        legendItem = legend.getItem(dataset.config.legendItemId);
        dataset.addExtEventListener('click', function () {
          dataset.legendInteractivity(legendItem);
        }, legendItem);
      }
      legendItem.configure(config);
      legendItem.setStateCosmetics('default', {
        symbol: {
          fill: (0, _lib.toRaphaelColor)(fillColor),
          stroke: (0, _lib.toRaphaelColor)(strokeColor)
        }
      });
      // check if dataset is initiallyhidden
      if (!dataset.getState('visible')) {
        legendItem.setLegendState('hidden');
      }
    } else if (dataset.config.legendItemId) {
      legend.disposeItem(dataset.config.legendItemId);
    }
  };
  /**
   * Calculate current pos w.r.t prev for an array
   * @param   {Object}  path   current path
   * @param   {Object}  lim    x,y axis limits
   * @return {Array}          Old path
   */


  RadarDataset.prototype.getOldPath = function getOldPath(path, lim) {
    var dataSet = this,
        xLim = lim.x,
        yLim = lim.y,
        oldLim = dataSet.config && dataSet.config.prevLim,
        oldLimX = oldLim.x,
        oldLimY = oldLim.y,
        i = 0,
        ii = path.pathArr.length,
        item,
        arr = [],
        getOldValX = function getOldValX(val) {
      // getting ratio by pixels
      val = (val - oldLimX.minPixel.x) / (oldLimX.maxPixel.x - oldLimX.minPixel.x);
      // ratio to value
      val = val * (oldLimX.max - oldLimX.min) + oldLimX.min;
      // value in old ratio
      val = (val - xLim.min) / (xLim.max - xLim.min);
      // return position in previous
      return val * (xLim.maxPixel.x - xLim.minPixel.x) + xLim.minPixel.x + 1;
    },
        getOldValY = function getOldValY(val) {
      if (val < oldLimY.base && val > yLim.base || val > oldLimY.base && val < yLim.base) {
        val = yLim.base;
      }
      return val - 1;
    },
        getOldValYBase = function getOldValYBase(val) {
      if (val === oldLimY.base) {
        return yLim.base;
      }
      return getOldValY(val);
    };
    if (oldLimY.min === yLim.min && oldLimX.min === xLim.min && oldLimY.max === yLim.max && oldLimX.max === xLim.max) {
      return path;
    }
    path = (0, _lib.extend2)({}, path);
    if (!oldLim) {
      return arr;
    }
    // generating new copy of array
    path.pathArr = path.pathArr.slice(0);
    path.path2Arr = path.path2Arr.slice(0);
    for (i = ii; i--;) {
      item = path.pathArr[i].slice(0);
      // check if array
      if (!item[1] || !item.join) {
        continue;
      }
      item[1] = getOldValX(item[1]);
      item[2] = getOldValYBase(item[2]);
      path.pathArr[i] = item;
    }
    for (i = path.path2Arr.length; i--;) {
      item = path.path2Arr[i].slice(0);
      // check if array
      if (!item[1] || !item.join) {
        continue;
      }
      item[1] = getOldValX(item[1]);
      item[2] = getOldValYBase(item[2]);
      path.path2Arr[i] = item;
    }
    return path;
  };

  return RadarDataset;
}(_area2['default']);

exports['default'] = RadarDataset;

/***/ }),

/***/ 890:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _polarUtil = __webpack_require__(93);

exports['default'] = {
  'initial.dataset.radar': function initialDatasetRadar() {
    return {
      'anchor.appearing': function anchorAppearing() {
        return [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          startEnd: {
            start: 0.5,
            end: 1
          },
          slot: 'plot'
        }];
      },
      'anchor.updating': function anchorUpdating() {
        return [{
          initialAttr: {
            opacity: 0
          },
          finalAttr: {
            opacity: 1
          },
          slot: 'final'
        }];
      },
      'anchor.disappearing': function anchorDisappearing() {
        return [{
          finalAttr: {
            opacity: 0,
            'fill-opacity': 0,
            'stroke-opacity': 0
          },
          slot: 'final'
        }];
      },
      'line.appearing': function lineAppearing(inputJSON) {
        var dataset = inputJSON.component,
            xAxis = dataset.getFromEnv('xAxis'),
            yAxis = dataset.getFromEnv('yAxis'),
            catLen = xAxis.getTicksLen(),
            chartConfig = dataset.getFromEnv('chartConfig'),
            finalAttr = inputJSON.attr,
            value = chartConfig.canvasTop + chartConfig.canvasHeight / 2,
            initialPath = [],
            i = void 0;
        for (i = 0; i < catLen; i++) {
          initialPath.push(i ? 'L' : 'M');
          initialPath.push((0, _polarUtil.getCoordinates)({
            radius: value,
            theta: 0
          }, xAxis).x);
          initialPath.push(yAxis.getPixel(0));
        }
        initialPath.push('Z');
        return [{
          initialAttr: {
            opacity: 0,
            path: initialPath
          },
          finalAttr: {
            opacity: 1,
            path: finalAttr.path
          },
          startEnd: {
            start: 0,
            end: 0.5
          },
          slot: 'middle'
        }];
      },
      'label.appearing': [{
        initialAttr: {
          opacity: 0
        },
        finalAttr: {
          opacity: 1
        },
        slot: 'final'
      }],
      '*': null
    };
  }
};

/***/ }),

/***/ 891:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var canvas = chart.getChildren('canvas')[0],
      config = chart._feedAxesRawData(),
      axisRefVisual = canvas.getChildren('axisRefVisualPolar')[0],
      yAxis = void 0,
      xAxis = void 0,
      redraw = function redraw() {
    return axisRefVisual.asyncDraw();
  };
  (0, _lib.componentFactory)(chart, _numeric2['default'], 'yAxis', 1, config.yAxisConf);
  (0, _lib.componentFactory)(chart, _polar2['default'], 'xAxis', 1, config.xAxisConf);

  yAxis = chart.getChildren('yAxis')[0];
  xAxis = chart.getChildren('xAxis')[0];

  yAxis.setLinkedItem('canvas', canvas);
  axisRefVisual.setLinkedItem(yAxis.getId(), yAxis);
  axisRefVisual.setLinkedItem(xAxis.getId(), xAxis);

  axisRefVisual.addExtEventListener('visiblerangeset', redraw, xAxis);
  axisRefVisual.addExtEventListener('visiblerangeset', redraw, yAxis);

  canvas.attachAxis(xAxis, false, {});
  canvas.attachAxis(yAxis, true, {});

  chart._setCategories();
};

var _numeric = __webpack_require__(69);

var _numeric2 = _interopRequireDefault(_numeric);

var _polar = __webpack_require__(892);

var _polar2 = _interopRequireDefault(_polar);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 892:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _axis = __webpack_require__(201);

var _axis2 = _interopRequireDefault(_axis);

var _lib = __webpack_require__(5);

var _polarUtil = __webpack_require__(93);

var _diff = __webpack_require__(87);

var _diff2 = _interopRequireDefault(_diff);

var _polarAnimation = __webpack_require__(893);

var _polarAnimation2 = _interopRequireDefault(_polarAnimation);

var _dependencyManager = __webpack_require__(6);

var _assign = __webpack_require__(54);

var _assign2 = _interopRequireDefault(_assign);

var _category = __webpack_require__(310);

var _category2 = _interopRequireDefault(_category);

var _commonApi = __webpack_require__(55);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */


var UNDEF,
    DASH_DEF = 'none',

// PXSTRING = 'px',
POINTER = 'pointer',
    NORMALSTRING = 'normal',
    EVENTARGS = 'eventArgs',
    POSITION_MIDDLE = _lib.preDefStr.POSITION_MIDDLE,
    POSITION_START = _lib.preDefStr.POSITION_START,
    POSITION_TOP = _lib.preDefStr.POSITION_TOP,
    POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
    POSITION_END = _lib.preDefStr.POSITION_END,

// M = 'M',
math = Math,
    mathMin = math.min,
    pi = math.PI,
    pi2 = 2 * pi,

// pInt = function (s, mag) {
//   return parseInt(s, mag || 10);
// },
// labelFontBdrColor,
convertColor = _lib.graphics.convertColor;

(0, _dependencyManager.addDep)({
  name: 'polarAnimation',
  type: 'animationRule',
  extension: _polarAnimation2['default']
});

/**
 * Creates the Polar axis class
 * @class
 */

var Polar = function (_Axis) {
  _inherits(Polar, _Axis);

  /**
   * adding animation rules
   */
  function Polar() {
    _classCallCheck(this, Polar);

    var _this = _possibleConstructorReturn(this, _Axis.call(this));

    _this.config.scale = new _category2['default']();
    _this.config.referenceInfo = [];
    return _this;
  }
  /**
   * Sets the name of the component
   * @return {string} name
   */


  Polar.prototype.getName = function getName() {
    return 'polarCategory';
  };

  /**
   * Sets default config
   *
   * @memberof Polar
   */


  Polar.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _Axis.prototype.__setDefaultConfig && _Axis.prototype.__setDefaultConfig.call(this);
    this.config.drawPlotBands = false;
  };

  /**
   * Prepare the axis attributes for use by the chart drawing. It applies default values to the
   * options that are undefined.
   * @param  {Object}  rawAttr The raw attributes to be set
   */


  Polar.prototype.configureAttributes = function configureAttributes(rawAttr) {
    var axis = this,
        axisConfig = axis.config,
        axisAttr = rawAttr,
        chart = axis.getFromEnv('chart'),
        jsonData = chart.getFromEnv('dataSource'),
        FCChartObj = jsonData.chart,
        colorM = axis.getFromEnv('color-manager');
    _Axis.prototype.configureAttributes.call(this, rawAttr);
    axisConfig.gridLineColor = convertColor((0, _lib.pluck)(axisAttr.radarSpikeColor, colorM.getColor('divLineColor')), (0, _lib.pluckNumber)(axisAttr.radarSpikeAlpha, axisAttr.radarInLineAlpha, colorM.getColor('divLineAlpha')));
    axisConfig.radarSpikeThickness = (0, _lib.pluckNumber)(FCChartObj.radarspikethickness, 1);
    // labelFontBdrColor = labelFontBdrColor ? convertColor(
    //   labelFontBdrColor, pluckNumber(FCChartObj.labelborderalpha,
    //     FCChartObj.labelalpha, 100)) : BLANKSTRING;
    // axisConfig.labels.style = {
    //   fontFamily: pluck(axisAttr.labelFont, axisAttr.outCanfontFamily),
    //   fontSize: pluckNumber(axisAttr.labelFontSize, pInt(axisAttr.outCanfontSize)) + PXSTRING,
    //   fontWeight: pluckNumber(axisAttr.labelFontBold) ? 'bold' :
    //     NORMALSTRING,
    //   fontStyle: pluckNumber(axisAttr.labelFontItalic) ? 'italic' :
    //     NORMALSTRING,
    //   color: convertColor(pluck(axisAttr.labelFontColor, axisAttr.outCancolor),
    //     pluckNumber(axisAttr.labelFontAlpha, 100)),
    //   labelLink: FCChartObj.labellink,
    //   border: labelFontBdrColor || FCChartObj.labelbgcolor ?
    //     (pluckNumber(FCChartObj.labelborderthickness, 1) + 'px solid') : '',
    //   borderColor: labelFontBdrColor,
    //   borderThickness: pluckNumber(FCChartObj.labelborderthickness, 1),
    //   borderPadding: pluckNumber(FCChartObj.labelborderpadding, 2),
    //   borderRadius: pluckNumber(FCChartObj.labelborderradius, 0),
    //   backgroundColor: FCChartObj.labelbgcolor ?
    //     convertColor(FCChartObj.labelbgcolor,
    //       pluckNumber(FCChartObj.labelbgalpha, FCChartObj.labelalpha,
    //         100)) : BLANKSTRING,
    //   borderDash: pluckNumber(FCChartObj.labelborderdashed, 0) ?
    //     getDashStyle(pluckNumber(FCChartObj.labelborderdashlen, 4),
    //       pluckNumber(FCChartObj.labelborderdashgap, 2)) : DASH_DEF
    // };
    // axisConfig.categoryNumDivLines = pluckNumber(axisConfig.numDivLines, 0);
  };

  /**
   * Function set the starting point for drawing the axis and the axis drawing width/height
   * @param {Object} data Contains the x, y, length and whether the axis is drawn on the opposite side
   */


  Polar.prototype.setAxisDimention = function setAxisDimention(data) {
    var axis = this,
        scale = axis.getScale(),
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        startAngle = axisConfig.startAngle || -pi / 2,
        totalAngle = axisConfig.totalAngle || -pi2,
        endAngle = startAngle + totalAngle,
        rangeArr = void 0,
        category = axisConfig.tickValues.tickValue || [],
        anglePerSlice = totalAngle / (category.length || 1),
        axisDimention = axisConfig.axisDimention || (axisConfig.axisDimention = {});

    axisDimention.opposite = (0, _lib.pluckNumber)(data.opposite, axisDimention.opposite);
    axisDimention.centerX = (0, _lib.pluckNumber)(data.x, axisDimention.x, chartConfig.canvasLeft);
    axisDimention.centerY = (0, _lib.pluckNumber)(data.y, axisDimention.y, chartConfig.canvasTop);
    axisDimention.axisLength = pi2;

    endAngle -= anglePerSlice;
    rangeArr = axisConfig.clockWise ? [endAngle, startAngle] : [startAngle, endAngle];
    scale.setRange(rangeArr);
  };
  /**
   * Parse category line attributes
   *
   * @memberof Polar
   */


  Polar.prototype._parseCategoryPlotLine = function _parseCategoryPlotLine() {
    var axis = this,
        axisConfig = axis.config,
        tickValue = axisConfig.tickValues.tickValue,
        plotLineColor = axisConfig.gridLineColor,
        plotLineWidth = axisConfig.radarSpikeThickness,
        axisAttrObj,
        referenceInfo = axisConfig.referenceInfo,
        i,
        value;

    axisAttrObj = {
      stroke: plotLineColor,
      'stroke-width': plotLineWidth
      // 'stroke-dasharray': plotLineDashStyle
    };
    // checking for pure tickValue axis exclude bubble scatter
    if (tickValue[0] && (tickValue[0].x !== UNDEF || tickValue[0].y !== UNDEF)) {
      return;
    }
    // checking if lines are to be drawn user can decide
    if (axisConfig.lines.isDraw && axisConfig.numDivLines) {
      for (i = 0; i < tickValue.length; ++i) {
        value = i;

        referenceInfo.push({
          from: value,
          type: 'line',
          layer: 1,
          attr: axisAttrObj
        });
      }
    }
  };
  /**
   * Function called by the chart when there is requirement to calculate or recalculate the space
   * management this function must be called every time when chart dimension is changed
   * @param {number} width The maximum width that is available for space management
   * @param {number} height The maximum height that is available for space management
   * @return {Object} Left and right defining how much space is used in left and right
   */


  Polar.prototype.placeAxis = function placeAxis(width, height) {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        smartLabel = chart.getFromEnv('smartLabel'),
        labelStyle = axisConfig.labels.style,
        categories = chart.getFromEnv('dataSource').categories,
        axisValuePadding = axisConfig.labelPadding = (0, _lib.pluckNumber)(axisConfig.rawAttr.axisValuePadding, 10),
        useEllipsesWhenOverflow = axisConfig.useEllipsesWhenOverflow,
        top = 0,
        left = 0,
        right = 0,
        bottom = 0,
        avalTop = height / 2,
        avalBottom = height / 2,
        avalRight = width / 2,
        avalLeft = width / 2,
        i,

    // text,
    // allCategories = axisConfig.categories && axisConfig.categories.category,
    allCategories = axisConfig.tickValues && axisConfig.tickValues.tickValue,
        categoryLength,
        singleCategory,
        smartLabelText,
        categoriesStyle,
        categoryStyle,
        smartLabelStyle,
        smartLabelStyleLineHeight;
    // TODO : so space management for category

    axisConfig.labels.isDraw = 1;
    axisConfig.labels.drawNormalVal = 1;
    axisConfig.labels.drawLimitVal = 1;

    if (!axis.components) {
      axis.components = {};
    }
    axis.components.labels = [];
    // The style for the catergories
    if (axisConfig.showLabels) {
      if (categories) {
        var firstCategory = categories[0];
        categoriesStyle = {
          fontFamily: firstCategory.font,
          fontSize: firstCategory.fontsize,
          color: firstCategory.fontcolor
        };
      }
      for (i = 0, categoryLength = allCategories.length; i < categoryLength; i++) {
        singleCategory = allCategories[i];
        // Style for the individuel category
        categoryStyle = {
          fontFamily: singleCategory.font,
          fontSize: singleCategory.fontsize,
          fontWeight: singleCategory.fontbold ? 'bold' : NORMALSTRING,
          fontStyle: singleCategory.fontitalic ? 'italic' : NORMALSTRING
        };
        // the final style for smart label of that individual category label
        smartLabelStyle = {
          fontFamily: (0, _lib.pluck)(categoryStyle.fontFamily, categoriesStyle.fontFamily, labelStyle.fontFamily),
          fontSize: (0, _lib.pluck)(categoryStyle.fontSize, categoriesStyle.fontSize, labelStyle.fontSize),
          fontWeight: (0, _lib.pluck)(categoryStyle.fontWeight, labelStyle.fontWeight),
          fontStyle: (0, _lib.pluck)(categoryStyle.fontStyle, labelStyle.fontStyle)
        };

        smartLabelStyleLineHeight = (0, _lib.setLineHeight)(smartLabelStyle);

        smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
        smartLabel.setStyle(smartLabelStyle);

        // Make a copy of actual category label
        singleCategory.oriLabel === UNDEF && (singleCategory.oriLabel = singleCategory.label);
        if (i === 0) {
          smartLabelText = smartLabel.getSmartText(singleCategory.oriLabel, width, mathMin(smartLabelStyleLineHeight, avalTop), useEllipsesWhenOverflow);

          singleCategory.label = smartLabelText.text;

          smartLabelText.width += axisValuePadding;
          smartLabelText.height += axisValuePadding;

          if (smartLabelText.height > top) {
            top = smartLabelText.height;
            bottom = top;
          }
        } else if (i === categoryLength / 2) {
          smartLabelText = smartLabel.getSmartText(singleCategory.oriLabel, width, mathMin(smartLabelStyleLineHeight, avalBottom), useEllipsesWhenOverflow);

          singleCategory.label = smartLabelText.text;

          smartLabelText.width += axisValuePadding;
          smartLabelText.height += axisValuePadding;

          if (smartLabelText.height > bottom) {
            bottom = smartLabelText.height;
          }
        } else if (i < categoryLength / 2) {
          smartLabelText = smartLabel.getSmartText(singleCategory.oriLabel, avalLeft, smartLabelStyleLineHeight, useEllipsesWhenOverflow);

          singleCategory.label = smartLabelText.text;

          smartLabelText.width += axisValuePadding;
          smartLabelText.height += axisValuePadding;

          if (smartLabelText.width > left) {
            left = smartLabelText.width;
          }
        } else {
          smartLabelText = smartLabel.getSmartText(singleCategory.oriLabel, avalRight, smartLabelStyleLineHeight, useEllipsesWhenOverflow);

          singleCategory.label = smartLabelText.text;

          smartLabelText.width += axisValuePadding;
          smartLabelText.height += axisValuePadding;

          if (smartLabelText.width > right) {
            right = smartLabelText.width;
          }
        }

        // Store width and height of labels
        axis.components.labels.push({
          config: {
            props: {
              label: {
                attr: {
                  width: smartLabelText.width,
                  height: smartLabelText.height
                }
              }
            }
          }
        });
      }
    }
    return {
      top: top,
      left: left,
      right: right,
      bottom: bottom
    };
  };
  /**
   * Calculates the parameters necessary to draw the components of the chart.
   * In addition, it also calculates and draws the axis labels and ticks
   */


  Polar.prototype._drawComponents = function _drawComponents() {
    var axis = this,
        axisConfig = axis.config;
    axisConfig.drawLabels && axisConfig.hasCategory && axis._drawCategory();
  };

  /**
   * Parses axis cosmetics and positions during post space management
   *
   * @memberof Polar
   */


  Polar.prototype.allocatePosition = function allocatePosition() {
    var axis = this,
        axisConfig = axis.config;

    axisConfig.drawLabels && axisConfig.hasCategory && axis._parseCategory();
  };
  /**
   * Parses the position and parsing of categories during post space management
   *
   * @memberof Polar
   */


  Polar.prototype._parseCategory = function _parseCategory() {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        isOpposit = axisConfig.isOpposit,
        labels = axisConfig.labels,
        style = labels.style,
        categoryLabel = axis.config.categoryLabel || (axis.config.categoryLabel = {}),
        categories = chart.getFromEnv('dataSource').categories,
        category = axisConfig.tickValues.tickValue,
        axisPadding = axisConfig.labelPadding,
        categoriesStyle = {},
        categoryStyle = {},
        centerX = axisConfig.axisDimention.centerX,
        centerY = axisConfig.axisDimention.centerY,
        i,
        max,
        min,
        curCategory,
        text,
        labelRotation,
        labelLineHeight,
        addCategoryPadding,
        css,
        axisAttrObj,
        fontColor,
        pos,
        curCategoryValue,
        posX,
        posY,
        radius,
        radiusXY,
        theta,
        axisScale = axis.getScale(),
        catStyle,
        id,
        textId;

    radius = (0, _lib.pluckNumber)(axisConfig.radius, 0);
    min = 0;
    max = category ? category.length - 1 : 0;

    // checking if labels are to be drawn user can decide or can be decided by axis placeAxis function
    if (axisConfig.labels.isDraw) {
      if (categories) {
        var cat0 = categories[0];
        categoriesStyle.fontFamily = cat0.font;
        categoriesStyle.fontSize = cat0.fontsize;
        categoriesStyle.color = cat0.fontcolor;
      }
      // main loop where the drawing starts
      for (i = min; i <= max; i++) {
        curCategory = category[i];
        // TODO : need to
        curCategoryValue = (0, _lib.pluckNumber)(curCategory.x, curCategory.y, i);
        // if values are not limit value and label drawing is off other
        // than limit increment it and continue
        if (!axisConfig.labels.drawNormalVal && !(axisConfig.labels.drawLimitVal && (i === min || curCategoryValue === max))) {
          continue;
        }
        if (!axisConfig.labels.drawNormalVal && !(curCategoryValue === min || curCategoryValue === max)) {
          continue;
        }
        // if value are limit value but limit value are not mean to be drawn
        if (!axisConfig.labels.drawLimitVal && (curCategoryValue === min || curCategoryValue === max)) {
          continue;
        }
        categoryStyle = {
          fontFamily: (0, _lib.pluck)(curCategory.font, curCategory.labelfont),
          fontSize: (0, _lib.pluck)(curCategory.fontsize, curCategory.labelfontsize),
          fontWeight: (0, _lib.pluckNumber)(curCategory.fontbold, curCategory.labelfontbold, 0) ? 'bold' : UNDEF,
          fontStyle: (0, _lib.pluckNumber)(curCategory.fontitalic, curCategory.labelfontitalic, 0) ? 'italic' : UNDEF
        };

        fontColor = convertColor((0, _lib.pluck)(curCategory.fontcolor, curCategory.labelfontcolor, categoriesStyle.color, style.color), (0, _lib.pluckNumber)(curCategory.labelalpha, axisConfig.rawAttr.labelFontAlpha, 100));
        css = {
          fontFamily: (0, _lib.pluck)(categoryStyle.fontFamily, categoriesStyle.fontFamily, style.fontFamily),
          fontSize: (0, _lib.pluck)(categoryStyle.fontSize, categoriesStyle.fontSize, style.fontSize),
          fontWeight: (0, _lib.pluck)(categoryStyle.fontWeight, style.fontWeight),
          fontStyle: (0, _lib.pluck)(categoryStyle.fontStyle, style.fontStyle)
        };

        css.lineHeight = (0, _lib.setLineHeight)(css);

        if (css.lineHeight) {
          labelLineHeight = css.lineHeight;
          if (labelLineHeight.indexOf('px') !== -1) {
            labelLineHeight = labelLineHeight.replace(/px/i, '');
            labelLineHeight = parseFloat(labelLineHeight);
          }
        }

        // make the attribute ready to use
        // y-axis
        theta = axisScale.getRangeValue(curCategoryValue);
        pos = (0, _polarUtil.polarToCartesian)(radius + axisPadding, theta);
        pos.x += centerX;
        pos.y += centerY;
        posX = pos.x;
        posY = pos.y;

        text = curCategory.label || '';
        if ((0, _lib.pluckNumber)(curCategory.showlabel, 1) === 0 || axisConfig.showLabels === 0) {
          text = '';
        }
        addCategoryPadding = curCategory.labelPadding || 0;
        axisAttrObj = {
          fill: fontColor,
          'line-height': labelLineHeight,
          'font-size': style.fontSize,
          'text': text,
          cursor: curCategory.link ? POINTER : '',
          'x': posX,
          'y': posY
        };
        if (addCategoryPadding) {
          axisAttrObj.y += addCategoryPadding;
        }
        if (labelRotation) {
          axisAttrObj['text-anchor'] = isOpposit ? POSITION_START : POSITION_END;
          axisAttrObj['vertical-align'] = 'center';
        } else {
          axisAttrObj['vertical-align'] = isOpposit ? POSITION_BOTTOM : POSITION_TOP;
        }

        if (i === 0) {
          axisAttrObj['text-anchor'] = POSITION_MIDDLE;
          axisAttrObj['vertical-align'] = POSITION_BOTTOM;
        } else if (i === (max + 1) / 2) {
          axisAttrObj['text-anchor'] = POSITION_MIDDLE;
          axisAttrObj['vertical-align'] = POSITION_TOP;
        } else if (i < (max + 1) / 2) {
          axisAttrObj['text-anchor'] = POSITION_END;
          axisAttrObj['vertical-align'] = 'center';
        } else {
          axisAttrObj['text-anchor'] = POSITION_START;
          axisAttrObj['vertical-align'] = 'center';
        }

        theta = axisScale.getRangeValue(curCategoryValue);
        radiusXY = (0, _polarUtil.polarToCartesian)(radius, theta);
        radiusXY.x += centerX;
        radiusXY.y += centerY;
        // If labels shift is applicable (Specially for 3D) then apply the changes
        if (labels.shiftX) {
          axisAttrObj.x += labels.shiftX;
        }
        if (labels.shiftY) {
          axisAttrObj.y += labels.shiftY;
        }

        // CategoryLabel is not present, create it.
        categoryLabel = axisConfig.categoryLabel = categoryLabel || {};
        // Create/reuse category label
        textId = 'Label' + (id || i);

        categoryLabel[textId] = categoryLabel[textId] || {};
        categoryLabel[textId].config = categoryLabel[textId].config || {};

        categoryLabel[textId].config.labelBox = catStyle = {
          label: text,
          lineHeight: css.lineHeight,
          border: (0, _lib.pluckNumber)(curCategory.borderthickness, curCategory.labelborderthickness) ? (0, _lib.pluckNumber)(curCategory.borderthickness, curCategory.labelborderthickness, 1) + 'px solid' : '',
          borderColor: curCategory.bordercolor || curCategory.labelbordercolor ? convertColor(curCategory.bordercolor || curCategory.labelbordercolor, (0, _lib.pluckNumber)(curCategory.borderalpha, curCategory.labelborderalpha, curCategory.alpha, curCategory.labelalpha, 100)) : _lib.BLANKSTRING,
          borderThickness: (0, _lib.pluckNumber)(curCategory.borderthickness, curCategory.labelborderthickness),
          borderPadding: (0, _lib.pluckNumber)(curCategory.borderpadding, curCategory.labelborderpadding),
          borderRadius: (0, _lib.pluckNumber)(curCategory.borderradius, curCategory.labelborderradius),
          backgroundColor: curCategory.bgcolor || curCategory.labelbgcolor ? convertColor(curCategory.bgcolor || curCategory.labelbgcolor, (0, _lib.pluckNumber)(curCategory.bgalpha, curCategory.labelbgalpha, curCategory.alpha, curCategory.labelalpha, 100)) : _lib.BLANKSTRING,
          borderDash: (0, _lib.pluckNumber)(curCategory.borderdashed, curCategory.labelborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(curCategory.borderdashlen, curCategory.labelborderdashlen, 4), (0, _lib.pluckNumber)(curCategory.borderdashgap, curCategory.labelborderdashgap, 2)) : (0, _lib.pluckNumber)(curCategory.borderdashed, curCategory.labelborderdashed) === 0 ? DASH_DEF : style.borderDash
        };
        // Set the categorylabel text-bound cosmetics
        categoryLabel[textId].config.labelBox['text-bound'] = !text ? [] : [(0, _lib.pluck)(catStyle.backgroundColor, style.backgroundColor), (0, _lib.pluck)(catStyle.borderColor, style.borderColor), (0, _lib.pluck)(catStyle.borderThickness, style.borderThickness), (0, _lib.pluck)(catStyle.borderPadding, style.borderPadding), (0, _lib.pluck)(catStyle.borderRadius, style.borderRadius), (0, _lib.pluck)(catStyle.borderDash, style.borderDash)];

        axisAttrObj['text-bound'] = categoryLabel[textId].config.labelBox['text-bound'];

        axis.components.labels[i].config.props.label.css = css;
        axis.components.labels[i].config.props.label.attr = (0, _assign2['default'])(axis.components.labels[i].config.props.label.attr, axisAttrObj);
      }
    }
  };
  /**
   * Draws the category labels of the axis
   */


  Polar.prototype._drawCategory = function _drawCategory() {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        animationManager = chart.getFromEnv('animationManager'),
        labels = axisConfig.labels,
        style = labels.style,
        axisContainer = axisConfig.axisContainer,
        category = axisConfig.tickValues.tickValue,
        raiseEvent = function raiseEvent(event) {
      return function (data) {
        var ele = this;
        _lib.plotEventHandler.call(ele, chart, data, event);
      };
    },
        counter = 0,
        i,
        max,
        min,
        curCategory,
        textElement,
        css,
        axisAttrObj,
        curCategoryValue,
        removeElem,
        id,
        textId,
        mapArr = [],
        removeElementsArr,
        removeFn = function removeFn() {
      this.remove();
    },

    /**
     * Removes element which are required anymore.
     * @param {any} arrOfId array
     */
    removeElements = function removeElements(arrOfId) {
      for (i = 0; i < arrOfId.length; ++i) {
        removeElem = axis.getGraphicalElement(arrOfId[i]);
        axis.removeGraphicalElement(animationManager.setAnimation({
          el: removeElem,
          container: axisContainer,
          callback: removeFn,
          component: axis,
          label: 'polarLabel'
        }));
      }
    };

    min = 0;
    max = category ? category.length - 1 : 0;

    // checking if labels are to be drawn user can decide or can be decided by axis placeAxis function
    if (axisConfig.labels.isDraw) {
      // main loop where the drawing starts
      for (i = min, counter = 0; i <= max; i++) {
        curCategory = category[i];
        // TODO : need to
        curCategoryValue = (0, _lib.pluckNumber)(curCategory.x, curCategory.y, i);
        // if values are not limit value and label drawing is off other
        // than limit increment it and continue
        if (!axisConfig.labels.drawNormalVal && !(axisConfig.labels.drawLimitVal && (i === min || curCategoryValue === max))) {
          continue;
        }
        if (!axisConfig.labels.drawNormalVal && !(curCategoryValue === min || curCategoryValue === max)) {
          continue;
        }
        // if value are limit value but limit value are not mean to be drawn
        if (!axisConfig.labels.drawLimitVal && (curCategoryValue === min || curCategoryValue === max)) {
          continue;
        }
        textId = 'Label' + (id || i);
        mapArr.push(textId);

        axisAttrObj = axis.components.labels[i].config.props.label.attr;
        css = axis.components.labels[i].config.props.label.css;

        textElement = axis.getGraphicalElement(textId);
        textElement = animationManager.setAnimation({
          css: css,
          el: textElement || 'text',
          attr: axisAttrObj,
          container: axisContainer,
          component: axis,
          label: 'polarLabel'
        });

        // Attach/remove tooltip
        if (axisConfig.showTooltip && curCategory.tooltext) {
          textElement.tooltip(curCategory.tooltext);
          textElement.trackTooltip(true);
        } else {
          textElement.trackTooltip(false);
        }

        // Attach event handler to category label
        textElement.click(raiseEvent('datalabelclick')).hover(raiseEvent('dataLabelRollOver'), raiseEvent('dataLabelRollOut'));

        textElement.data(EVENTARGS, {
          link: curCategory.link || curCategory.labellink || style.labelLink,
          text: axisAttrObj.text,
          index: counter
        });

        axis.addGraphicalElement(textId, textElement);

        counter += 1;
      }

      axisConfig.labelMap = axisConfig.labelMap || [];
      removeElementsArr = (0, _diff2['default'])(axisConfig.labelMap, mapArr);
    } else {
      removeElementsArr = mapArr;
    }
    axisConfig.labelMap = mapArr;
    removeElements(removeElementsArr);
  };

  /**
   * translation wil be for radar
   * @return {number} value 0
   */


  Polar.prototype.getTranslation = function getTranslation() {
    if (this) return 0;
  };

  /**
   * returns the reference info
   * @return {Array} array of object
  */


  Polar.prototype.getReferenceInfo = function getReferenceInfo() {
    return this.config.referenceInfo;
  };

  /**
   * Sets the visible range of the axis. Also sets axis's reference values and re-calculates PVR.
   * @param  {number} minValue The minimum value of the area to be visible
   * @param  {number} maxValue The maximum value of the area to be visible
   * @return {boolean} Whether the visible range of the axis was successfully set or not
   */


  Polar.prototype.setVisibleConfig = function setVisibleConfig(minValue, maxValue) {
    var axis = this,
        axisConfig = axis.config,
        scale = axis.getScale(),
        domain = void 0;

    if (minValue >= maxValue || minValue < axisConfig.axisRange.min || maxValue > axisConfig.axisRange.max) {
      return false;
    }

    domain = scale.setDomain([minValue, maxValue]).getDomain();
    axisConfig.visibleMin = domain[0];
    axisConfig.visibleMax = domain[1];

    axis.clearReferenceInfo();

    axis._parseReferenceVisuals();

    axis.asyncDraw();

    axis.fireEvent('visiblerangeset', { minValue: minValue, maxValue: maxValue });

    return true;
  };

  /**
   * will call api for parsing reference visuals
  */


  Polar.prototype._parseReferenceVisuals = function _parseReferenceVisuals() {
    this.config.drawPlotlines && this._parseCategoryPlotLine();
  };

  /**
   * will clear the reference visuals
  */


  Polar.prototype.clearReferenceInfo = function clearReferenceInfo() {
    var axisConfig = this.config;
    axisConfig.referenceInfo = [];
  };

  return Polar;
}(_axis2['default']);

Polar.prototype.setTickValues = _commonApi.setTickValues;
Polar.prototype._setAxisRange = _commonApi._setAxisRangeCategory;
Polar.prototype.shiftLabels = _commonApi.shiftLabels;
Polar.prototype._createContainer = _commonApi._createContainer;
Polar.prototype.setAxisPadding = _commonApi.setAxisPadding;
Polar.prototype.getPixel = _commonApi.getPixel;
Polar.prototype.getLabel = _commonApi.getLabel;

exports['default'] = Polar;

/***/ }),

/***/ 893:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _polarAxisAnimation = __webpack_require__(231);

var _polarAxisAnimation2 = _interopRequireDefault(_polarAxisAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.axis.polar': function initialAxisPolar() {
    return {
      'path.appearing': _polarAxisAnimation2['default'],
      'text.appearing': _polarAxisAnimation2['default']
    };
  }
};

/***/ }),

/***/ 894:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (chart) {
  var pCanvas = void 0;
  (0, _lib.componentFactory)(chart, _polarCanvas2['default'], 'canvas', chart.config.showVolumeChart ? 2 : 1);
  pCanvas = chart.getChildren('canvas');
  for (var i = 0, len = pCanvas.length; i < len; i++) {
    pCanvas[i].configure();
    (0, _lib.componentFactory)(pCanvas[i], _axisRefPolarComponent2['default'], 'axisRefVisualPolar');
  }
};

var _polarCanvas = __webpack_require__(895);

var _polarCanvas2 = _interopRequireDefault(_polarCanvas);

var _axisRefPolarComponent = __webpack_require__(896);

var _axisRefPolarComponent2 = _interopRequireDefault(_axisRefPolarComponent);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),

/***/ 895:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _canvas2 = __webpack_require__(104);

var _canvas3 = _interopRequireDefault(_canvas2);

var _polarUtil = __webpack_require__(93);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var polarCanvas = function (_canvas) {
  _inherits(polarCanvas, _canvas);

  function polarCanvas() {
    _classCallCheck(this, polarCanvas);

    return _possibleConstructorReturn(this, _canvas.apply(this, arguments));
  }

  /**
   * Returns name of component
   *
   * @return {any}
   * @memberof polarCanvas
   */
  polarCanvas.prototype.getName = function getName() {
    return 'polarCanvas';
  };

  /**
   * Returns type of component
   *
   * @return {any}
   * @memberof polarCanvas
   */


  polarCanvas.prototype.getType = function getType() {
    return 'canvas';
  };

  polarCanvas.prototype.configureAttributes = function configureAttributes() {
    _canvas.prototype.configureAttributes.call(this);
    var canvas = this,
        canvasConfig = canvas.config,
        chart = canvas.getFromEnv('chart'),
        JSONData = chart.getFromEnv('dataSource'),
        FCChartObj = JSONData.chart,
        colorM = chart.getFromEnv('color-manager');

    canvasConfig.radarBorderColor = (0, _lib.convertColor)((0, _lib.pluck)(FCChartObj.radarbordercolor, colorM.getColor('divLineColor')), (0, _lib.pluckNumber)(FCChartObj.radarborderalpha, 100));
    canvasConfig.radarFillColor = (0, _lib.convertColor)((0, _lib.pluck)(FCChartObj.radarfillcolor, colorM.getColor('altHGridColor')), (0, _lib.pluckNumber)(FCChartObj.radarfillalpha, colorM.getColor('altHGridAlpha')));
    canvasConfig.radarBorderThickness = (0, _lib.pluckNumber)(FCChartObj.radarborderthickness, 2);
    canvasConfig.showRadarBorder = (0, _lib.pluckNumber)(FCChartObj.showradarborder, 1);
  };

  /**
   * Draws group and canvas
   *
   * @memberof polarCanvas
   */


  polarCanvas.prototype.draw = function draw() {
    this.createGroup();
    this.drawCanvas();
  };

  /**
   * Draws the radar border and background
   *
   * @memberof polarCanvas
   */


  polarCanvas.prototype.drawCanvas = function drawCanvas() {
    var canvas = this,
        canvasConfig = this.config,
        chart = canvas.getFromEnv('chart'),
        chartConfig = chart.config,
        axis = chart.getChildren('xAxis')[0],
        animationManager = chart.getFromEnv('animationManager'),
        radarBorderContainerDummy = canvas.getContainer('radarBorderContainer'),
        radarBorderContainer = void 0,
        canvasGroup = canvas.getContainer('canvasGroup'),
        axisConfig = axis.config,
        radarBorderAttrObj = {
      stroke: canvasConfig.radarBorderColor,
      fill: canvasConfig.radarFillColor,
      'stroke-width': canvasConfig.radarBorderThickness,
      path: ['M']
    },
        i = void 0,
        category = axisConfig.tickValues.tickValue,
        min = void 0,
        max = void 0,
        theta = void 0,
        axisScale = axis.getScale(),
        radiusXY = void 0,
        radius = void 0,
        radBorderDummy = canvas.getGraphicalElement('radarBorder'),
        radarBorder = void 0,
        centerX = axisConfig.axisDimention.centerX,
        centerY = axisConfig.axisDimention.centerY;

    radius = (0, _lib.pluckNumber)(axisConfig.radius, 0);
    min = 0;
    max = category ? category.length - 1 : 0;

    canvasConfig.canvasLeft = canvasConfig.canvasLeft || chartConfig.canvasLeft;
    canvasConfig.canvasTop = canvasConfig.canvasTop || chartConfig.canvasTop;
    canvasConfig.canvasWidth = canvasConfig.canvasWidth || chartConfig.canvasWidth;
    canvasConfig.canvasHeight = canvasConfig.canvasHeight || chartConfig.canvasHeight;

    if (axisConfig.showRadarBorder !== 0) {
      for (i = min; i <= max; i++) {
        theta = axisScale.getRangeValue(i);
        radiusXY = (0, _polarUtil.polarToCartesian)(radius, theta);
        radiusXY.x += centerX;
        radiusXY.y += centerY;
        radarBorderAttrObj.path.push(radiusXY.x, radiusXY.y, 'L');
      }
      radarBorderAttrObj.path.pop();
      radarBorderAttrObj.path.push('Z');
    }

    radarBorderContainer = animationManager.setAnimation({
      el: radarBorderContainerDummy || 'group',
      attr: {
        name: 'radarBorderContainer'
      },
      container: canvasGroup,
      component: canvas,
      label: 'group'
    });

    if (!radarBorderContainerDummy) {
      canvas.addContainer('radarBorderContainer', radarBorderContainer);
    }
    // Create/Reuse rabBorder0
    radarBorder = animationManager.setAnimation({
      el: radBorderDummy || 'path',
      attr: radarBorderAttrObj,
      container: radarBorderContainer,
      component: axis,
      dom: 'path'
    });

    if (!radBorderDummy) {
      canvas.addGraphicalElement('radarBorder', radarBorder);
    }
    // axis.config.radarBorder = radarBorder;
  };

  return polarCanvas;
}(_canvas3['default']);

exports['default'] = polarCanvas;

/***/ }),

/***/ 896:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _axisRefComponent = __webpack_require__(209);

var _axisRefComponent2 = _interopRequireDefault(_axisRefComponent);

var _polarUtil = __webpack_require__(93);

var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(6);

var _axisRefPolarAnimation = __webpack_require__(897);

var _axisRefPolarAnimation2 = _interopRequireDefault(_axisRefPolarAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }
// import { getCrispPath } from '../axis/numeric';


var M = 'M',
    Z = 'Z',
    L = 'L',
    getRadius = function getRadius(axis, point) {
  var scale = axis.getScale(),
      range = axis.config.axisRange;

  return Math.abs(scale.getRangeValue(point) - scale.getRangeValue(range.min));
};
(0, _dependencyManager.addDep)({
  name: 'axisRefPolarAnimation',
  type: 'animationRule',
  extension: _axisRefPolarAnimation2['default']
});

var AxisRefPolarVisual = function (_AxisRefComponent) {
  _inherits(AxisRefPolarVisual, _AxisRefComponent);

  function AxisRefPolarVisual() {
    _classCallCheck(this, AxisRefPolarVisual);

    return _possibleConstructorReturn(this, _AxisRefComponent.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  AxisRefPolarVisual.prototype.getType = function getType() {
    return 'axisRefVisuals';
  };
  /**
   * Sets the name of the component
   * @return {string} name
   */


  AxisRefPolarVisual.prototype.getName = function getName() {
    return 'axisRefVisualsPolar';
  };
  /**
   * Decides the type of line to draw
   *
   * @param {any} lineInfo
   * @param {any} axis
   * @memberof AxisRefPolarVisual
   */


  AxisRefPolarVisual.prototype.createLine = function createLine(lineInfo, axis) {
    var axisRef = this;
    if (axis.getName() === 'polarCategory') {
      return axisRef.createNormalLine(lineInfo, axis);
    } else if (axis.getName() === 'numeric') {
      return axisRef.createRadialLine(lineInfo, axis);
    }
  };

  /**
   * Creates radial line
   *
   * @param {any} lineInfo
   * @param {any} axis
   * @returns {any}
   * @memberof AxisRefPolarVisual
   */


  AxisRefPolarVisual.prototype.createRadialLine = function createRadialLine(lineInfo, axis) {
    var axisRef = this,
        xAxis = axisRef.getFromEnv('xAxis')[0],
        xAxisConfig = xAxis.config,
        category = xAxisConfig.tickValues.tickValue,
        yAxis = axis,
        axisRefConfig = axisRef.config,
        containersArr = axisRefConfig.containers,
        container = containersArr[lineInfo.layer],
        animationManager = axisRef.getFromEnv('animationManager'),
        toolTipController = axisRef.getFromEnv('toolTipController'),
        i = void 0,
        key = void 0,
        min = void 0,
        max = void 0,
        radius = void 0,
        lineAttr = lineInfo.attr,
        pathAr = [M],
        coordinate = void 0,
        compId = yAxis.getId(),
        eleId = lineInfo.id || lineInfo.from,
        lineEleId = compId + '_' + eleId,
        handlers = lineInfo.handlers,
        element = axisRef.getGraphicalElement(lineEleId);

    radius = getRadius(yAxis, eleId);
    min = 0;
    max = category ? category.length - 1 : 0;

    for (i = min; i <= max; i++) {
      coordinate = (0, _polarUtil.getCoordinates)({
        radius: radius,
        theta: i
      }, xAxis);
      pathAr.push(coordinate.x, coordinate.y, L);
    }
    pathAr.pop();
    pathAr.push(Z);

    lineAttr.path = pathAr;

    element = axisRef.addGraphicalElement(lineEleId, animationManager.setAnimation({
      container: container,
      el: element || 'path',
      attr: lineAttr,
      component: axisRef,
      label: 'path'
    }));

    if (lineInfo.toolText) {
      toolTipController.enableToolTip(element, lineInfo.toolText);
    } else {
      toolTipController.disableToolTip(element);
    }

    for (key in handlers) {
      if (handlers.hasOwnProperty(key)) {
        element.on(key, handlers[key].bind(axis));
      }
    }
    return [lineEleId];
  };

  /**
   * Draws normal line
   *
   * @param {any} lineInfo
   * @param {any} axis
   * @memberof AxisRefPolarVisual
   */


  AxisRefPolarVisual.prototype.createNormalLine = function createNormalLine(lineInfo, axis) {
    var axisRef = this,
        axisRefConfig = axisRef.config,
        axisConfig = axis.config,
        radius = (0, _lib.pluckNumber)(axisConfig.radius, 0),
        pathAr = [M],
        containersArr = axisRefConfig.containers,
        container = containersArr[lineInfo.layer],
        animationManager = axisRef.getFromEnv('animationManager'),
        toolTipController = axisRef.getFromEnv('toolTipController'),
        coordinate = void 0,
        key = void 0,
        centerX = axisConfig.axisDimention.centerX,
        centerY = axisConfig.axisDimention.centerY,
        compId = axis.getId(),
        eleId = lineInfo.id || lineInfo.from,
        lineEleId = compId + '_' + eleId,
        handlers = lineInfo.handlers,
        element = axisRef.getGraphicalElement(lineEleId);

    pathAr.push(centerX, centerY, L);
    coordinate = (0, _polarUtil.getCoordinates)({
      radius: radius,
      theta: lineInfo.from
    }, axis);

    pathAr.push(coordinate.x, coordinate.y);
    lineInfo.attr.path = pathAr;

    element = axisRef.addGraphicalElement(lineEleId, animationManager.setAnimation({
      container: container,
      el: element || 'path',
      attr: lineInfo.attr,
      component: axisRef,
      label: 'path'
    }));

    if (lineInfo.toolText) {
      toolTipController.enableToolTip(element, lineInfo.toolText);
    } else {
      toolTipController.disableToolTip(element);
    }

    for (key in handlers) {
      if (handlers.hasOwnProperty(key)) {
        element.on(key, handlers[key].bind(axis));
      }
    }
    return [lineEleId];
  };
  // eslint-disable-next-line


  AxisRefPolarVisual.prototype.createBand = function createBand() {
    // super.createBand(x, y);
  };

  return AxisRefPolarVisual;
}(_axisRefComponent2['default']);

exports['default'] = AxisRefPolarVisual;

/***/ }),

/***/ 897:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _polarAxisAnimation = __webpack_require__(231);

var _polarAxisAnimation2 = _interopRequireDefault(_polarAxisAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  'initial.axis.axisRefVisualsPolar': function initialAxisAxisRefVisualsPolar() {
    return {
      'path.appearing': _polarAxisAnimation2['default'],
      'text.appearing': _polarAxisAnimation2['default']
    };
  }
};

/***/ })

},[776])["default"];
});
//# sourceMappingURL=fusioncharts.powercharts.js.map